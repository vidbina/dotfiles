#+OPTIONS: html5-fancy:t
#+HTML_DOCTYPE: html5
#+STARTUP: overview
#+TODO: TODO WIP PROTOTYPE(p@) READY(p@) | DONE CANCELED(c@)
#+TITLE: Emacs ü¶¨ Configuration

This is an emoji-heavy üòÖ literal[fn:1] configuration for [[https://www.gnu.org/software/emacs/][Emacs]] which is definitely not as feature complete like some distros out there (think: [[https://github.com/hlissner/doom-emacs][Doom Emacs]] or [[https://www.spacemacs.org/][Spacemacs]]) but may still provide you a pragmatic and easily parsable configuration that sticks to standard tooling üß∞ and patterns while providing sufficient context as to what is happening such that beginners[fn:2] can also have a good time cooking üë®üèø‚Äçüî¨ up or tweaking üë®üèø‚Äçüîß their configurations.

* Installation

I manage both my Emacs installation and my Emacs configuration declaratively. A [[nix-config][home-manager configuration written in Nix]] manages the version and bundle of Emacs on my system while classic Emacs LISP manages the Emacs configuration itself.

#+begin_center
‚ö†Ô∏è In case you don't use Nix ‚ùÑÔ∏è or can't be bothered to dive into it (in the same way I can't be bothered to remember the different build instructions for the tools that I depend on), please skip the part where I [[install-hm][install Emacs with home-manager]] and focus on the [[install-manual][manual installation]] instructions instead.
#+end_center

** <<install-hm>> Install with Home-Manager

My Emacs version is pretty up-to-date as per [2022-06-30 Thu 14:06] and was built entirely through my Nix configuration since I don't want to be bothered in terms on tooling in figuring out how to rebuild Emacs from scratch whenever needed.

#+begin_src elisp :results verbatim :exports both
(emacs-version)
#+end_src

#+RESULTS:
: "GNU Emacs 29.0.50 (build 1, x86_64-pc-linux-gnu, X toolkit, cairo version 1.16.0, Xaw scroll bars)"

The good bit about home-manager is that is will go as far as setting up home directories for me as well so there is little that I need to manually do other than the following steps:

1. clone this repo to a path of choice (e.g.: =~/src/THIS_REPO=)
2. to install either
   1. my entire config:
      1. enter root of the repo and
      2. run =make install=
   2. or just my Emacs-related config:
      1. borrow ideas from [[file:default.nix]] (or [[file:default-darwin.nix]] for macOS users) and place them into your own home-manager configuration
3. profit üí∞

** <<install-manual>> Install manually

<<emacsconfdir>>
#+begin_center
‚ö†Ô∏è For this configuration we will refer to your /emacs configuration directory/ as =~/.emacs.d= for historic and didactic reasons, but it may be =~/.config/emacs= in your case. Consult [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Find-Init.html][How Emacs Finds Your Init File]] for explanation on how Emacs loads configurations and note that every mention of =~/.emacs.d= in this literate config assumes that you substitute it for your actual /emacs configuration directory/.
#+end_center

Clone this repository and symlink =~/.emacs.d= into the =emacs= directory of this configuration:
1. clone this repo to a path of choice (e.g.: =~/src/THIS_REPO=)
2. symlink =~/.emacs.d=[fn:3] to the =emacs= subdirectory of the cloned project (e.g.: =ln -s ~/src/THIS_REPO/emacs ~/.emacs.d=)
3. optionally, populate =~/.emacs.d/lang.el= or =~/.emacs.d/personal.el= (refer to [[*Usage][Usage]] for instructions)
4. reload your config or restart Emacs (e.g.: I have to run =systemctl --restart emacs.service= on NixOS since I am running Emacs as a systemd-managed service)

‚ö†Ô∏è Note that we are in subdirectory =emacs= of a dotfiles repository here which is all examples of commands or paths are written from the perspective of the [[file:..][top-level]] directory of this repository.

* Usage

Use this configuration by changing [[file:README.org][this README.org file]], the only source of truth, and tangling it to produce the Emacs LISP files [[file:early-init.el]], [[file:init.el]], [[file:lang.el]] and [[file:personal-example.el]] along with the relevant Nix configuration files [[file:default.nix]] and [[file:default-darwin.nix]] using the ~(org-babel-tangle)~ function which is mapped to =C-c C-v C-t= or =C-c C-v t= by default.

The files of this configuration are as follows:
- [[file:README.org]] :: source of truth that describes the entire configuration and tangles into the Elisp files listed below
- [[file:early-init.el]] :: configuration that is loaded before the GUI and package system are started (see [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html][The Early Init File]])
- [[file:init.el]] :: primary configuration file that Emacs loads on start (see [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html][The Emacs Initialization File]]),
- [[file:lang.el]] :: optional configuration file for language-specific settings, and
- [[file:personal-example.el]] :: reference for [[file:personal.el]] where you can add your personally sensitive configuration.
- [[file:personal.el]] :: optional configuration file for personal setting which can be populated by copying [[file:personal-example.el]] for to get started and modifying the code as necessary
- [[file:default.nix]] :: Nix home-manager configuration for GNU/Linux systems
- [[file:default-darwin.nix]] :: Nix home-manager configuration for Darwin system (macOS)

#+begin_src dot :file images/conf-setup.png :exports results
digraph G {
  subgraph cluster_emacs {
    label="Emacs load process"
    node_earlyinit [shape=box, label="early-init.el", style=filled]
    node_init [shape=box, label="init.el", style=filled]
    node_personal [shape=box, label="personal.el", style=filled]
    node_lang [shape=box, label="lang.el", style=filled]

    node_init -> node_personal [label="loads"]
    node_init -> node_lang [label="loads"]
  }

  node_this [shape=box, label="README.org"]
  node_personal_example [shape=box, label="personal-example.el"]
  node_default_nix [shape=box, style=dotted, label="default.nix"]
  node_default_darwin_nix [shape=box, style=dotted, label="default-darwin.nix"]

  node_this -> node_earlyinit [label="tangles to"]
  node_this -> node_init [label="tangles to"]
  node_this -> node_default_nix [label="tangles to", style=dotted]
  node_this -> node_default_darwin_nix [label="tangles to", style=dotted]
  node_personal_example -> node_personal [style=dotted]
}
#+end_src

#+RESULTS:
[[file:images/conf-setup.png]]

For convenience's sake, let's start stubbing some of the files that we will be tangling from this literate configuration.

** Tangle providence notice

#+begin_src elisp :noweb-ref tangle-providence
;; Tangled from dotfiles/emacs/README.org

#+end_src

*** early-init.el

#+begin_src elisp :tangle early-init.el :noweb yes
<<tangle-providence>>
#+end_src

*** init.el

#+begin_src elisp :tangle init.el :noweb yes
<<tangle-providence>>
#+end_src

*** lang.el

‚ö†Ô∏è We only populate into an example file.

#+begin_src elisp :tangle lang.example.el :noweb yes
<<tangle-providence>>
#+end_src

*** personal.el

‚ö†Ô∏è We only populate into an example file.

#+begin_src elisp :tangle personal-example.el :noweb yes
<<tangle-providence>>
#+end_src

** early-init.el

The [[file:early-init.el]] will be loaded before our "real configuration" is evaluated. Some configuration settings may have to be set at this stage but this should be used sparingly as it may be an indication of poor configuration when one has to resort too often to configuring at this stage.

#+begin_src elisp :tangle early-init.el
(message "ü•± Loading early-init.el")
#+end_src

** init.el

We enabe lexical binding, since some packages (e.g.: consult) will require this.

#+begin_src elisp :tangle init.el
;; -*- lexical-binding: t -*-
#+end_src


#+begin_src elisp :tangle init.el
(message "üöú Loading init.el")
#+end_src

* üì¶ Package Management

Setting =package-enable-at-startup= to =nil= before the Emacs default package system even loads (i.e.: before *early-init.el*) minimizes the potential for global state to affect the configuration which ends up simplifying this configuration's use[fn:4].

#+begin_src elisp :tangle early-init.el
(setq package-enable-at-startup nil)
#+end_src

** Straight üçÄ

[[https://github.com/raxod502/straight.el#getting-started][Straight.el]] üçÄ is a popular package manager used to manage Emacs packages.

The primary advantage of using *straight.el* is the ability to _pin package version in a [[file:straight/versions/default.el][lockfile]]_ (e.g.: =~/.emacs.d/straight/versions/default.el=) in manner quite similar to how popular package managers such as Bundler (Ruby) and NPM (JavaScript) or Yarn (JavaScript) improve reproducibility of a configuration by pinning the versions of their packages in a dependency manifest (e.g.: Gemfile.lock for Bundler, package.lock for NPM and yarn.lock for Yarn).

*** ‚ö†Ô∏è Pre-bootstrap Work-around

The issue is that straight relies on the existence of variables with prefixes that have been renamed from =comp= to =native-comp=. So, if the installed variant of Emacs lacks native compilation capability, then straight will be bumping into undefined symbols.

#+begin_src elisp :tangle init.el
;; https://github.com/raxod502/straight.el/issues/757#issuecomment-839764260
(defvar comp-deferred-compilation-deny-list ())
#+end_src

Installation of the following packages may break when this block is disabled:
- straight
- [[*Org-contrib][org-contrib]]
- [[*Dockerfile][dockerfile-mode]]

*** ü•æ Bootstrap

#+begin_src elisp :tangle init.el
;; https://github.com/raxod502/straight.el#getting-started
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

*** Enabling the commonly-used *use-package* interface

For [[use-package-format][convenience]], we configure *straight.el* to use the *use-package* interface.

#+begin_src elisp :tangle init.el
;; https://github.com/raxod502/straight.el#integration-with-use-package
(straight-use-package 'use-package)
#+end_src

In order to improve visibility over package-related issues, we set =use-package-verbose= such that loading and configuration information is verbosely reported. The reporting output can be examined in the =*Messages*= buffer or in the logging output (.e.g: systemd journal in case Emacs is run as a systemd user unit or service).

#+begin_src elisp :tangle early-init.el
(setq use-package-verbose t)
#+end_src

<<use-package-format>>
If you've used Emacs for a while or have read through a few configurations, you have likely encountered a =use-package= declaration before. An association list (alist) style interface (of keyword[fn:5]-value pairs) is used by *use-package* to provide a pleasantly readable configuration structure.

The [[https://jwiegley.github.io/use-package/keywords/][Keywords]] page provides guidance as to how to use =use-package= keywords and the following snippet demonstrates the general structure of a =use-package= declaration:

#+begin_src elisp :results none
;; Just an example of a use-package form
(use-package my-package-y
  :straight t
  :after
  (:all my-package-a my-package-x)

  :init
  (setq my-package-coefficient 42)
  (message "Just a heads-up: we'll be setting up package y")

  :config
  (my-package-y-run-checks-after-load)
  (my-package-y-check-data-on-filesystem)
  (my-package-y-mode t)

  :bind (("C-c y 1" . my-package-y-do-thing-in-buffer)
         ("C-c y 2" . my-package-y-do-another-thing-in-buffer)))
#+end_src

#+begin_details org
#+HTML: <summary>Historic Context: Before use-package, package-specific configuration declarations may have been spread throughout a configuration and thus difficult to associate or debug.</summary>
For those familiar with classical Emacs configurations, you may recall that it wasn't uncommon to intersperse fragments of configurations of multiple packages in order to get everything loaded in the right order.

Compared to the earlier snippet in which the use of the *use-package* macro was demonstrated, a pre-*use-package* era configuration may have had the relevant declarations for a single package spread throughout a configuration.

#+begin_src elisp :results none
(setq my-package-coefficient 42)
(message "Just a heads-up: we'll be setting up package y")

;; ...

(require 'my-package-a)
(require 'my-package-x)

;; ...

(require 'my-package-y)
(my-package-y-run-checks-after-load)
(my-package-y-check-data-on-filesystem)
(my-package-y-mode t)

(add-hook 'my-package-y-mode
          (lambda ()
            (local-set-key (kbd "C-c y 1") 'my-package-y-do-thing-in-buffer)
            (local-set-key (kbd "C-c y 2") 'my-package-y-do-another-thing-in-buffer))
#+end_src

#+end_details

**** Organization

On the tidying up front, for example, you'll find that the *use-package* macro provides mechanisms to:
1. order the load sequence of packages by defining dependencies by means of the =:after= keyword
2. time application of parts of a configurations before or after /package load/ by means of the =:init= (i.e.: before load) and =:config= (i.e.: after load) keywords
3. bind keychords using the =:bind= keyword

**** Performance

On the performance front, you'll find that the *use-package* macro provides mechanisms to:
1. delay loading of packages by means of the =:defer= or =:demand= keywords
1. delay loading of packages needed in a particular mode or interpreter by means of the =:mode= or =:interpreter= keywords
2. define "as-of-yet not seen" symbols that will be needed for compilation by means of the =:functions= and =:defines= keywords

**** Ordering Management through Hooks

Emacs is a hot mess of global state sorcery and as such it may be useful to load packages or call package-specific functions in a particular order to render a configuration sufficiently functional. üôä

Using *use-package*, the =:after= and =:hook= keywords are probably the more powerful tools to manage the ordering of your packages.

The Emacs [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Startup-Summary.html#Startup-Summary][Startup Summary]] page outlines when the =before-init-hook=, =after-init-hook=, =emacs-startup-hook= and =window-setup-hook= are run.

For convenience, we define some hook to notify us in the *Messages* buffer when these different milestones are reached.

#+begin_src elisp :tangle early-init.el
(add-hook 'before-init-hook (lambda () (message "ü™ù Before init")))
(add-hook 'after-init-hook (lambda () (message "ü™ù After init")))
(add-hook 'emacs-startup-hook (lambda () (message "ü™ù Emacs startup")))
(add-hook 'window-setup-hook (lambda () (message "ü™ù Window setup")))
#+end_src

Through the =:hook= keyword, we can /hook/ operations for a particular package into to the previously listed Emacs lifecycle hooks without leaving the expression for that specific package -- thus keeping all relevant configurations neatly localized.

*** TODO Explain: Introspection

For troubleshootings sake it is helpful to know how to use function =straight-dependents=

#+begin_src elisp
;; test
(straight-dependents)
(straight-dependents 'org-roam)
(straight-dependencies)
(straight-dependencies 'org-roam)
#+end_src

* üìì Org

[[https://orgmode.org/worg/org-contrib/org-protocol.html][Org]] is probably the killer app of Emacs and is actually just a clearly standardized markup format. Three ways in which Org discerns itself from Markdown are in that it:
1. has a single clear standard (that is widely used) as opposed to Markdown that has a few variants floating about that exhibit slightly differing behavior[fn:6] and may present a bit of challenge for application developers that wish to implement the standard
2. natively allows for the notation of dates and times which allow for things like time-tracking and planning within a single document.
3. natively provides table support

#+begin_src elisp :noweb yes :tangle init.el :results none
;; https://orgmode.org/worg/org-contrib/org-protocol.html
;; https://github.com/org-roam/org-roam/issues/529
;; https://git.savannah.gnu.org/cgit/emacs/org-mode.git/
(use-package org
  :straight (:type built-in)
  :init
  (setq org-adapt-indentation nil ; https://orgmode.org/manual/Hard-indentation.html
        org-hide-leading-stars nil
        org-odd-levels-only nil)
  <<org-bind>>
  :config
  ;; https://orgmode.org/manual/Capture-templates.html#Capture-templates
  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-c d") 'org-hide-drawer-toggle)
  ;; https://www.reddit.com/r/emacs/comments/ldiryk/weird_tab_behavior_in_org_mode_source_blocks
  (setq org-src-preserve-indentation t
        org-hide-block-startup t)
  <<org-config>>
  :custom
  <<org-custom>>)
#+end_src

** Customizations

#+begin_src elisp :noweb-ref org-custom
(org-tags-column 0 "Avoid wrapping issues by minimizing tag indentation")
(org-catch-invisible-edits 'error "Disable invisible edits")
(org-src-window-setup 'current-window "Show edit buffer in calling window")
(org-refile-targets '((nil . (:maxlevel . 3))) "Allow refiling to 3rd level headings")
#+end_src

*** Default workflow states

To facilitate my [[https://orgmode.org/manual/Workflow-states.html][workflow states]], we define:
- TODO :: something we want to work on
- WIP :: something that is work-in-progress but not yet "usable"
- PROTOTYPE :: something that is "usable"
- CANCELED :: something that we aborted and we'll have to provide explanation
- +DONE+ :: something that works and is ready for prime-time
  - this state is struck-out because we should assume that any heading without a state is either done or not a task-like heading at all
  - in practice, I sometimes unstate headings with a =DONE= state after I feel enough time has passed to just turn them into boring headings

#+begin_src elisp :noweb-ref org-custom
(org-todo-keywords '((sequence "TODO(t)" "WIP(w)" "|" "DONE(d)" "CANCELED(@c)")) "Allow fast-selection for my standard TODO states")
#+end_src

After a while, we can drop the =DONE= state from headings to just promote them to regular "features". In fact, we may as well remove 

#+begin_src plantuml :file images/org-default-workflow-states.png :exports results
@startuml

state "TODO" as state_todo #yellow
state "WIP" as state_wip #yellow
state "PROTOTYPE" as state_prototype #yellow
state "CANCELED" as state_canceled #pink
state "DONE" as state_done #lightgreen

[*] -> state_todo
state_todo -> state_wip : stub concept
state_todo --> state_canceled : abort
state_wip -> state_prototype : release alpha/beta
state_wip --> state_canceled : abort
state_prototype -> state_done : release production
state_prototype --> state_canceled : abort
state_canceled --> state_todo : reboot
state_done -> [*]

@enduml
#+end_src

#+RESULTS:
[[file:images/org-default-workflow-states.png]]

** <<org-babel>> Org-Babel

*** PROTOTYPE <<org-babel-tangle>> Asynchronous Tangle
:LOGBOOK:
- State "PROTOTYPE"  from "WIP"        [2022-06-28 Tue 13:34] \\
  initial concept using =find-file= which may be inefficient but we'll eat the gun on account of the ease of use
:END:

Tangling sometimes takes a fair amount of time that we can't always afford to waste by simply waiting. The following =org-babel-tangle-async= function wraps the original =org-babel-tangle= call in an async handler in order to allow us to regain control of our buffer while Org does its tangling magic.

#+begin_src elisp :noweb yes :noweb-ref org-config
(defun org-babel-tangle-async (&optional arg target-file lang-re)
  "Call `org-babel-tangle' asynchronously"
  (interactive "P")
  (message "üß¨ Async Org-Babel start tangling %s" buffer-file-name)
  <<org-babel-tangle-async-start>>)
#+end_src

The =org-babel-map= is defined in org-keys.el and maps =t= and =C-t= to =org-babel-tangle= of which we only need one alternative mapped to the async variant. Since I use lower keystroke variant =C-v C-c t= most, we'll map that one to our async variant.

#+begin_src elisp :noweb-ref org-bind
:bind (:map org-babel-map ("t" . org-babel-tangle-async))
#+end_src

The async handler, doesn't have to copy over the buffer contents since saving is a prerequisite to tangling.

#+begin_src elisp :noweb-ref org-babel-tangle-async-start
(run-hooks 'org-babel-pre-tangle-hook)
#+end_src

The async handler disables the auto-save facility and clears the pre-tangle hooks (perhaps a bad idea ü§∑üèø‚Äç‚ôÇÔ∏è). We then just simply check that buffer-file-name is a string representing a valid file name and then open the file, navigate to point and trigger the intended [[(org-babel-tangle-call)][=org-babel-tangle= call]].

#+begin_center
It's unclear if the use of =find-file= is a really bad idea. I've considered that =with-temp-buffer= in combination with =insert= may be faster (see [[http://xahlee.info/emacs/emacs/elisp_find-file_vs_with-temp-buffer.html][Xahlee]]), but since we're tangling we'd need to spawn Org-mode anyways, so using =find-file= handles the major-mode switching for us to ensure that Org facilities are within reach. I may have to initialize packages if we need to mirror more of the configuration of the calling environment but we'll cross that bridge when we get there -- hence /prototype/. üêâ
#+end_center

#+begin_src elisp :noweb-ref org-babel-tangle-async-start
(async-start `(lambda ()
                (if (and (stringp ,buffer-file-name)
                         (file-exists-p ,buffer-file-name))
                    (progn
                      (setq exec-path ',exec-path
                            load-path ',load-path
                            enable-local-eval t
                            auto-save-default nil
                            org-babel-pre-tangle-hook '())
                      (package-initialize)
                      (find-file ,(buffer-file-name))
                      (read-only-mode t)
                      (goto-char ,(point))
                      (org-babel-tangle ,arg ,target-file ,lang-re) ; tangle! (ref:org-babel-tangle-call)
                      buffer-file-name)
                  (error "üß¨ Async Org-Babel is not visiting a file")))
             `(lambda (result)
                (message "üß¨ Async Org-Babel tangled %s" result)))
#+end_src

**** TODO Contrast current with =org-export-async-start= implementation

Is there something here that we can borrow to bring our implementation more in line with existing ways to handle async export.

*** WIP <<ox-html>> ox-html: Org-Babel HTML exporter

When exporting HTML, it is quite frustrating when the exported HTML conflicts with the current theme in Emacs. When I'm using the dark theme and switch to the browser to view the exported HTML, browser extensions like darkmode typically don't work on local files and thus switching between Emacs and the browser may result to a bit of a briefly-blinding constrast shock.

**** Background: Color retrieval from active theme

We define the following helper to retrieve currently active color foregrounds for a face of interest:

#+NAME: ox-html-get-color
#+begin_src elisp :var face='default :var attribute="foreground"
(let* ((sym (intern-soft (format ":%s" attribute)))
       (val (face-attribute face sym nil t))) ;; pass inherit 'nil to test none
  (if (or (null val) (eq 'unspecified val)) "none" (format "%s" val)))
#+end_src

Note that the default style is defined in =org-html-style-default= and is to be left alone (according to the Emacs docs). Observe the [[https://orgmode.org/manual/CSS-support.html
][CSS support]] documentation for some explanation of some of the CSS classes that are used by ox-html.

#+begin_src elisp
(face-attribute 'default :foreground nil t)
(face-attribute 'default :background nil t)
(face-attribute 'link :foreground nil t)
#+end_src

Note how we can use the =ox-html-get-color= block defined above to retrieve colors in a code block.

#+begin_src elisp :noweb no
(list :default <<ox-html-get-color(face='default)>>
      :link <<ox-html-get-color(face='link)>>
      :link-visited <<ox-html-get-color(face='link-visited)>>)
#+end_src

The resulting block with *noweb* is enabled, produces the following code:

#+begin_src elisp :noweb yes
(list :default "<<ox-html-get-color(face='default)>>"
      :link "<<ox-html-get-color(face='link)>>"
      :link-visited "<<ox-html-get-color(face='link-visited)>>")
#+end_src

**** CSS Template

The =ox-html-get-color= logic defined above can be used to template some CSS, agreeing with the current active theme in Emacs, that we can inject into exported HTML.

The variable =org-html-style-default= is not meant to be changed but the snippet below is derived therefrom and is drafted as a noweb template to aid in dynamically generating the needed CSS. We can tangle the snippet below into the [[file:ox-html.css][ox-html.css]] file that we can use in our templates.

#+begin_center
‚ö†Ô∏è Do not tangle this block async (so just use =org-babel-tangle=) because the theming information is not available when used through =org-babel-tangle-async=. I don't know why this is but this [[https://lists.gnu.org/archive/html/emacs-orgmode/2016-05/msg00191.html][thread]] may provide clues to a future debugger. üïµüèø‚Äç‚ôÇÔ∏è
#+end_center

#+begin_src css :noweb yes :exports code :tangle ox-html.css
body {
  background-color: <<ox-html-get-color(face='default, attribute="background")>>;
  color: <<ox-html-get-color(face='default)>>;
}
a {
  color: <<ox-html-get-color(face='link)>>;
}
.todo {
  color: <<ox-html-get-color(face='org-todo)>>;
}
.done   {
  color: <<ox-html-get-color(face='org-done)>>;
}
.priority {
  color: <<ox-html-get-color(face='org-priority)>>;
}
.tag    {
  color: <<ox-html-get-color(face='org-tag)>>;
  background-color: <<ox-html-get-color(face='org-tag, attribute="background")>>;
}
.timestamp {
  color: <<ox-html-get-color(face='org-date, attribute="foreground")>>;
}
.timestamp-kwd {
  color: <<ox-html-get-color(face='org-scheduled)>>;
}
pre {
    border-color: <<ox-html-get-color(face='org-block)>>;
    background-color:  <<ox-html-get-color(face='org-block, attribute="background")>>;
    color: <<ox-html-get-color(face='org-block)>>;
}
pre.src:before {
    color: <<ox-html-get-color(face='org-block-begin-line)>>;
    background-color: <<ox-html-get-color(face='org-block-begin-line, attribute="background")>>;
}
.inlinetask {
    color: <<ox-html-get-color(face='org-level-8)>>;
    background-color: <<ox-html-get-color(face='org-level-8, attribute="background")>>;
}
.code-highlighted {
  background-color: <<ox-html-get-color(face='region, attribute="background")>>;
}
.org-info-js_search-highlight {
  background-color: <<ox-html-get-color(face='region, attribute="background")>>;
  color: <<ox-html-get-color(face='region)>>;
}
#+end_src

*** TODO XeLaTeX instead of pdfLaTeX

The orgmode FAQ contains an entry on using [[https://orgmode.org/worg/org-faq.html#using-xelatex-for-pdf-export][XeLaTeX for LaTeX export instead of pdfLaTeX]] which we will use as a reference in order to simplify the export of my emoji-heavy files which are combined unicode characters which cause problems for pdfLaTeX.

*** Define reference to custom CS Template

In order to configure custom styling, we should define the string variable =org-html-head= (or its alias =org-html-style=) and clear =org-html-head-include-default-style=.

#+begin_src elisp :noweb-ref org-custom
(org-html-head (format "<link rel=\"stylesheet\" type=\"text/css\" href=\"%s\" />" (expand-file-name "ox-html.css" user-emacs-directory)) "Point to our custom stylesheet")
#+end_src

**** WIP CSS Generation Helpers

#+begin_src elisp
(defun vidbina/theme-switch-update-ox-html-css ()
  (let* ((colors '((:main-bg . (default :background))
                   (:main-fg . (default :foreground))
                   (:link-fg . (link :foreground))
                   (:todo-fg . (org-todo :foreground))
                   (:done-fg . (org-done :foreground))
                   (:prio-fg . (org-priority :foreground))
                   (:tag-fg . (org-tag :foreground))
                   (:tag-bg . (org-tag :background))
                   (:timestamp-fg . (org-date :foreground))
                   (:scheduled-fg . (org-scheduled :foreground))
                   (:org-block-fg . (org-block :foreground))
                   (:org-block-bg . (org-block :background))
                   (:org-block-edge-fg . (org-block-begin-line :foreground))
                   (:org-block-edge-bg . (org-block-begin-line :background))
                   (:org-block-edge-bg . (org-block-begin-line :background))
                   (:inlinetask-fg . (org-level-8 :foreground))
                   (:inlinetask-bg . (org-level-8 :background))
                   (:region-fg . (region :foreground))
                   (:region-bg . (region :background))
                   (:default . (default :foreground)))))
    (-> (mapcar
         (lambda (x)
           (let ((key (car x))
                 (val (pcase (cdr x)
                        (`(,a ,b) (let ((v (face-attribute a b nil t)))
                                    (if (eq 'unspecified v) nil (format "%s" v))))
                        (_ nil))))
             (list key (or val "none"))))
         colors)
        flatten-list))
  ;; TODO: Merge values into template
  )
#+end_src

** Tips

*** Peeking through Org buffers

When navigating large buffers of Org, one can quickly peek through parts of the buffer in order to return to continue editing text thereafter. Do this by entering =org-goto= which is bound to =C-c C-j= by default and then using =org-occur= which is bound to =/= by default to have a glance and finally return by =C-g=.

Note that entering org-occur pulls up a buffer that provides some instructions.

** Org-Tempo

[[https://orgmode.org/manual/Structure-Templates.html][Structure templates]] allow one to quickly produce convenient src or quote blocks with just three keypresses. For example
- =< s TAB= to produce a source block
- =< q TAB= to produce a quote block
- =< C TAB= to produce a comment block
- =< h TAB= and =< l TAB= to produce export blocks for HTML and LaTeX respectively

#+begin_src elisp :noweb-ref org-config
;; https://orgmode.org/manual/Structure-Templates.html
(require 'org-tempo)
#+end_src

*** TODO COMMENT Completions broken: jumping to next link or block instead

#+begin_center
‚ö†Ô∏è Unclear how to reproduce!
#+end_center

- when =ob-async-org-babel-execute-src-block= is highlighted through =C-;=

  =< s TAB= with the cursor at [[cursor]] breaks with the following profile

#+begin_src text
1448  79% - command-execute
1266  69%  - byte-code
1266  69%   - read-extended-command
1266  69%    - completing-read-default
1266  69%     - apply
1266  69%      - vertico--advice
1256  68%       + #<subr completing-read-default>
181   9%  - funcall-interactively
96   5%   - evil-open-below
2   0%    - evil-insert-newline-below
2   0%     - evil-move-end-of-line
2   0%      + move-end-of-line
2   0%    + evil-insert-state
1   0%    + indent-according-to-mode
61   3%   + evil-previous-visual-line
13   0%   + execute-extended-command
11   0%     iedit-next-occurrence
288  15% - ...
288  15%    Automatic GC
48   2% + timer-event-handler
23   1% + evil-normal-post-command
9   0% + redisplay_internal (C function)
2   0% + which-key--hide-popup
2   0% + evil--jump-hook
1   0% + evil-repeat-pre-hook
#+end_src

*** TODO COMMENT Fix =Marker does not point anywhere= error when attempting to complete tempo template

I sometimes get =Marker does not point anywhere= errors when attempting to insert snippets through, for example =<s=. Unable to reproduce, happens sporadically!

#+begin_src text
Debugger entered--Lisp error: (error "Marker does not point anywhere")
  tempo-insert-mark(#<marker at 63749 in README.org>)
  tempo-insert-template(tempo-template-org-src nil)
  tempo-complete-tag(fail)
  org-tempo-complete-tag()
  org-cycle(nil)
  funcall-interactively(org-cycle nil)
  command-execute(org-cycle)
#+end_src

#+begin_src elisp
(point-marker)
(tempo-insert-mark (point-marker))
;; run `(org-tempo-complete-tag)' with point at the end of the next line
<s
#+end_src

** Org $LaTeX$ Listing Source Wrapping

By default listings in LaTeX exports don't line-wrap which is really useless when you have blocks with long lines and are hoping for readable output in a printable form-factor -- not to say that you actually print it but hey... your e-reader may want that printable form-factor?!? ü§∑üèø‚Äç‚ôÇÔ∏è

The following configuration was stolen from [[https://www.reddit.com/r/emacs/comments/c1b70i/best_way_to_include_source_code_blocks_in_a_latex/][a Reddit thread]].

Figuring out how to get the ouput portrayed in a monospace font was informed by [[https://stackoverflow.com/a/2915765][a StackOverflow answer]] detailing how removal of the =column=flexible= option may help.

#+begin_src elisp :noweb-ref org-config
;; https://www.reddit.com/r/emacs/comments/c1b70i/best_way_to_include_source_code_blocks_in_a_latex/
(add-to-list 'org-latex-packages-alist '("" "listings" nil))
;;(setq org-latex-packages-alist nil)
;;(setq org-latex-listings t)
;;(setq org-latex-listings-options '(("breaklines" "true")))
(setq org-latex-listings t)
(setq org-latex-listings-options
      '(("basicstyle" "\\ttfamily")
        ("breakatwhitespace" "false")
        ("breakautoindent" "true")
        ("breaklines" "true")
        ;;("columns" "[c]fullflexible")
        ("commentstyle" "")
        ("emptylines" "*")
        ("extendedchars" "false")
        ;;("fancyvrb" "true")
        ("firstnumber" "auto")
        ("flexiblecolumns" "false")
        ("frame" "single")
        ("frameround" "tttt")
        ("identifierstyle" "")
        ("keepspaces" "true")
        ("keywordstyle" "")
        ("mathescape" "false")
        ("numbers" "left")
        ("numbers" "none")
        ("numbersep" "5pt")
        ("numberstyle" "\\tiny")
        ("resetmargins" "false")
        ("showlines" "true")
        ("showspaces" "false")
        ("showstringspaces" "false")
        ("showtabs" "true")
        ("stepnumber" "2")
        ("stringstyle" "")
        ("tab" "‚Üπ")
        ("tabsize" "4")
        ("texcl" "false")
        ("upquote" "false")))
#+end_src

** ox-clip: export Org fragments into HTML for rich-text input fields

The ox-clip exporters allow us to export fragments of our org documents into rich-text that is ready to paste into inputs on web apps. I use this frequently to copy org pieces into Google Docs or other online rich-text editors.

#+begin_src elisp :tangle init.el
;; https://github.com/jkitchin/ox-clip
;; https://zzamboni.org/post/my-emacs-configuration-with-commentary/
(use-package ox-clip
  :straight (ox-clip :type git
                     :host github
                     :repo "jkitchin/ox-clip")
  :after (org)
  :bind
  ("C-c y" . ox-clip-formatted-copy))
#+end_src

** phscroll

The [[https://github.com/misohena/phscroll][phscroll]] package allows to exclude some regions in a buffer from wrapping. This is really convenient when you have section with long lines that lose meaning when wrapped (or being unreadable) like rows from tables.

#+begin_src elisp :tangle init.el
;; https://github.com/misohena/phscroll
(use-package phscroll
  :straight (phscroll :type git
                      :host github
                      :repo "misohena/phscroll")
  :init
  (setq org-startup-truncated nil))
#+end_src

Some of the bindings to remember when in phscroll-mode are:

- =C-x <=, =C-x >= :: horizontally scroll
- =C-l= :: recenter top-bottom
- =C-S-l= :: recenter left-right
  - twice to scroll to *left edge*

** COMMENT htmlize

Running ~(straight-dependants "htmlize")~ yields =("ox-clip" ("org-ref" "org-roam-bibtex"))= so we define htmlize to control the version of htmlize that is installed since the implict configuration resulted to an outdated version of htmlize on my system.

:BACKGROUND:
Looking into htmlize started when stumbling upon errors in exporting Org blocks to HTML. Just export this entire file to HTML would eventually fail with =Invalid face: unspecified= to which I authored a [[https://github.com/hniksic/emacs-htmlize/pull/41/files][PR]] with a coarse fix.
:END:

#+begin_src elisp :noweb yes :tangle init.el
;; https://github.com/hniksic/emacs-htmlize
(use-package htmlize
  <<htmlize-straight-github-fork>>
  :init
  ;; https://www.reddit.com/r/orgmode/comments/5uj17n/invalid_face_error_when_publishing_org_to_html/
  (setq org-html-htmlize-output-type 'inline-css)
  :custom
  (htmlize-ignore-face-size t))
#+end_src

:DRAWER:
Running into the following pesky warning which is why this is still in WIP:

When using my fork on Github, I get:

#+begin_src text
Warning (straight): Two different recipes given for "htmlize" (:repo cannot be both "hniksic/emacs-htmlize" and "vidbina/emacs-htmlize") Disable showing Disable logging
#+end_src

When pointing straight to a local directory, I get:

#+begin_src text
Warning (straight): Two different recipes given for "htmlize" (:local-repo cannot be both "emacs-htmlize" and "~/src/vidbina/emacs-htmlize") Disable showing Disable logging
#+end_src

There was a dialog to resolve this by renaming one of the origins to =origin-1= and configuring the new target as =origin= but this broke in a manner that required me to drop into Dired or Magit to fix it anyways. I ended up removing the offending folder in the straight/repos directory.
:END:

*** Source from Github

The original repository is [[https://github.com/hniksic/emacs-htmlize][hniksic/emacs-htmlize]]:

#+begin_src elisp :noweb-ref htmlize-straight-github-original
:straight (htmlize :type git
                   :host github
                   :repo "hniksic/emacs-htmlize")
#+end_src

In order to refer to a self-cooked fix in a local-system independent way, I have a [[https://github.com/vidbina/emacs-htmlize][fork]] with a fix branch.

#+begin_src elisp :noweb-ref htmlize-straight-github-fork
:straight (htmlize :type git
                   :host github
                   :branch "fix-face-size-unspecified-head"
                   :repo "vidbina/emacs-htmlize")
#+end_src

*** Source Locally

For the testing of changes, I may opt to directly refer to a folder local to my system and ignore version control and consider the folder state authoritative to accellerate development.

#+begin_center
‚ö†Ô∏è Setting =:type nil= seems invalid.
#+end_center

#+begin_src elisp :noweb-ref htmlize-straight-local
:straight (htmlize :local-repo "~/src/vidbina/emacs-htmlize")
#+end_src

*** TODO Merge change to =htmlize-face-size= upstream

https://github.com/hniksic/emacs-htmlize/pull/41

** COMMENT ox-slimhtml

https://github.com/balddotcat/ox-slimhtml

#+begin_src elisp :tangle init.el
;; https://github.com/balddotcat/ox-slimhtml
(use-package ox-slimhtml
  :straight (ox-slimhtml :type git
                         :host github
                         :repo "balddotcat/ox-slimhtml")
  :after org
  :config
  (org-export-string-as "org content" 'slimhtml t)
  (org-export-to-buffer 'slimhtml "*slimhtml*")

  (org-export-define-derived-backend
      'custom-html-exporter
      'slimhtml                             ;; org's default exporter is 'html
    :translate-alist
    '((bold . ox-slimhtml-bold)             ;; technically, this is already set
      (special-block . org-html-special-block))))
#+end_src

** TODO Bibliography

*** ol-BibTeX (Org-BibTeX): Bibliography through org properties

The =ol-bibtex= package, previously known as =org-bibtex= and still prefixed as such, allows for the definition of bibliography entries within Org properties.

#+begin_src org
,** Introduction to Flight Test Engineering
:PROPERTIES:
:BIB_TITLE: Introduction to Flight Test Engineering
:BIB_BTYPE: techreport
:BIB_CUSTOM_ID: stoliker2005FTE
:BIB_AUTHOR: F.N. Stoliker
:BIB_INSTITUTION: RTO
:BIB_YEAR: 2005
:BIB_NUMBER: RTO-AG-300-V14
:BIB_DATE: 7/25/2005
:BIB_ADDRESS:
:BIB_MONTH: 07
:BIB_BIB_DOI: 10.14339/RTO-AG-300-V14
:BIB_BIB_ISBN: 92-837-1126-2
:BIB_NOTE:
:BIB_ANNOTE:
:END:

Some notes on this book...
#+end_src

The previously listed Org snippet will produce the following BibTeX entry:

#+begin_src bibtex
                  @techreport{stoliker2005FTE,
                    annote={},
                    note={},
                    isbn={92-837-1126-2},
                    doi={10.14339/RTO-AG-300-V14},
                    month={07},
                    address={},
                    date={7/25/2005},
                    number={RTO-AG-300-V14},
                    year={2005},
                    institution={RTO},
                    author={F.N. Stoliker},
                    custom_id={stoliker2005FTE},
                    title={Introduction to Flight Test Engineering}
                  }
#+end_src

Please note that *ol-bibtex* refers to an internal index =org-bibtex-types= that lists fields for every record type (e.g.: article, book, techreport, etc.) and only honors the entries that are listed therein.

Since, I sometimes need "arbitrary" fields such as =doi= that BibTeX itself may recognize but that the ol-bibtex package will simply ignore (for some bibliography types) as they are not listed in =org-bibtex-types=, it will be necessary to set =org-bibtex-export-arbitrary-types= to honor arbitrary fields which itself will require =org-bibtex-prefix= to also be set (which I set to =BIB_=). The caveat is that setting =org-bibtex-prefix= is an all-or-nothing type of deal and will require us to prefix all BibTeX properties (with =BIB_= in this particular configuration's case).

Another option may be for us to enhance =org-bibtex-headline= to be a bit smarter about honoring "known fields" in a properties block along with "arbitrary fields" as long as they are prefixed. This is only a partial solution as it only solves to problem of converting headlines to BibTeX entries, while the *ol-bibtex* package also helps reading valid BibTeX entries with =org-bibtex-read= and writing them into Org headlines with =org-bibtex-write= where the prefix is used for all entries indicating that prefixing everything is the expected behavior that allows for reliable and consistent bidirectional traffic (Org-to-BibTeX and BibTeX-to-Org).

#+begin_src elisp :tangle init.el
(use-package ol-bibtex
  :straight (:type built-in)
  :after org
  :custom
  (org-bibtex-prefix "BIB_" "Define prefix for arbitrary fields")
  (org-bibtex-export-arbitrary-fields t "Export prefixed fields"))
#+end_src

For reference's sake, note that for headers containing non-prefixed and prefixed fields, *ol-bibtex* will end up exporting the prefixed fields only.

#+begin_src org
,** Introduction to Flight Test Engineering
:PROPERTIES:
:TITLE:    Introduction to Flight Test Engineering
:BTYPE:    techreport
:CUSTOM_ID: stoliker2005FTE
:AUTHOR:   F.N. Stoliker
:INSTITUTION: RTO
:YEAR:     2005
:NUMBER:   RTO-AG-300-V14
:DATE:     7/25/2005
:ADDRESS:
:MONTH:    07
:BIB_DOI:  10.14339/RTO-AG-300-V14
:BIB_ISBN: 92-837-1126-2
:NOTE:
:ANNOTE:
:END:
#+end_src

The example listed above will yield the following BibTeX entry which demonstrates this point.

#+begin_src bibtex
                  @techreport{stoliker2005FTE,
                    isbn={92-837-1126-2},
                    doi={10.14339/RTO-AG-300-V14}
                  }
#+end_src

*** Org-contrib

#+begin_src elisp :tangle init.el
;; https://git.sr.ht/~bzg/org-contrib
(use-package org-contrib
  :straight (org-contrib :type git
                         :host nil
                         :repo "https://git.sr.ht/~bzg/org-contrib")
  :after org)
#+end_src

*** COMMENT Citar (formerly bibtex-actions)

#+begin_src elisp :tangle init.el
;; https://github.com/bdarcus/citar
(use-package citar
  :straight (citar :type git
                   :host github
                   :repo "bdarcus/citar")
  :no-require
  :custom
  (org-cite-insert-processor 'citar)
  (org-cite-follow-processor 'citar)
  (org-cite-activate-processor 'citar)
  :bind
  (:map org-mode-map :package org ("C-c b" . #'org-cite-insert)))
#+end_src

** üóÑÔ∏è Org-Roam

A good solution for maintaining a Zettelkasten-inspired note-taking system is [[https://github.com/org-roam/org-roam][Org-Roam]] which allows one to conveniently link related notes together.

#+CAPTION: Screenshot of Org-Roam in use with an Org-Roam-UI note network graph
[[file:images/screenshot-orui-org-cite-dark.png]]

#+begin_src elisp :tangle init.el :noweb yes
;; https://github.com/org-roam/org-roam
(use-package org-roam
  :straight (org-roam :type git
                      :host github
                      :repo "org-roam/org-roam")
  :after org
  :init
  (setq org-roam-v2-ack t)
  <<org-roam-init>>

  :config
  (message "üìî org-roam is loaded")
  <<org-roam-config>>

  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n i" . org-roam-node-insert)
         <<org-roam-bind>>))
#+end_src

*** Org-Roam Directory

Set the Org-Roam directory through variable =org-roam-directory= and keep in mind that this directory changes to the active directoy when switching between different Org-Roam directories.

#+begin_quote
üí° Multiple Org-Roam directories may be necessary to separate notes on a project or topic-specific basis.
#+end_quote

A possible workaround to trigger the tangling from the root directory thata contains all note directories and letting Org-Roam recursively walk through the file tree to visit all those directories.

#+begin_src elisp :noweb-ref org-roam-init
(let ((directory (file-truename "~/org/roam/")))
  (make-directory directory t)
  (setq org-roam-directory directory
        ;; Define a directory that does not change along with the Org-Roam folder
        vidbina-org-roam-root-directory directory))
#+end_src

#+begin_quote
‚ö†Ô∏è This approach requires one to structure all Org-Roam directories within a single root directory
#+end_quote

*** Use Markdown

Some of my notes, or some of my notes with others are unfortunately still in Markdown and I want to factor them into my Org-Roam setup.

#+begin_src elisp :noweb-ref org-roam-init
(setq org-roam-file-extensions '("org" "md"))
#+end_src

*** Database

Set the Org-roam database location:

#+begin_src elisp :noweb-ref org-roam-init
(setq org-roam-db-location (file-truename "~/org/roam/org-roam.db"))
#+end_src

**** WIP <<org-roam-db-sync-async>> Async Org-Roam-DB Sync or rather Non-blocking Org-Roam DB Sync

Yes, naming of this section is problematic because of the async-sync bit but we're trying to conduct the /synchronization/ in an /asynchronous/ manner such that we don't have to block the main thread all the time we conduct an =org-roam-db-sync= so forgive me. We define interactive function =vidbina/org-roam-async-forced-sync= to expose the asynchronous synchronization logic.

#+begin_src elisp :noweb yes :tangle personal-example.el
(defun vidbina/org-roam-db-async-forced-sync ()
  "Force sync org-roam asynchronously"
  (interactive)
  <<vidbina/org-roam-db-async-sync>>)
#+end_src

Before triggering the async handler, we close all database connections in order to
1. minimize issues with sqlite (which isn't a multi-connection database) and to
2. hopefully invalidate some cache such that subsequent Org-roam lookups or other events become change aware.

#+begin_src elisp :noweb-ref vidbina/org-roam-db-async-sync
(org-roam-db--close-all)
#+end_src

that wraps the src_elisp[:exports code]{(org-roam-db-sync 'force)} call in an asych handler.

The async handler is defined in the following block which allows us to quickly debug it by triggered ~org-edit-special~ on the block and executing the block by running ~eval-defun~:

#+begin_src elisp :noweb-ref vidbina/org-roam-db-async-sync
(let* ((label "üï∑Ô∏è Async Org-Roam sync")
       (my-org-roam-vars '("org-roam-db-location"
                           "org-roam-file-extensions"
                           "org-roam-v2-ack"))
       (my-setq-form (async-inject-variables (regexp-opt my-org-roam-vars))))
  (async-start `(lambda ()
                  (message "%s start" ,label)
                  (setq exec-path ',exec-path
                        load-path ',load-path)
                  ,my-setq-form
                  (setq org-roam-directory ,vidbina-org-roam-root-directory)
                  (package-initialize)
                  (require 'org-roam)
                  (message "%s dir %s for file extensions %s"
                           ,label org-roam-directory org-roam-file-extensions)
                  (org-roam-db-sync 'force)
                  (with-current-buffer "*Messages*"
                    (buffer-string)))
               `(lambda (result)
                  (message "%s *Messages* was:\n%s\n%s end of report"
                           ,label result ,label))))
#+end_src

We define a binding that calls our async synchronization function:

#+begin_src elisp :noweb-ref org-roam-bind :results none
("C-c n u" . vidbina/org-roam-db-async-forced-sync)
#+end_src

Since I want to handle synchronization of my Org-Roam database manually through my async handler, we disable autosync:

#+begin_src elisp :noweb-ref org-roam-config
(org-roam-db-autosync-disable)
#+end_src

*** Org-Roam-UI

#+begin_src elisp :tangle init.el
;; https://github.com/org-roam/org-roam-ui
(use-package org-roam-ui
  :straight (org-roam-ui :host github
                         :repo "org-roam/org-roam-ui"
                         :branch "main"
                         :files ("*.el" "out"))
  :delight
  (org-roam-ui-mode "üï∏Ô∏è")
  (org-roam-ui-follow-mode "üëÄ")
  :after org-roam
  ;; normally we'd recommend hooking orui after org-roam, but since org-roam does not have
  ;; a hookable mode anymore, you're advised to pick something yourself
  ;; if you don't care about startup time, use
  :bind (("C-c n ." . org-roam-ui-node-zoom)
         ("C-c n ," . org-roam-ui-node-local))
  :hook (after-init . org-roam-ui-mode)
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow nil
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start nil))
#+end_src

*** Incorporate Markdown into your Org-Roam use

It isn't unlikely that you will have some of your notes captured in Markdown files. In order to not have to rewrite these files into Org-files, you can use [[https://github.com/nobiot/md-roam][Md-roam]].

#+begin_src elisp :tangle init.el
;; https://github.com/nobiot/md-roam
(use-package md-roam
  :straight (md-roam :type git
                     :host github
                     :repo "nobiot/md-roam")
  :after org-roam
  :init
  (setq md-roam-use-markdown-file-links t
        md-roam-file_extension-single "md"
        org-roam-tag-sources '(prop md-frontmatter)
        org-roam-title-sources '((mdtitle title mdheadline headline) (mdalias alias))))
#+end_src

*** <<org-roam-bibtex>> Org-Roam-BibTeX (ORB)

#+begin_src elisp :noweb yes :tangle init.el
;; https://github.com/org-roam/org-roam-bibtex
(use-package org-roam-bibtex
  :straight (org-roam-bibtex :type git
                             :host github
                             :repo "org-roam/org-roam-bibtex")
  :after org-roam
  <<org-roam-bibtex-org-ref>>
  )
#+end_src

We add a reminder in the source that usage of org-roam-bibtex in combination with [[org-ref][org-ref]] requires additional configuration -- lest I forget. üòÖ

#+begin_src elisp :noweb-ref org-roam-bibtex-org-ref
;; NOTE: Using org-ref requires additional configuration
#+end_src

**** COMMENT Using ORB with Org-ref

Since Org-cite is shipped with Org now (as per Org 9.5), we may not need [[org-ref][Org-ref]] anymore. In case you still want to use the org-ref citation package in combination with Org-Roam, the following configurations may come in handy:

#+begin_src elisp :noweb-ref org-roam-bibtex-org-ref
:config
(require 'org-ref)
:custom
(orb-roam-ref-format 'org-ref-v3 "Use new org-ref cite:&links notation in ROAM_REFS property")
#+end_src

** COMMENT <<org-ref>> Org-ref

[[https://github.com/jkitchin/org-ref][Org-ref]] provides a system to define citations and cross-references. With Org-cite becoming part of standard-Org since 9.5, I am trying to use standard Org as much as possible which means dropping Org-ref out of my toolbox for a bit.

#+begin_center
Org-ref has provisions for cross-referencing that Org-cite doesn't quite provide, so you may want to enable Org-ref in your configuration if you use the Org-ref cite syntax or rely on cross-referencing capability.
#+end_center

#+begin_src elisp :tangle init.el
;; https://github.com/jkitchin/org-ref
(use-package org-ref
  :straight (org-ref :type git
                     :host github
                     :repo "jkitchin/org-ref")
  :after (org-roam))
#+end_src

** Org-QL

In order to query Org files with more flexibility, [[https://github.com/alphapapa/org-ql][org-ql]] can come to the rescue.

#+begin_src elisp :tangle init.el
;; https://github.com/alphapapa/org-ql
(use-package org-ql
  :straight (org-ql :type git
                    :host github
                    :repo "alphapapa/org-ql"))
#+end_src

In the most basic usage form you can basically run ~org-ql-search~ and just enter =todo= to get a basic listing.

** <<ob-async>> ob-async

In some cases, code blocks need to be executed in a non-blocking manner (e.g.: when firing up a test instance of emacs or triggering a large file transfer). The [[https://github.com/astahlman/ob-async][ob-async]] package allow async execution of code-blocks by simply adding the =:async= keyword to the a codeblock of interest.

#+begin_center
Since the [[https://blog.tecosaur.com/tmio/2021-05-31-async.html#async-babel-sessions
][introduction of ob-comint.el]] there is support for sessions and async code execution built into Org itself. The only gotcha is that, at the time of writing [2022-06-26 Sun], there is only a Python implementation that is ob-comint compatible while there are implementations for R and Ruby in the works. For other runtimes, ob-async is a bit more flexible because we can use this on any language since there is no requirement on providing a ob-comint-compatible implementation but we simply spawn another Emacs sessions asynchronously to just run the code. Use variable =ob-async-no-async-language-alist= to bypass ob-async for org-babel-languages that provide their own =:async= keyword and async handling workflow.
#+end_center

*** COMMENT Original

#+begin_src elisp :tangle init.el
;; https://github.com/astahlman/ob-async
(use-package ob-async
  :straight (ob-async :type git
                      :host github
                      :repo "astahlman/ob-async"))
#+end_src

*** Fork

In order to fix the ob-async for my own setup, I've [[https://github.com/vidbina/ob-async][forked]] the [[https://github.com/astahlman/ob-async][original repo]] with a few minor changes/fixes.

#+begin_src elisp :tangle init.el
;; https://github.com/vidbina/ob-async
(use-package ob-async
  :straight (ob-async :type git
                      :host github
                      :branch "main"
                      :repo "vidbina/ob-async"))
#+end_src

*** Usage

Under the hood ob-async depends on [[async]] and can be used by specifying an =:async= header on a code block as demonstrated below:

#+begin_src bash :async t :session "*blah*" :results verbatim
sleep 2; echo hi
#+end_src

#+RESULTS:
: 
: hi

*** WIP COMMENT Debug invalid read read syntax error during variable injection

When injecting variables, the default =ob-async-inject-variables= pattern seems to allow for propertized strings getting injected into the new environment which likely triggers invalid read syntax issues.

#+begin_src text
error in process sentinel: async-when-done: Invalid read syntax: "#"
error in process sentinel: Invalid read syntax: "#"
#+end_src

*** TODO Introduce =:async= header args for org-lint checks

The =:async= header argument should be accepted by Org-lint when ob-async is loaded. IIRC the =:async= header arg should be legal for Python blocks.

**** COMMENT Yak Shaving

***** Exploring Text Properties

Since Emacs 28.1, we can check an object for text properties in the following manner which we can use to collect the properties to strip from said object:

#+begin_src elisp
(object-intervals (concat
                   (propertize "foo" 'face 'bold)
                   " and "
                   (propertize "bar" 'face 'italic
                               'mouse-face 'bold-italic)))
#+end_src

The idiomatic async package way to strip an object of its properties is through =async--purecopy=:

#+begin_src elisp
(async--purecopy (concat
                  (propertize "foo" 'face 'bold)
                  " and "
                  (propertize "bar" 'face 'italic
                              'mouse-face 'bold-italic)))
#+end_src

A simple check of property-free-ness could be conducted by an equality check between the purecopy equivalent and the original object using the =equal-including-properties= function:

#+begin_src elisp :results verbatim
(let ((x (concat
          (propertize "foo" 'face 'bold)
          " and "
          (propertize "bar" 'face 'italic
                      'mouse-face 'bold-italic))))
  (list (equal-including-properties "foo and bar" (async--purecopy x))
        (equal-including-properties "foo and bar" x)))
#+end_src

#+RESULTS:
: (t nil)

***** Variable Injection

For debugging purposes, we'll start off by trying to inject variables only when the variable names and properties are property-free.

#+begin_src elisp -n -r :results none
(defun async-inject-variables
    (include-regexp &optional predicate exclude-regexp noprops)
  "Return a `setq' form that replicates part of the calling environment.

It sets the value for every variable matching INCLUDE-REGEXP and
also PREDICATE.  It will not perform injection for any variable
matching EXCLUDE-REGEXP (if present) or representing a `syntax-table'
i.e. ending by \"-syntax-table\".
When NOPROPS is non nil it tries to strip out text properties of each
variable's value with `async-variables-noprops-function'.

It is intended to be used as follows:

    (async-start
       \\=`(lambda ()
          (require \\='smtpmail)
          (with-temp-buffer
            (insert ,(buffer-substring-no-properties (point-min) (point-max)))
            ;; Pass in the variable environment for smtpmail
            ,(async-inject-variables \"\\\\=`\\(smtpmail\\|\\(user-\\)?mail\\)-\")
            (smtpmail-send-it)))
       \\='ignore)"
  `(setq
    ,@(let (bindings)
        (mapatoms
         (lambda (sym)
           (let* ((sname (and (boundp sym) (symbol-name sym)))
                  (value (and sname (symbol-value sym))))
             (when (and sname
                        (eq nil (object-intervals sname)) ; check that sname is props-free
                        (or (null include-regexp)
                            (string-match include-regexp sname))
                        (or (null exclude-regexp)
                            (not (string-match exclude-regexp sname)))
                        (not (string-match "-syntax-table\\'" sname)))
               (unless (or (stringp value)
                           (memq value '(nil t))
                           (numberp value)
                           (vectorp value))
                 (setq my-debug-last-unless-sname sname)
                 (setq value `(quote ,value)))
               (when noprops
                 (setq my-debug-last-noprops-sname sname)
                 (setq value (funcall async-variables-noprops-function
                                      value)))
               (when (or (null predicate)
                         (funcall predicate sym))
                 (setq bindings (cons value bindings)
                       bindings (cons sym bindings)))))))
        bindings)))
#+end_src

From the following error output we instrument =async-handle-result=:

#+begin_src text
Debugger entered--Lisp error: (invalid-read-syntax "#")
async-handle-result((lambda (result) (with-current-buffer #<buffer README.org<concept-clj-react>> (let ((default-directory "/home/vidbina/src/formation.tools/eng/concept-clj-...")) (save-excursion (cond ((member "none" ...) (message "result silenced")) ((member "silent" ...) (message ...)) (t (goto-char #<marker at 2280 in README.org<concept-clj-react>>) (let ... ... ... ...))) (run-hooks 'org-babel-after-execute-hook))))) (async-signal (invalid-read-syntax "#")) #<buffer *emacs*<26>>)
async-when-done(#<process emacs> "finished\n")
#+end_src

Inside =async-handle-result= we evaluated =result= which is already =async-signal (invalid-read-syntax "#")= which leads me to conclude that the caller =async-when-done= is already in an error state. The caller basically populates the value for the arg-of-interest through ~(read (current-buffer))~

#+begin_center
‚ö†Ô∏è I once instrumented =async-when-done= and ended up in a curous GC infinite loop that was difficult to meaningfully debug with GDB on account of lacking symbols.
#+end_center

Note that =(read (current-buffer))= [[(handle-old)]] can be resolved for a hard-coded value like ="hi"= which does complete without error. Furthermore, ~(vidbina/open-proc-below proc)~ [[(handle-dbg)]] is a helper to spawn the proc buffer for improved visibility during debugging. The ~(edebug)~ source breakpoint allows us to stop at this point for further investigation.

#+begin_src elisp -n -r :results none
(defun async-when-done (proc &optional _change)
  "Process sentinel used to retrieve the value from the child process."
  (when (eq 'exit (process-status proc))
    (with-current-buffer (process-buffer proc)
      (let ((async-current-process proc))
        (if (= 0 (process-exit-status proc))
            (if async-callback-for-process
                (if async-callback
                    (prog1
                        (funcall async-callback proc)
                      ;; (edebug)
                      (unless async-debug
                        (kill-buffer (current-buffer))))
                  (set (make-local-variable 'async-callback-value) proc)
                  (set (make-local-variable 'async-callback-value-set) t))
              ;;(vidbina/open-proc-below proc) ;; open a debug window below with the proc results (ref:handle-dbg)
              ;;(edebug)
              (goto-char (point-max))
              (backward-sexp)
              (async-handle-result async-callback (read (current-buffer)) ;; this read fails (ref:handle-old)
                                   (current-buffer)))
          (set (make-local-variable 'async-callback-value)
               (list 'error
                     (format "Async process '%s' failed with exit code %d"
                             (process-name proc) (process-exit-status proc))))
          (set (make-local-variable 'async-callback-value-set) t))))))
#+end_src

Before =async-when-done= is called the proc already exists and contains the following content as the =vidbina/debug-open-proc= call above on line [[(handle-dbg)]] has revealed:

#+begin_src text
Lisp expression: (async-signal (invalid-read-syntax "#"))
#+end_src

This leads us to the caller =async-start-process= which we can debug next, where =proc= calls =apply= against =#'start-process name buf program program-args= as demonstrated in [[(proc-apply)]].

The =async-start-process= function fires another process and attaches callbacks for when its state changes through the =set-process-sentinel= function.

#+begin_src elisp -n -r :results none
(defun async-start-process (name program finish-func &rest program-args)
  "Start the executable PROGRAM asynchronously named NAME.  See `async-start'.
PROGRAM is passed PROGRAM-ARGS, calling FINISH-FUNC with the
process object when done.  If FINISH-FUNC is nil, the future
object will return the process object when the program is
finished.  Set DEFAULT-DIRECTORY to change PROGRAM's current
working directory."
  (let* ((buf (generate-new-buffer (concat "*" name "*")))
         (proc (let ((process-connection-type nil))
                 (apply #'start-process name buf program program-args)))) ;; where the async work happens (ref:proc-apply)
    (with-current-buffer buf
      (set (make-local-variable 'async-callback) finish-func)
      (set-process-sentinel proc #'async-when-done)
      (unless (string= name "emacs")
        (set (make-local-variable 'async-callback-for-process) t))
      proc)))
#+end_src

In my setup, there are the following variables and values:
- program  =/nix/store/9b2cr2b5ldkclxkiascbslrczzg2y5y2-emacs-git-20220101.0/bin/emacs-29.0.50=
- program-args
  - =-Q=
  - =-l=
  - =/home/vidbina/.emacs.d/straight/build/async/async.el=
  - =-batch=
  - =-f=
  - =async-batch-invoke= which is the function that is invoked on the executioner end.
  - =<none>=

Going one level higher, one will notice that =async-start= attempts to serialize =start-func= at line [[(async-serialization)]]. This serialization attempt isn't fool-proof.

#+begin_src elisp -n -r :results none
(defun async-start (start-func &optional finish-func)
  "Execute START-FUNC (often a lambda) in a subordinate Emacs process.
When done, the return value is passed to FINISH-FUNC.  Example:

    (async-start
       ;; What to do in the child process
       (lambda ()
         (message \"This is a test\")
         (sleep-for 3)
         222)

       ;; What to do when it finishes
       (lambda (result)
         (message \"Async process done, result should be 222: %s\"
                  result)))

If FINISH-FUNC is nil or missing, a future is returned that can
be inspected using `async-get', blocking until the value is
ready.  Example:

    (let ((proc (async-start
                   ;; What to do in the child process
                   (lambda ()
                     (message \"This is a test\")
                     (sleep-for 3)
                     222))))

        (message \"I'm going to do some work here\") ;; ....

        (message \"Waiting on async process, result should be 222: %s\"
                 (async-get proc)))

If you don't want to use a callback, and you don't care about any
return value from the child process, pass the `ignore' symbol as
the second argument (if you don't, and never call `async-get', it
will leave *emacs* process buffers hanging around):

    (async-start
     (lambda ()
       (delete-file \"a remote file on a slow link\" nil))
     \\='ignore)

Note: Even when FINISH-FUNC is present, a future is still
returned except that it yields no value (since the value is
passed to FINISH-FUNC).  Call `async-get' on such a future always
returns nil.  It can still be useful, however, as an argument to
`async-ready' or `async-wait'."
  (let ((sexp start-func)
        ;; Subordinate Emacs will send text encoded in UTF-8.
        (coding-system-for-read 'utf-8-auto))
    (setq async--procvar
          (async-start-process
           "emacs" (file-truename
                    (expand-file-name invocation-name
                                      invocation-directory))
           finish-func
           async-quiet-switch "-l"
           ;; Using `locate-library' ensure we use the right file
           ;; when the .elc have been deleted.
           (locate-library "async")
           "-batch" "-f" "async-batch-invoke"
           (if async-send-over-pipe
               "<none>"
             (with-temp-buffer
               (async--insert-sexp (list 'quote sexp))
               (buffer-string)))))
    (if async-send-over-pipe
        (async--transmit-sexp async--procvar (list 'quote sexp))) ;; (ref:async-serialization)
    async--procvar))
#+end_src

#+begin_src elisp
(setq async-debug nil)
#+end_src

**** Root cause

From a deeper analysis of =async-inject-variables= on the ob-async pattern, the following snippet will fail when the variable injection form is not "readable" by the async executor.

#+begin_src elisp -n -r :results none
(read (pp-to-string (async-inject-variables ob-async-inject-variables)))
#+end_src

In some cases, variables like =org-babel-hide-result-overlays= may contain /overlay/ values:

#+begin_src elisp :results verbatim
(overlayp (car org-babel-hide-result-overlays))
#+end_src

#+RESULTS:
: t

A sexp will be sent to the executor after serialization of the sexp through =pp-to-string= and since overlays are serialized into a =#<overlays ...>= format, they are not "readable" in their pretty-printed form:

#+begin_src elisp :results none
(read (#<overlay from 39236 to 39236 in README.org<emacs>>))
#+end_src

**** COMMENT Solution

We can exclude the problem by eliminating "-overlays" from the variable injection form.

#+begin_src elisp -n -r :results none
(read (pp-to-string (async-inject-variables ob-async-inject-variables nil "-overlay")))
#+end_src

We define a rejection pattern:

#+begin_src elisp :tangle init.el
(defvar ob-async-inject-variables-exclude "-overlays"
  "Regex of variables to exclude from injection into the async process.
It's a good idea to exclude any variables that contain overlays.")
#+end_src

We define the execute handler:

#+begin_src elisp :tangle init.el
(defun ob-async-org-babel-execute-src-block (&optional orig-fun arg info params)
  "Like org-babel-execute-src-block, but run asynchronously.

Original docstring for org-babel-execute-src-block:

Execute the current source code block.  Insert the results of
execution into the buffer.  Source code execution and the
collection and formatting of results can be controlled through a
variety of header arguments.

With prefix argument ARG, force re-execution even if an existing
result cached in the buffer would otherwise have been returned.

Optionally supply a value for INFO in the form returned by
`org-babel-get-src-block-info'.

Optionally supply a value for PARAMS which will be merged with
the header arguments specified at the front of the source code
block."
  (interactive "P")
  (cond
   ;; If this function is not called as advice, do nothing
   ((not orig-fun)
    (warn "ob-async-org-babel-execute-src-block is no longer needed in org-ctrl-c-ctrl-c-hook")
    nil)
   ;; If there is no :async parameter, call the original function
   ((not (assoc :async (nth 2 (or info (org-babel-get-src-block-info)))))
    (funcall orig-fun arg info params))
   ;; If the src block language is in the list of languages async is not to be
   ;; used for, call the original function
   ((member (nth 0 (or info (org-babel-get-src-block-info)))
            ob-async-no-async-languages-alist)
    (funcall orig-fun arg info params))
   ;; Otherwise, perform asynchronous execution
   (t
    (let ((placeholder (ob-async--generate-uuid)))
      ;; Here begins the original source of org-babel-execute-src-block
      (let* ((org-babel-current-src-block-location
              (or org-babel-current-src-block-location
                  (nth 5 info)
                  (org-babel-where-is-src-block-head)))
             (src-block-marker (save-excursion
                                 (goto-char org-babel-current-src-block-location)
                                 (point-marker)))
             (info (if info (copy-tree info) (org-babel-get-src-block-info))))
        ;; Merge PARAMS with INFO before considering source block
        ;; evaluation since both could disagree.
        (cl-callf org-babel-merge-params (nth 2 info) params)
        (when (org-babel-check-evaluate info)
          (cl-callf org-babel-process-params (nth 2 info))
          (let* ((params (nth 2 info))
                 (cache (let ((c (cdr (assq :cache params))))
                          (and (not arg) c (string= "yes" c))))
                 (new-hash (and cache (org-babel-sha1-hash info)))
                 (old-hash (and cache (org-babel-current-result-hash)))
                 (current-cache (and new-hash (equal new-hash old-hash)))
                 (result-params (cdr (assq :result-params params))))
            (cond
             (current-cache
              (save-excursion		;Return cached result.
                (goto-char (org-babel-where-is-src-block-result nil info))
                (forward-line)
                (skip-chars-forward " \t")
                (let ((result (org-babel-read-result)))
                  (message (replace-regexp-in-string "%" "%%" (format "%S" result)))
                  result)))
             ((org-babel-confirm-evaluate info)
              ;; Insert a GUID as a placeholder in our RESULTS block
              (when (not (or (member "none" result-params)
                             (member "silent" result-params)))
                (org-babel-insert-result placeholder '("replace")))
              (let* ((lang (nth 0 info))
                     ;; Expand noweb references in BODY and remove any
                     ;; coderef.
                     (body
                      (let ((coderef (nth 6 info))
                            (expand
                             (if (org-babel-noweb-p params :eval)
                                 (org-babel-expand-noweb-references info)
                               (nth 1 info))))
                        (if (not coderef) expand
                          (replace-regexp-in-string
                           (org-src-coderef-regexp coderef) "" expand nil nil 1))))
                     (dir (cdr (assq :dir params)))
                     (default-directory
                      (or (and dir (file-name-as-directory (expand-file-name dir)))
                          default-directory))
                     (cmd (intern (concat "org-babel-execute:" lang)))
                     (org-babel-async-content
                      (buffer-substring-no-properties (point-min) (point-max)))
                     result)
                (unless (fboundp cmd)
                  (error "No org-babel-execute function for %s!" lang))
                (message "executing %s code block%s..."
                         (capitalize lang)
                         (let ((name (nth 4 info)))
                           (if name (format " (%s)" name) "")))
                (progn
                  (async-start
                   `(lambda ()
                      ;; TODO: Put this in a function so it can be overidden
                      ;; Initialize the new Emacs process with org-babel functions
                      (setq exec-path ',exec-path)
                      (setq load-path ',load-path)
                      ,(async-inject-variables ob-async-inject-variables nil ob-async-inject-variables-exclude)
                      (package-initialize)
                      (setq ob-async-pre-execute-src-block-hook ',ob-async-pre-execute-src-block-hook)
                      (run-hooks 'ob-async-pre-execute-src-block-hook)
                      (org-babel-do-load-languages 'org-babel-load-languages ',org-babel-load-languages)
                      (let ((default-directory ,default-directory))
                        (with-temp-buffer
                          (insert org-babel-async-content)
                          (,cmd ,body ',params))))
                   `(lambda (result)
                      (with-current-buffer ,(current-buffer)
                        (let ((default-directory ,default-directory))
                          (save-excursion
                            (cond
                             ((member "none" ',result-params)
                              (message "result silenced"))
                             ((member "silent" ',result-params)
                              (message (replace-regexp-in-string "%" "%%" (format "%S" result))))
                             (t
                              (goto-char ,src-block-marker)
                              (let ((file (cdr (assq :file ',params))))
                                (when file
                                  ;; when result type is link, don't write result content to file.
                                  (unless (member "link" ',result-params)
                                    ;; If non-empty result and :file then write to :file.
                                    (when result
                                      (with-temp-file file
                                        (insert (org-babel-format-result
                                                 result (cdr (assq :sep ',params)))))))
                                  (setq result file))
                                ;; Possibly perform post process provided its
                                ;; appropriate.  Dynamically bind "*this*" to the
                                ;; actual results of the block.
                                (let ((post (cdr (assq :post ',params))))
                                  (when post
                                    (let ((*this* (if (not file) result
                                                    (org-babel-result-to-file
                                                     file
                                                     (let ((desc (assq :file-desc ',params)))
                                                       (and desc (or (cdr desc) result)))))))
                                      (setq result (org-babel-ref-resolve post))
                                      (when file
                                        (setq result-params (remove "file" ',result-params))))))
                                (org-babel-insert-result result ',result-params ',info ',new-hash ',lang))))
                            (run-hooks 'org-babel-after-execute-hook)))))))))))))))))
#+end_src

**** DONE Compose PR upstream

See [[https://github.com/astahlman/ob-async/pull/88][PR astahlman/ob-async #88]]

** TODO COMMENT org-store-link org-mairix-store-gnus links broken

#+begin_center
‚ö†Ô∏è Unclear how to reproduce!
#+end_center

<<cursor>>

#+begin_src text
Debugger entered--Lisp error: (void-function org-mairix-store-gnus-link)
org-mairix-store-gnus-link()
org-store-link(nil 1)
funcall-interactively(org-store-link nil 1)
command-execute(org-store-link record)
execute-extended-command(nil "org-store-link" "org-store-link")
funcall-interactively(execute-extended-command nil "org-store-link" "org-store-link")
command-execute(execute-extended-command)
#+end_src

#+begin_src elisp :results verbatim :wrap src elisp
(org-store-link-functions)
#+end_src

#+RESULTS:
#+begin_src elisp
(org-eww-store-link org-rmail-store-link org-mhe-store-link org-irc-store-link org-info-store-link org-gnus-store-link org-docview-store-link org-bbdb-store-link org-w3m-store-link treemacs-store-org-link org-notmuch-tree-store-link org-notmuch-search-store-link org-notmuch-store-link mu4e-org-store-link org-bibtex-store-link org-link--store-help)
#+end_src

*** What is Mairix

#+begin_quote
mairix is a program for indexing and searching email messages stored in Maildir, MH or mbox folders
#+end_quote

https://github.com/rc0/mairix

** TODO COMMENT Fix nested code block eldoc recursion issue

When navigating through code blocks inside of Org buffers, we often seem to run into GC issues along with the following errors:

#+begin_src text
eldoc error: (error Lisp nesting exceeds ‚Äòmax-lisp-eval-depth‚Äô)
#+end_src

Advising =(org-eldoc-documentation-function &rest ARGS)= to skip doc lookup when inside of a code block may be a potential fix here.

** TODO COMMENT Debug why org-id-get-create takes so long

*** Profiler

**** Sample [2022-07-20 Wed 20:46]

I've had this for a while but a bunch of profiling attempts turned out unspectacular (as in, the issue did't appear when profiler) until now.

***** Memory

#+begin_src text
      8,159,596  91% - command-execute
      5,507,873  61%  - byte-code
      5,507,873  61%   - read-extended-command
      5,507,873  61%    - completing-read-default
      5,507,873  61%     - apply
      5,507,873  61%      - vertico--advice
      5,429,013  60%       - #<subr completing-read-default>
      3,836,933  42%        - vertico--exhibit
      1,509,874  16%         - vertico--update-candidates
        933,018  10%          - vertico--recompute-candidates
        663,738   7%           - vertico--all-completions
        663,738   7%            - completion-all-completions
        663,738   7%             - apply
        663,738   7%              - #<subr completion-all-completions>
        663,738   7%               - completion--nth-completion
        663,738   7%                - completion--some
        663,738   7%                 + #<compiled -0xa6ec707464c0be4>
          1,056   0%             vertico--metadata-get
        566,368   6%            redisplay
      1,339,889  14%         - vertico--arrange-candidates
        766,289   8%          - vertico--affixate
        765,233   8%           - #<compiled -0xae271d86ff3f9bf>
        765,233   8%            - apply
        760,017   8%             - marginalia--affixate
        720,985   8%              - marginalia--cached
        692,265   7%               - marginalia-annotate-command
        502,946   5%                + marginalia--function-doc
         35,312   0%                + marginalia--documentation
         22,176   0%              + select-window
          1,056   0%           + vertico--metadata-get
        303,472   3%          - vertico--format-candidate
        159,808   1%             vertico--display-string
         77,640   0%            seq-subseq
         55,216   0%          + #<compiled 0x1a85e55656e6ad8d>
          4,224   0%            vertico--window-width
          1,056   0%            vertico--metadata-get
        917,558  10%         - vertico--display-candidates
          9,362   0%          - vertico--resize-window
          8,306   0%           - window-resize
          6,352   0%            + window--resize-mini-window
          1,056   0%             vertico--window-width
         65,100   0%           vertico--display-count
         38,580   0%        + timer-event-handler
         30,536   0%        + redisplay_internal (C function)
          4,728   0%        + command-execute
          4,224   0%        + minibuffer-inactive-mode
          3,168   0%        + minibuffer-mode
          1,056   0%        + which-key--hide-popup
      2,650,667  29%  - funcall-interactively
      2,650,667  29%   - execute-extended-command
      2,650,547  29%    - command-execute
      2,650,515  29%     - funcall-interactively
         46,753   0%      + org-id-get-create
            994   0%      + profiler-start
            120   0%    + run-at-time
        777,555   8% - timer-event-handler
        777,555   8%  - apply
        761,987   8%   + #<compiled 0xd6718aec4408409>
         15,520   0%   + #<subr F616e6f6e796d6f75732d6c616d626461_anonymous_lambda_14>
             48   0%   + blink-cursor-start
            504   0% + redisplay_internal (C function)
             48   0% + eldoc-schedule-timer
              0   0%   ...
#+end_src

***** CPU

#+begin_src text
        2091  59% - timer-event-handler
        2091  59%  - apply
        2084  59%   - #<compiled 0xd6718aec4408409>
        2062  58%    - execute-extended-command--shorter
        2062  58%     - completion-try-completion
        2062  58%      - completion--nth-completion
        2062  58%       - completion--some
        2062  58%        + #<compiled -0xd9b28e4ac16b362>
          20   0%    + sit-for
           5   0%     #<subr F616e6f6e796d6f75732d6c616d626461_anonymous_lambda_12>
           2   0%   + #<subr F616e6f6e796d6f75732d6c616d626461_anonymous_lambda_14>
        1304  37% - command-execute
        1301  37%  - byte-code
        1301  37%   - read-extended-command
        1301  37%    - completing-read-default
        1301  37%     - apply
        1301  37%      - vertico--advice
        1292  36%       - #<subr completing-read-default>
        1204  34%        - vertico--exhibit
        1165  33%         - vertico--update-candidates
        1111  31%          - vertico--recompute-candidates
        1082  30%           - vertico--all-completions
        1082  30%            - completion-all-completions
        1082  30%             - apply
        1082  30%              - #<subr completion-all-completions>
        1082  30%               - completion--nth-completion
        1081  30%                - completion--some
        1081  30%                 - #<compiled -0xa6ec707464c0be4>
        1080  30%                  - orderless-all-completions
        1078  30%                   - orderless-filter
        1074  30%                    - #<subr F616e6f6e796d6f75732d6c616d626461_anonymous_lambda_49>
        1074  30%                     - complete-with-action
         178   5%                      - all-completions
          95   2%                       + #<compiled -0x1c173d7981ce569>
           3   0%                    + orderless-pattern-compiler
           1   0%                   + orderless-highlight-matches
          19   0%           + vertico-sort-history-length-alpha
          54   1%            redisplay
          25   0%         + vertico--arrange-candidates
          11   0%         + vertico--display-candidates
           3   0%           vertico--display-count
          20   0%        + timer-event-handler
           2   0%        + redisplay_internal (C function)
           2   0%        + minibuffer-inactive-mode
           1   0%        + minibuffer-mode
           1   0%        + window--resize-root-window-vertically
           3   0%  + funcall-interactively
         104   2% + ...
           1   0% + redisplay_internal (C function)
#+end_src

* üëÅÔ∏è Appearance

This section will deal with some of the visual trappings of Emacs. My design goal is to arrive at a rather minimal, or rather clean, design while providing the needed information scope perhaps through toggles (i.e.: showing whitespace characters at command).

** üôà Hide GUI Elements

In order to minimize visual noise, let's disable the graphical scroll bars, tool bars and menu bars.

#+begin_src elisp :tangle init.el
;; https://www.emacswiki.org/emacs/ScrollBar
(scroll-bar-mode -1)

;; https://www.emacswiki.org/emacs/ToolBar
(tool-bar-mode -1)

;; https://www.emacswiki.org/emacs/MenuBar
(menu-bar-mode -1)

;; https://www.emacswiki.org/emacs/ShowParenMode
(show-paren-mode 1)
#+end_src

** COMMENT Column Indicator

Display a border at the position to indicate where the right margin is drawn. This should provide authors a sense of where lines should be broken to keep the text relatively readable.

#+begin_src elisp :tangle init.el
;; https://www.emacswiki.org/emacs/FillColumnIndicator
(global-display-fill-column-indicator-mode 1)
#+end_src

#+begin_quote
üí° Even if we have extremely wide displays, reading is a lot easier if the text is width-constrained so do yourself a favor and use something like [[visual-fill-column]] mode.
#+end_quote

** üè∑Ô∏è Line Numbers

Let's hide line numbers and For the sake of ease of navigation and spatial orientation we display line numbers in the left margin.

#+begin_src elisp :tangle init.el
;; https://www.emacswiki.org/emacs/LineNumbers
(use-package display-line-numbers
  :straight (:type built-in)

  :config
  (display-line-numbers-mode 0)

  :hook
  (prog-mode . (lambda () (display-line-numbers-mode 1)))
  (notmuch-hello-mode . (lambda () (display-line-numbers-mode 0))))
#+end_src

** üè≥Ô∏è Whitespace

Visualize white spaces (tabs, spaces, trailing whitespace). The global whitespace mode can be toggled through =(global-whitespace-mode)= in order to reduce the visual noise or enable the whitespace indication.

#+begin_src elisp :tangle init.el
;; https://www.emacswiki.org/emacs/WhiteSpace
;; https://www.emacswiki.org/emacs?action=browse;oldid=WhitespaceMode;id=WhiteSpace
(setq whitespace-style '(empty face lines-tail tabs trailing))
#+end_src

** üéõÔ∏è Modeline

The modeline is the bar typically at the bottom of a buffer which provides useful information about the system.

*** COMMENT <<smart-mode-line>> Smart-mode-line

When switching between different screen configurations, it helps to have the mode-line adapt to the available screen real estate and optimize for readability. This is particularly annoying when I switch to a split-frame layout in which the perspective indicator is out of view.

The [[https://github.com/Malabarba/smart-mode-line][smart-mode-line]] package should improve visbility by truncating certain bits of information based on the available screens space.

#+begin_src elisp :tangle init.el
;; https://github.com/Malabarba/smart-mode-line
(use-package smart-mode-line
  :after
  (:all delight diminish)
  :straight
  (smart-mode-line :type git
                   :host github
                   :repo "Malabarba/smart-mode-line"))
#+end_src

**** TODO Solve mode-line overflow

The current position indicator in [[mode-line]] is not always in view.

This probably has something to do with the manner in which smart-mode-line calculates modeline-width in =sml/generate-minor-modes= when emojis are in play.

*** Delight and Diminish

Since the amount of textual information in the Modeline can get overwhelming at times, we provide horizontally succinct (i.e.: single char) pictographic indicators for the Modeline instead.

#+begin_src elisp :tangle init.el
;; https://git.savannah.nongnu.org/git/delight.git
(use-package delight
  :straight (delight :type git
                     :host nil
                     :repo "https://git.savannah.nongnu.org/git/delight.git")
  :delight
  (fundamental-mode "üóíÔ∏è")
  (auto-revert-mode "‚ôªÔ∏è")
  (eldoc-mode "elüìñ")
  (edebug-mode "üêû")
  (whitespace-mode "üè≥Ô∏è")
  (visual-line-mode "üåØ")
  (mu4e-main-mode "üì´")
  (mu4e-headers-mode "üì¨")
  (mu4e-view-mode "üìß")
  (vterm-mode "üë®üèø‚Äçüíª"))

;; https://github.com/myrjola/diminish.el
(use-package diminish
  :straight (diminish :type git
                      :host github
                      :repo "myrjola/diminish.el"))
#+end_src

One can debug the configuration by examining the =minor-mode-alist= variable to verify if the delight/diminish configurations are correctly applied to the configuration variable.

**** TODO Delight auto-revert mode

Set =auto-revert-mode-text= since the delight setting isn't robust enough. Perhaps we should move this out into a dedicated =use-package= form for auto-revert-mode.

#+begin_src elisp :tangle init.el
(customize-set-variable 'auto-revert-mode-text "‚ôªÔ∏è")
#+end_src

** üî§ Text

*** <<visual-fill-column>> Visual Fill Column

For the sake of readability, it helps to wrap text at a fixed column instead of filling up whatever screen real estate that is available to a buffer. The [[https://github.com/joostkremers/visual-fill-column][visual-fill-column]] package by Joost Kremers accomplishes just this and can be toggled by running ~(visual-fill-column-mode)~.

#+begin_src elisp :tangle init.el
;; https://github.com/joostkremers/visual-fill-column
(use-package visual-fill-column
  :straight (visual-fill-column :type git
                                :host github
                                :repo "joostkremers/visual-fill-column"))
#+end_src

#+CAPTION: Demonstration of toggling visual-fill-column mode
[[file:images/demonstration-visual-fill-column.gif]]

**** Global binding for convenience

For convenience, I have defined the following global binding to facilitate my laziness and avoid having to enter =visual-fill-column-mode= which isn't as much of a pain to begin with TBH if you consider that there is completion within Emacs. ü§∑üèø‚Äç‚ôÇÔ∏è

#+begin_src elisp
(global-set-key (kbd "C-c v \\") 'visual-fill-column-mode)
#+end_src

*** <<adaptive-wrap>> Adaptive Wrap

By using [[https://elpa.gnu.org/packages/adaptive-wrap.html][adaptive wrap]] mode, wrapping behaviour can be adapted to respect indentation present at the start of a line. This should simply the readability of long lines in e-mail quotes or in nested code.

#+begin_src elisp :tangle init.el
;; https://elpa.gnu.org/packages/adaptive-wrap.html
(use-package adaptive-wrap
  :straight (adaptive-wrap :type git
                           :host github
                           :repo "emacs-straight/adaptive-wrap")
  :config
  (adaptive-wrap-prefix-mode))
#+end_src

Using adaptive wrapping along with visual-fill-column mode may introduce some performance issues especially when longer texts are being soft-wrapped. When dealing with code blocks or tables, adaptie wrapping can be a bit more confusing than helpful which is why it helps to define key bindings to simplify toggling this behaviour. In my case, I have defined the =vidbina/wrap= function to play to control =visual-line-mode= and =adaptive-wrap-mode= in a single operation.

*** Default Text Scale

For global text scaling, the [[https://github.com/purcell/default-text-scale][default-text-scale]] package can be used. Without this package, scaling may require one to resize the text in every buffer independently which is an arduous task.

#+begin_src elisp :tangle init.el
;; https://github.com/purcell/default-text-scale
;; Doesn't work well in emacsclient
(use-package default-text-scale
  :straight (default-text-scale :type git
                                :host github
                                :repo "purcell/default-text-scale")
  :hook ((after-init . default-text-scale-mode)))
#+end_src

The package sets the height attribute of the default face, which can be retrieved by the following code:

#+begin_src elisp
(face-attribute 'default :height)
#+end_src

In my configuration, I have updated the height of the default face through the =customize-face= interface (see [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Specific-Customization.html][Customizing Specific Items]] for more instruction on how to customize faces in Emacs) and applied and saved these changes to allow different machines/environments to load their customization that don't make much sense tracking in git (see the section on our [[*Customizations][custom.el file]] which allows for this).

‚ö†Ô∏è When updating the font face through the =customize-face= interface see to it that you uncheck all non-height attributes to ensure that the customization written into custom.el only sets height information as in the snippet example below:

#+begin_src elisp
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(default ((t (:height 241)))))
#+end_src

**** TODO Investigate if the =server-after-make-frame-hook= is a sane configuration option

The call to =default-text-scale-reset= has been configured in the =server-after-make-frame-hook= since I was having some trouble using this package when using Emacs in client/server mode as opposed to standalone mode.

I don't quite use Emacs in standalone mode anymore, unless I'm debugging my config (by invoking =emacs --debug-init=), but AFAIK, the =server-after-make-frame-hook= was necessary to ensure that =default-text-scale-reset= is only called once the a GUI frame is ready, thus allowing default-text-scale to calculculate text scale.

Note that =default-text-scale--update-for-new-frame= is called in =after-make-frame-functions=, so perhaps this is already sufficient to ensure that all frames have the same scaling for text.

*** Olivetti

For focus, [[https://github.com/rnkn/olivetti.git][Olivetti mode]] can be a great help, so let's just install it for the odd cases where we need it.

#+begin_src elisp :tangle init.el
;; https://github.com/rnkn/olivetti.git
(use-package olivetti
  :straight (olivetti :type git
                      :host github
                      :repo "rnkn/olivetti"))
#+end_src

** üé® Rainbow Mode

[[https://github.com/emacsmirror/rainbow-mode][Rainbow mode]] allows the coloring or color codes within buffers such as #ff0000 and #0f0.

#+begin_src elisp :tangle lang.example.el
;; https://github.com/emacsmirror/rainbow-mode
(use-package rainbow-mode
  :straight (rainbow-mode :type git
                          :host github
                          :repo "emacsmirror/rainbow-mode"))
#+end_src

** üíÑ Themes

*** COMMENT Leuven Theme

#+begin_src elisp :tangle init.el
;; https://github.com/fniessen/emacs-leuven-theme
(use-package leuven-theme
  :straight (leuven-theme :type git
                          :host github
                          :repo "fniessen/emacs-leuven-theme"))
#+end_src

*** Modus Themes

In order to avoid overthinking themes, I've opted for Prot's [[https://gitlab.com/protesilaos/modus-themes][Modus themes]] which offers a highly readable color scheme from an accessibility perspective.

#+CAPTION: Screenshot of this Emacs configuration in dark-mode
[[file:images/screenshot-README-dark.png]]

#+CAPTION: Screenshot of this Emacs configuration in light-mode
[[file:images/screenshot-README-light.png]]

#+begin_src elisp :tangle init.el
;; https://gitlab.com/protesilaos/modus-themes
(use-package modus-themes
  :straight (modus-themes :type git
                          :host gitlab
                          :repo "protesilaos/modus-themes")
  :config
  (modus-themes-load-themes)
  :init
  (setq modus-themes-bold-constructs t
        modus-themes-org-blocks 'gray-background
        modus-themes-region '(bg-only no-extend accented)
        modus-themes-prompts '(intense)
        modus-themes-fringes '(intense)
        modus-themes-hl-line '(accented)
        modus-themes-paren-match '(bold intense)
        modus-themes-syntax '(yellow-comments green-strings alt-syntax)
        modus-themes-headings '((1 . (background overline))
                                (2 . (background overline rainbow))
                                (t . (background overline rainbow)))
        modus-themes-scale-headings t))
#+end_src

** COMMENT NŒõNO: NANO Theme by Rougier

The [[https://github.com/rougier/nano-emacs][NŒõNO theme by Rougier]] provides a very "clean" Emacs experience. Let's use parts of it for a better DX.

#+begin_src elisp :tangle init.el
(use-package nano-emacs
  :straight (nano-emacs :type git
                        :host github
                        :repo "rougier/nano-emacs")
  :after (:all modus-themes svg-tag-mode mu4e-dashboard mu4e-thread-folding)
  :config
  (require 'nano-base-colors)
  (require 'nano-faces)
  (require 'nano-mu4e))
#+end_src

*** TODO Debug why this doesn't work nicely yet :xmas:

Probably a good holiday hacking effort.

*** mu4e-dashboard

#+begin_src elisp :tangle init.el
(use-package mu4e-dashboard
  :straight (mu4e-dashboard :type git
                            :host github
                            :repo "rougier/mu4e-dashboard"))
#+end_src

#+begin_src elisp :tangle init.el
(use-package mu4e-thread-folding
  :straight (mu4e-thread-folding :type git
                                 :host github
                                 :repo "rougier/mu4e-thread-folding"))
#+end_src

*** svg-tag-mode

#+begin_src elisp :tangle init.el
(use-package svg-tag-mode
  :straight (svg-tag-mode :type git
                          :host github
                          :repo "rougier/svg-tag-mode"))
#+end_src

** Dired-k

The standard Emacs directory editor named dired doesn't ship with convenient highlighting or coloring of the listed files. The dired-k package adds some flair to the dired ouput.

#+begin_src elisp :tangle init.el
;; https://github.com/emacsorphanage/dired-k
(use-package dired-k
  :straight (dired-k :type git
                     :host github
                     :repo "emacsorphanage/dired-k")
  :init
  (setq dired-k-style 'git)
  :hook (dired-initial-position-hook . dired-k))
#+end_src

* üå∑ Misc

** ü™ü Windows

*** üèóÔ∏è Buffer Placement

#+begin_src elisp :tangle init.el
(setq display-buffer-alist
      (let* ((sidebar-width '(window-width . 85))
             (sidebar-parameters '(window-parameters . ((no-other-window . t))))
             (sidebar (list '(side . left) sidebar-width sidebar-parameters)))
        (list (cons (regexp-opt-group '("*org-roam*"))
                    (cons #'display-buffer-in-side-window
                          `((slot . 0) ,@sidebar)))
              (cons (regexp-opt-group '("*Dictionary*"))
                    (cons #'display-buffer-in-side-window
                          `((slot . -1) ,@sidebar)))
              (cons (regexp-opt-group '("*Help*" "*Info*" "*info*"))
                    (cons #'display-buffer-in-side-window
                          `((slot . 5) ,@sidebar)))
              (cons (regexp-opt-group '("*Shortdoc"))
                    (cons #'display-buffer-in-side-window
                          `((slot . 6) ,@sidebar)))
              (cons (regexp-opt-group '("*Warnings*"))
                    (cons #'display-buffer-in-side-window
                          `((slot . 10) ,@sidebar))))))
#+end_src

**** Error reporting

Just did some updates and am getting a lot of warnings for docstrings being wider than 80 chars and more of that jazz. This is a massive distraction (for me) and does not warrant a buffer popping up to make me aware of the issues so we're opting to just allow the buffer to emerge for actual errors instead and thus reducing the noisiness.

#+begin_src elisp :tangle init.el
(customize-set-variable 'display-warning-minimum-level :error
                        "Pop up buffer for error-level or more severe warnings")
#+end_src

*** üîç <<zoom-window>> Zoom-window: Zoom to a single window

In order to single out a particular window in order to return to the preceding layout shortly thereafter again, one may use the [[https://github.com/emacsorphanage/zoom-window][zoom-window]] package. It's a great way to clear some screen real estate and obtain some focus.

#+begin_src elisp :noweb yes :tangle init.el
;; https://github.com/emacsorphanage/zoom-window
(use-package zoom-window
  :straight (zoom-window :type git
                         :host github
                         :repo "emacsorphanage/zoom-window")
  :init
  (message "Configuring ‚Äòzoom-window‚Äô")
  <<zoom-window-init>>)
#+end_src

*** ü™Ñ <<ace-window>> ace-window

In order to quickly jump between windows by numbers, we can use the [[https://github.com/abo-abo/ace-window][ace-window]] package. This eliminates the need for the tedious next/previous window bindings (either native Emacs or evil).

#+begin_src elisp :tangle init.el
;; https://github.com/abo-abo/ace-window
;; https://jao.io/blog/2020-05-12-ace-window.html
(use-package ace-window
  :straight (ace-window :type git
                        :host github
                        :repo "abo-abo/ace-window")
  :bind (("M-o" . ace-window)))
#+end_src

**** TODO Debug hanging when attempting to switchin windows through =M-o= from help page

When the help page for function =null= is open, the =M-o= binding just ends up hanging up Emacs *sometimes*. Can't reproduce it yet. üò≠

#+begin_src elisp
(describe-function #'null)
#+end_src

#+RESULTS:
#+begin_example
null is a built-in function in ‚ÄòC source code‚Äô.

(null OBJECT)

Return t if OBJECT is nil, and return nil otherwise.

  Other relevant functions are documented in the list group.
  Probably introduced at or before Emacs version 1.9.
  This function does not change global state, including the match data.

#+end_example

***** Profiler results
****** Profiler output from the =null= help page

******* Memory

#+begin_src text
  1,362,566,599  99% - command-execute
  1,359,050,303  99%  - funcall-interactively
  1,355,593,128  99%   - ace-window
  1,355,593,128  99%    - ace-select-window
  1,355,593,128  99%     - aw-select
  1,355,592,072  99%      - avy-read
         22,136   0%       - aw--lead-overlay
          6,336   0%        + #<compiled 0x21abf780a0956>
          6,136   0%          aw--point-visible-p
          5,280   0%        - aw--overlay-str
          2,112   0%         - select-window
          2,112   0%          - apply
          2,112   0%             ad-Advice-select-window
          2,112   0%         + #<compiled 0x21a7852646156>
          4,224   0%        - select-window
          4,224   0%         - apply
          4,224   0%            ad-Advice-select-window
      3,457,175   0%   + execute-extended-command
      3,515,240   0%  + byte-code
        249,481   0% + timer-event-handler
         47,172   0% + redisplay_internal (C function)
             24   0% + eldoc-schedule-timer
             21   0% + #<compiled 0xdb7dccf4d947c67>
              0   0%   ...
#+end_src

******* CPU

#+begin_src text
        6135  59% - ...
        6135  59%    Automatic GC
        3875  37% + command-execute
         285   2% + timer-event-handler
           1   0%   redisplay_internal (C function)
#+end_src

****** COMMENT Profiler output from when trying to window switch with =persp-string-match-p= help page open

#+begin_comment
I must have copied over the profile reports incorrectly since the CPU and Memory reports seem to deviate a bit from the other two reports that I've gathered. Just commenting this section out to avoid getting confused over this.
#+end_comment

******* Memory

#+begin_src text
     11,653,264  97% - command-execute
      7,258,981  60%  - byte-code
      7,258,938  60%   - read-extended-command
      7,258,938  60%    - completing-read-default
      7,258,938  60%     - apply
      7,257,882  60%      - vertico--advice
      7,177,718  60%       + #<subr completing-read-default>
      4,394,283  36%  - funcall-interactively
      3,697,527  31%   - execute-extended-command
      3,697,431  31%    - command-execute
      3,697,415  31%     - funcall-interactively
            631   0%      - profiler-start
            631   0%         apply
             96   0%    + run-at-time
        694,580   5%   + ace-window
          2,112   0%   + digit-argument
        131,812   1% + redisplay_internal (C function)
         86,886   0% + timer-event-handler
         36,345   0% + internal-echo-keystrokes-prefix
          8,184   0%   evil-repeat-pre-hook
          1,098   0% + #<compiled 0xdb7dccf4d947c67>
          1,056   0% + which-key--hide-popup
          1,056   0% + undo-auto--add-boundary
              0   0%   ...
#+end_src

******* CPU

#+begin_src text
        7930  99% - command-execute
        6878  86%  - funcall-interactively
        6873  86%   - ace-window
        6873  86%    - ace-select-window
        6873  86%     - aw-select
        6844  86%      + #<subr F616e6f6e796d6f75732d6c616d626461_anonymous_lambda_26>
          28   0%      + avy-read
           1   0%      + mapcar
           5   0%   + execute-extended-command
        1052  13%  + byte-code
           2   0% + redisplay_internal (C function)
           2   0% + timer-event-handler
           1   0%   evil-esc
           0   0% + ...
#+end_src

****** Profiler output

This run was particularly problematic, as you can tell it has basically consumed a crapload of memory and GC seems to be going wild.

******* Memory

#+begin_src text
  7,441,616,899  99% - command-execute
  7,435,010,443  99%  - funcall-interactively
  7,424,303,916  99%   - ace-window
  7,424,303,916  99%    - ace-select-window
  7,424,303,916  99%     - aw-select
  7,424,302,860  99%      - avy-read
    133,056,380   1%       - aw--lead-overlay
        129,404   0%          aw--point-visible-p
          5,280   0%        + aw--overlay-str
          5,280   0%        + #<compiled 0x47199a3e5d956>
          4,224   0%        + select-window
          1,056   0%        aw--make-backgrounds
      8,762,616   0%   + describe-function
      1,936,327   0%   + execute-extended-command
      5,284,212   0%  + byte-code
      1,321,188   0%  + help-fns--describe-function-or-command-prompt
        130,504   0% + redisplay_internal (C function)
         92,686   0% + timer-event-handler
          5,224   0% + eldoc-schedule-timer
          2,112   0% + jit-lock--antiblink-post-command
          1,098   0% + #<compiled 0xdb7dccf4d947c67>
              0   0%   ...
#+end_src

******* CPU

#+begin_src text
       36661  66% - ...
       36661  66%    Automatic GC
       18178  33% + command-execute
           8   0% + timer-event-handler
           3   0% + redisplay_internal (C function)
#+end_src

****** Profiler [2022-07-06 Wed 13:52]

Point on README.org and trying to =M-o= to Help bufer with =org-html-head-include-default-style=.

******* Memory

#+begin_src text
  3,719,970,307  99% - command-execute
  3,715,823,503  99%  - funcall-interactively
  3,712,721,656  99%   - ace-window
  3,712,721,656  99%    - ace-select-window
  3,712,721,656  99%     - aw-select
  3,712,717,432  99%      - avy-read
        390,744   0%       + aw--lead-overlay
          2,112   0%      + aw-window-list
          1,056   0%        aw--make-backgrounds
          1,056   0%      + #<subr F616e6f6e796d6f75732d6c616d626461_anonymous_lambda_26>
      3,101,847   0%   + execute-extended-command
      4,146,804   0%  + byte-code
         91,678   0% + timer-event-handler
         33,240   0% + redisplay_internal (C function)
          1,056   0% + mode-local-post-major-mode-change
             42   0% + #<compiled 0xd98e199f0b07c67>
             24   0% + eldoc-schedule-timer
              0   0%   ...
#+end_src

******* CPU

#+begin_src text
       18122  53% - ...
       18122  53%    Automatic GC
       15631  46% + command-execute
          10   0% + timer-event-handler
           1   0% + #<compiled 0xd98e199f0b07c67>
#+end_src

****** Profiler [2022-07-06 Wed 13:55]

Point on README.org (avy 2) and ran =M-o= and the avy window labels appeared but pressing any number key yields no result. Tried entering 1 which should have moved point to the Help buffer and also tried 2 which should have kept point on README.org.

******* Memory

#+begin_src text
     10,551,251  98% - command-execute
      5,733,544  53%  - byte-code
      5,729,400  53%   - read-extended-command
      5,729,400  53%    - completing-read-default
      5,729,400  53%     - apply
      5,729,400  53%      - vertico--advice
      4,813,351  45%       + #<subr completing-read-default>
      4,817,707  45%  - funcall-interactively
      3,694,391  34%   - execute-extended-command
      3,693,287  34%    - command-execute
      3,693,271  34%     - funcall-interactively
            631   0%      - profiler-start
            631   0%         apply
          1,104   0%    + run-at-time
      1,118,124  10%   - ace-window
      1,118,124  10%    - ace-select-window
      1,118,124  10%     - aw-select
      1,113,908  10%      - avy-read
        173,364   1%       - read-key
        147,140   1%        - read-key-sequence-vector
         10,812   0%         - redisplay_internal (C function)
         10,812   0%          - eval
         10,560   0%           - format
          5,280   0%            - propertize
          5,280   0%             - let
          5,280   0%                get-current-persp
          5,280   0%            - safe-persp-name
          5,280   0%               get-current-persp
          1,056   0%         + timer-event-handler
         17,424   0%        + use-global-map
          7,192   0%        + #<compiled 0x1449b5b163f5817e>
         75,200   0%       + aw--lead-overlay
          3,160   0%      + aw-window-list
          1,056   0%      + avy-tree
         74,096   0% + timer-event-handler
         37,416   0% + redisplay_internal (C function)
          1,080   0% + eldoc-schedule-timer
          1,056   0% + mode-local-post-major-mode-change
             63   0% + #<compiled 0xd98e199f0b07c67>
              0   0%   ...
#+end_src

******* CPU

#+begin_src text
        8272  99% - command-execute
        7685  92%  - funcall-interactively
        7677  92%   - ace-window
        7677  92%    - ace-select-window
        7677  92%     - aw-select
        7648  92%      - #<subr F616e6f6e796d6f75732d6c616d626461_anonymous_lambda_26>
        7648  92%       - aw--done
        5433  65%        - aw--restore-windows-hscroll
         775   9%           #<compiled 0xf5c1743c948468>
          28   0%      + avy-read
           1   0%      + aw-window-list
           8   0%   + execute-extended-command
         587   7%  + byte-code
           4   0% + timer-event-handler
           3   0% + redisplay_internal (C function)
           1   0% + #<compiled 0xd98e199f0b07c67>
           0   0% + ...
#+end_src

***** Yak Shaving

Let's study what =avy-tree= really does. The signature is ~(avy-read TREE DISPLAY-FN CLEANUP-FN)~ and is defined in [[file:straight/repos/avy/avy.el::defun avy-read (tree display-fn cleanup-fn][avy.el]].

*** <<avy>> avy

In order to speed up text navigation, one can use [[https://github.com/abo-abo/avy][avy]] to produce jump points that one can navigate through single keystrokes.

In order to jump to bind in the snippet below, one can grep for bind which is often fast enough or... one can trigger ~(avy-goto-char)~, type =b= and then observe how the different occurrences of b provide an indication of the character (or sequence of characters) that we need to press to "teleport" to that location.

#+begin_src elisp :tangle init.el
;; https://github.com/abo-abo/avy
(use-package avy
  :straight (avy :type git
                 :host github
                 :repo "abo-abo/avy")
  :bind (("C-:" . avy-goto-char)))
#+end_src

*** Rotate

Akin to rotating layouts in tmux, [[https://github.com/daichirata/emacs-rotate][emacs-rotate]] helps users rotate through layouts in Emacs. This can be handy when you quickly want to change a vertically tiles layout into a horizontally tiled layout.

#+begin_src elisp :tangle init.el
;; https://github.com/daichirata/emacs-rotate
(use-package rotate
  :straight (rotate :type git
                    :host github
                    :repo "daichirata/emacs-rotate"))
#+end_src

** Find File at Point (FFAP)

In order to provide point-specific behavior, we use the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/FFAP.html#index-ffap][FFAP]] package. As an example, the ~(find-file-at-point)~ command will provide custom behavior depending on the type of link it is called over.

#+begin_src elisp :tangle init.el
;; https://www.gnu.org/software/emacs/manual/html_node/emacs/FFAP.html#index-ffap
(ffap-bindings)
#+end_src

** Indentation

Turn of tab-indentation and opt for space-based indentation such that whitespace is a bit more controllable.

#+begin_src elisp :tangle init.el
;; https://www.gnu.org/software/emacs/manual/html_node/eintr/Indent-Tabs-Mode.html
(setq-default indent-tabs-mode nil)
#+end_src

#+begin_quote
‚ö†Ô∏è Not to append to ongoing flame wars: across different editors and viewers (pagers, terminals, etc) the use of spaces is a bit more predictable as a text alignment tool. ü§∑üèø‚Äç‚ôÇÔ∏è
#+end_quote

** Scrolling

In order to [[https://www.emacswiki.org/emacs/SmoothScrolling][facilitate smoother scrolling]] than the default i.e.: "when scrolling out of view, scroll such that point is in the middle of the buffer", we set =scroll-conservatively= to allow for more line-by-line scrolling.

#+begin_src elisp :tangle init.el
;; https://www.emacswiki.org/emacs/SmoothScrolling
(setq-default scroll-conservatively 100)
#+end_src

üí° If you want to center the cursor (or point in Emacs vernacular), the ~evil-scroll-line-to-center~ command bound to =z z= is your friend.

** TODO Undo

#+begin_src elisp :tangle init.el
;; https://github.com/emacsmirror/undo-fu
(use-package undo-fu
  :straight (undo-fu :type git
                     :host github
                     :repo "emacsmirror/undo-fu"))
#+end_src

** <<async>> Async

Emacs is single-threaded and this makes sense considering that many packages navigate the live buffers or affect change to these buffers. Just imagine the mess if these packages attempted to conduct these operations on Emacs buffers concurrently. üòß

[[https://github.com/jwiegley/emacs-async][Emacs async]] allows for some async code execution which can come in handy for logic that may otherwise have blocked the Emacs main thread for too long.

#+begin_src elisp :noweb yes :tangle init.el
;; https://github.com/jwiegley/emacs-async
(use-package async
  :straight (async :type git
                   :host github
                   :repo "jwiegley/emacs-async")
  :config
  <<async-config>>
  :custom
  <<async-custom>>)
#+end_src

#+begin_src elisp :noweb-ref async-config
(async-bytecomp-package-mode 1)
#+end_src

#+begin_src elisp :noweb-ref async-custom
(async-variables-noprops-function #'async--purecopy)
#+end_src

** PROTOTYPE iedit

The =evil-search-forward= (bound to =/=) which triggers =isearch-forward= under the hood allows for the temporary highlighting of entered patterns which can provide awareness of a patterns presence in a buffer but sometimes one just wants to highlight a symbol under point without having to type it in first.

#+begin_src elisp :tangle init.el
;; https://github.com/victorhge/iedit
(use-package iedit
  :straight (iedit :type git
                   :host github
                   :repo "victorhge/iedit"))
#+end_src

Enable the iedit-mode through the =C-;= binding to highlight symbol under point throughout the buffer.

** <<evil>> Evil

In order to save my hands some pain, it is helpful to use vi-like bindings that keep your hands around the home row more often and minimizes the need for your hands to pull acrobatic maneuvers üé™ that could incur some strain -- those Emacs /key-chords/. I use the [[https://github.com/emacs-evil/evil][extensible vi layer, inconveniently but mischievously abbreviated to Evil]], to help me to vi-bindings while in Emacs.

#+begin_quote
I used classical Emacs with the typical bindings extensively in college[fn:college:around the end of the early 2000s as I started college in 2007] and developed a pretty rough case of the /Emacs pinky/ issue at the time. That's about the time I switched back to *vi? (vi, gvim, vim) and around the end of 2021, I decided to give Emacs another try in combination with Evil-mode which provides me the best of both worlds. ü§Ø
#+end_quote

Consult the [[https://github.com/noctuid/evil-guide][guide]] for more information on evil. Note that the vi commands started with colon such a =:e=, =:s= and =:g= are mapped through evil-ex (see [[https://gist.github.com/agzam/acd3b5e311f8f7e87e21b550856f65e1][agzam's write up]] on these evil-ex commands for reference).

#+begin_src elisp :tangle init.el
;; https://github.com/emacs-evil/evil
;; https://github.com/noctuid/evil-guide
(use-package evil
  :straight (evil :type git
                  :host github
                  :repo "emacs-evil/evil")
  :after
  undo-fu
  :init
  ;; https://github.com/emacs-evil/evil-collection#installation
  ;; pre-set some evil vars prior to package load
  (setq evil-respect-visual-line-mode t)
  (setq evil-undo-system 'undo-fu)
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
  :config
  (evil-mode t)
  (evil-set-initial-state 'info-mode 'emacs)
  (evil-set-initial-state 'help-mode 'emacs)
  (evil-set-initial-state 'special-mode 'emacs))

;; https://github.com/emacs-evil/evil-collection
(use-package evil-collection
  :straight (evil-collection :type git
                             :host github
                             :repo "emacs-evil/evil-collection")
  :after evil
  :config
  (evil-collection-init)
  (advice-add 'evil-collection-mu4e-setup
              :before (lambda ()
                        (message "üòà Setup up evil-collection for mu4e üìß")))
  (advice-add 'evil-collection-vterm-setup
              :before (lambda ()
                        (message "üòà Setup up evil-collection for vterm üì†")))
  :delight
  (evil-collection-unimpaired-mode "üöÄ"))
#+end_src

#+begin_center
üö® *Remember the =C-z= binding to exit the 'emacs state and return to 'normal state.* You may accidentally change =evil-state= ([[info:evil.info#Modes and states][evil states]] are the equivalent to modes in vim vernacular) to =emacs= which will leave you with really annoying results when attempting to quickly navigate/edit your buffers. I've been cursing often enough thinking that my config was broken ü§¨ when I had just accidentally pressed =C-z= and ended up in Emacs state. ü§¶üèø‚Äç‚ôÇÔ∏è
#+end_center

People have somewhat strong opinions about keybindings. Grab yourself some popcorn üçø and enjoy some choice words on [[https://www.reddit.com/r/emacs/comments/tyg9v5/why_not_use_evil_in_2022/][Reddit]] or on a number of YouTube videos that are pretty easy to find.

Read [[https://blog.aaronbieber.com/2016/01/23/living-in-evil.html#forcing-emacs-state-][Living in Evil (Aaron Bieber)]] for some insight into some evil struggles that you may run into.

*** <<evil-vimish-fold>> Folding in a "vimish" fashion

The [[https://github.com/alexmurray/evil-vimish-fold][evil-vimish-fold]] package does exactly what the name implies and integrates evil and [[vimish-fold]] such that we can fold regions through the [[https://vim.fandom.com/wiki/Folding][vim-like bindings]] with classics such as =z f= to fold, =z o= to open and =z d= to delete.

#+begin_src elisp :tangle init.el
;; https://github.com/alexmurray/evil-vimish-fold
(use-package evil-vimish-fold
  :straight (evil-vimish-fold :type git
                              :host github
                              :repo "alexmurray/evil-vimish-fold")
  :diminish evil-vimish-fold-mode
  :after
  (:all vimish-fold)
  :hook ((prog-mode conf-mode text-mode) . evil-vimish-fold-mode))
#+end_src

** <<vimish-fold>> Folding with vimish-fold

The [[https://github.com/matsievskiysv/vimish-fold][vimish-fold]] package allows us to fold regions in buffers while persisting our folding preferences when we save files.

#+begin_src elisp :tangle init.el
;; https://github.com/matsievskiysv/vimish-fold
(use-package vimish-fold
  :straight (vimish-fold :type git
                         :host github
                         :repo "matsievskiysv/vimish-fold")
  :after evil)
#+end_src

** WIP Annotation

The [[https://github.com/bastibe/annotate.el][annotate.el]] package allows us to annotate code in different projects without affecting those project directories themselves. Think of it as your personal marker/highligher toolbox for source code.

#+begin_src elisp :tangle init.el
;; https://github.com/bastibe/annotate.el
(use-package annotate
  :straight (annotate :type git
                      :host github
                      :repo "bastibe/annotate.el")
  :custom
  (annotate-file-buffer-local nil "Use central annotations file"))
#+end_src

Use =C-c C-a= to *add annotations* and =C-c C-d= to *delete* annotations.

** Version Control

*** Magit: Git Porcelain

#+begin_src elisp :tangle init.el
;; https://github.com/magit/magit.git
(use-package magit
  :straight (magit :type git
                   :host github
                   :repo "magit/magit")
  :custom
  (magit-display-buffer-function
   (lambda (buffer)
     ;; based on magit-display-buffer-same-window-except-diff-v1
     (display-buffer
      buffer (if (with-current-buffer buffer
                   (derived-mode-p 'magit-diff-mode 'magit-process-mode))
                 '(display-buffer-below-selected)
               '(display-buffer-same-window))))
   "Open in same window or (when secondary) split at bottom")
  (magit-diff-refine-hunk t "Show fine differences (word-granularity) for current hunk only"))
#+end_src

*** Diff-hl: Diff highlighting in the left gutter of a buffer

#+begin_src elisp :tangle init.el
;; https://github.com/dgutov/diff-hl
(use-package diff-hl
  :straight (diff-hl :type git
                     :host github
                     :repo "dgutov/diff-hl")
  :hook (after-init . global-diff-hl-mode)
  :custom
  (diff-hl-margin-mode t "Use margin mode to clear up the fringe"))
#+end_src

** üìÅ Navigation

*** TODO Deft

#+begin_src elisp :tangle init.el
;; https://github.com/jrblevin/deft
(use-package deft
  :straight (deft :type git
                  :host github
                  :repo "jrblevin/deft")
  :after org
  :bind
  ("C-c n d" . deft)
  :custom
  (deft-directory "~/org")
  (deft-extensions '("md" "org"))
  (deft-recursive t)
  (deft-strip-summary-regexp
   (concat "\\("
           "[\n\t]" ;; blank
           "\\|^#\\+[[:alpha:]_]+:.*$" ;; org-mode metadata
           "\\)"))
  (deft-use-filename-as-title t)
  (deft-use-filter-string-for-filename t))
#+end_src

** Completion

Function ~completing-read-default~ is triggered to resolve completions. Observe the following example that fires up whichever completion framework is actively configured:

#+begin_src elisp
(completing-read-default "Pick one ü§∑üèø‚Äç‚ôÇÔ∏è: "
                         (list "Blue üîµ pill üíä"
                               "Red üî¥ pill üíä"))
#+end_src

The help page for the abovementioned function will indicate which completion framework is active.

#+begin_center
üí° TIP: You will be able to tell in the help pages which /advice/ is associated to the function thus allowing you to determine which functions are actually triggered.
#+end_center

*** <<orderless>> Orderless

The [[https://github.com/oantolin/orderless][orderless]] package provides more generous completion resolution by permitting us to:
1. provide partial phrases e.g.: "o i d" to filter for "org-indent-drawer" and
2. enter these parts in any order (hence /orderless/) e.g.: "drawer org" to filter for "org-indent-drawer".

#+begin_src elisp :noweb strip-export :tangle init.el
(use-package orderless
  :straight (orderless :type git
                       :host github
                       :repo "oantolin/orderless")
  <<orderless-ivy>>
  :custom
  (completion-styles '(orderless)))
#+end_src

The following note should help us remember to uncomment the [[orderless-ivy][Ivy integration]] when we are using [[swiper][Swiper]].

#+begin_src elisp :noweb-ref orderless-ivy
;; NOTE: Load Orderless after Swiper when using the Ivy integration
#+end_src

**** COMMENT <<orderless-ivy>> Ivy integration

In case Ivy is being used for completion, we will want to configure orderless to load after Ivy.

#+begin_src elisp :noweb-ref orderless-ivy
:after
(:all swiper)
#+end_src

Furthermore, we want to configure the ivy regex builder to play ball with orderless.

#+begin_src elisp :noweb-ref orderless-ivy
:custom
(ivy-re-builders-alist '((t . orderless-ivy-re-builder)))
#+end_src

*** TODO Marginalia

[[https://github.com/minad/marginalia
][Marginalia]] annotates entries in a completion buffer with additional context.

#+begin_src elisp :tangle init.el
;; Enable richer annotations using the Marginalia package
(use-package marginalia
  :straight (marginalia :type git
                        :host github
                        :repo "minad/marginalia")
  ;; Either bind `marginalia-cycle` globally or only in the minibuffer
  :bind (("M-A" . marginalia-cycle)
         :map minibuffer-local-map
         ("M-A" . marginalia-cycle))

  ;; The :init configuration is always executed (Not lazy!)
  :init

  ;; Must be in the :init section of use-package such that the mode gets
  ;; enabled right away. Note that this forces loading the package.
  (marginalia-mode))
#+end_src

*** Consult

[[https://github.com/minad/consult][Consult]] provides enchancements to completion systems based around the standard Emacs =completing-read= API.

#+begin_src elisp :noweb yes :tangle init.el
;; https://github.com/minad/consult
(use-package consult
  :straight (consult :type git
                     :host github
                     :repo "minad/consult")
  :bind
  (;; bindings from https://github.com/minad/consult#use-package-example
   <<consult-bindings>>
   )

  :config
  ;; Use `consult-completion-in-region' if Vertico is enabled.
  ;; Otherwise use the default `completion--in-region' function.
  (setq completion-in-region-function
        (lambda (&rest args)
          (apply (if vertico-mode
                     #'consult-completion-in-region
                   #'completion--in-region)
                 args))))
#+end_src

See the following example for Consult's multiple selection:

#+begin_src elisp
(consult-completing-read-multiple "Pick one ü§∑üèø‚Äç‚ôÇÔ∏è: "
                                  (list "Blue üîµ pill üíä"
                                        "Red üî¥ pill üíä"))
#+end_src

**** TODO Bindings

From the [[https://github.com/minad/consult#use-package-example][example configuration]].

#+begin_src elisp :noweb-ref consult-bindings
;; C-c bindings (mode-specific-map)
("C-c h" . consult-history)
("C-c m" . consult-mode-command)
("C-c k" . consult-kmacro)
#+end_src

#+begin_src elisp :noweb-ref consult-bindings
;; C-x bindings (ctl-x-map)
("C-x M-:" . consult-complex-command)     ; orig. repeat-complex-command
("C-x b"   . consult-buffer)              ; orig. switch-to-buffer
("C-x 4 b" . consult-buffer-other-window) ; orig. switch-to-buffer-other-window
("C-x 5 b" . consult-buffer-other-frame)  ; orig. switch-to-buffer-other-frame
("C-x r b" . consult-bookmark)            ; orig. bookmark-jump
("C-x p b" . consult-project-buffer)      ; orig. project-switch-to-buffer
#+end_src

#+begin_src elisp :noweb-ref consult-bindings
;; Custom M-# bindings for fast register access
("M-#"   . consult-register-load)
("M-'"   . consult-register-store)        ; orig. abbrev-prefix-mark (unrelated)
("C-M-#" . consult-register)
#+end_src

#+begin_src elisp :noweb-ref consult-bindings
;; Other custom bindings
("M-y"      . consult-yank-pop)           ; orig. yank-pop
("<help> a" . consult-apropos)            ; orig. apropos-command
#+end_src

#+begin_src elisp :noweb-ref consult-bindings
;; M-g bindings (goto-map)
("M-g e"   . consult-compile-error)
("M-g f"   . consult-flymake)             ; Alternative: consult-flycheck
("M-g g"   . consult-goto-line)           ; orig. goto-line
("M-g M-g" . consult-goto-line)           ; orig. goto-line
("M-g o"   . consult-outline)             ; Alternative: consult-org-heading
("M-g m"   . consult-mark)
("M-g k"   . consult-global-mark)
("M-g i"   . consult-imenu)
("M-g I"   . consult-imenu-multi)
#+end_src

#+begin_src elisp :noweb-ref consult-bindings
;; M-s bindings (search-map)
("M-s d" . consult-find)
("M-s D" . consult-locate)
("M-s g" . consult-grep)
("M-s G" . consult-git-grep)
("M-s r" . consult-ripgrep)
("M-s l" . consult-line)
("M-s L" . consult-line-multi)
("M-s m" . consult-multi-occur)
("M-s k" . consult-keep-lines)
("M-s u" . consult-focus-lines)
#+end_src

#+begin_src elisp :noweb-ref consult-bindings
;; Isearch integration
("M-s e" . consult-isearch-history)
:map isearch-mode-map
("M-e"   . consult-isearch-history)       ; orig. isearch-edit-string
("M-s e" . consult-isearch-history)       ; orig. isearch-edit-string
("M-s l" . consult-line)                  ; needed by consult-line to detect isearch
("M-s L" . consult-line-multi)            ; needed by consult-line to detect isearch
#+end_src

#+begin_src elisp :noweb-ref consult-bindings
;; Minibuffer history
:map minibuffer-local-map
("M-s" . consult-history)                 ; orig. next-matching-history-element
("M-r" . consult-history)                 ; orig. previous-matching-history-element
#+end_src

*** WIP <<vertico>> Vertico

The [[https://github.com/minad/vertico][vertico]] package provides a lighter completion solution when compared to Helm or Ivy.

#+begin_src elisp :tangle init.el
;; https://github.com/minad/vertico
(use-package vertico
  :straight (vertico :type git
                     :host github
                     :repo "minad/vertico")
  :init
  (vertico-mode)

  :config
  )

;; Persist history over Emacs restarts. Vertico sorts by history position.
(use-package savehist
  :straight (:type built-in)
  :init
  (savehist-mode))

;; A few more useful configurations...
(use-package emacs
  :straight (:type built-in)
  :init
  ;; Add prompt indicator to `completing-read-multiple'.
  ;; Alternatively try `consult-completing-read-multiple'.
  (defun crm-indicator (args)
    (cons (concat "[CRM] " (car args)) (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))

  ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
  ;; Vertico commands are hidden in normal buffers.
  (setq read-extended-command-predicate
        #'command-completion-default-include-p)

  ;; Enable recursive minibuffers
  (setq enable-recursive-minibuffers t)

  :hook (minibuffer-setup . cursor-intangible-mode))
#+end_src

üí° Remember that non-existing options can be entered using =M RET= instead of =RET= (which is convenient when trying to enter options in finders).

*** COMMENT <<swiper>> Ivy, Swiper and Counsel

The [[https://github.com/abo-abo/swiper][swiper]] package, or rather repository, contains three packages actually being:
- Ivy :: a completion mechanism
- Swiper :: Ivy-enhanced Isearch
- Counsel :: Ivy-enhanced versions of common Emacs commands
  - =counsel-list-processes= :: Ivy-enchanced =list-processes=
  - =counsel-switch-buffer= :: Ivy-enchanced =switch-to-buffer=

#+begin_src elisp :noweb yes :tangle init.el
;; https://github.com/abo-abo/swiper
(use-package swiper
  :straight (swiper :type git
                    :host github
                    :repo "abo-abo/swiper")
  :delight
  (counsel-mode)
  (ivy-mode)
  :config
  (straight-use-package 'counsel)
  <<ivy-config>>
  (setq ivy-use-virtual-buffers t
        enable-recursive-minibuffers t))
#+end_src

Read [[https://oremacs.com/2019/06/27/ivy-directory-improvements/][Ivy usability improvements when dealing with directories]] to get a sense of how the different completion bindings =C-m=, =C-j= and =C-M-j= may work. At the very least just remember that these are the options when you find yourself stuck in an Ivy completion prompt.

**** COMMENT Activate Ivy and Swiper upon load

#+begin_src elisp :noweb-ref ivy-config
;; activate ivy and counsel upon config
(ivy-mode +1)
(counsel-mode +1)
#+end_src

*** Which-key: Show key bindings next to command listing in pop-up

The [[https://github.com/justbur/emacs-which-key][which-key]] package annotes the command listing with the key bindings for the shown commands.

#+CAPTION: Screenshot of which-key diplaying some keybindings to commands listed in an expanded minibuffer in dark-mode
[[file:images/screenshot-which-key-dark.png]]

#+CAPTION: Screenshot of which-key diplaying keybindings to commands listed in an expanded minibuffer in light-mode
[[file:images/screenshot-which-key-light.png]]

#+begin_src elisp :tangle init.el
;; https://github.com/justbur/emacs-which-key
(use-package which-key
  :straight (which-key :type git
                       :host github
                       :repo "justbur/emacs-which-key")
  :delight
  :config
  (which-key-mode))
#+end_src

*** COMMENT Company: Completion framework with pluggable back-ends

The [[https://company-mode.github.io/][company]] completion framework allows for the use of backends such as [[https://github.com/tigersoldier/company-lsp][company-lsp]] (for LSP integration), BBRB, clang, Ispell, Etags, and Gtags. Completions are triggered through the ~(completion-at-point)~ function while the listing is presented in a pop-up or menu near the pointer itself.

#+begin_src elisp :tangle init.el
;; https://company-mode.github.io/
(use-package company
  :straight (company :type git
                     :host github
                     :repo "company-mode/company-mode")
  :config
  (define-key company-mode-map (kbd "TAB") #'company-indent-or-complete-common)
  :hook (after-init . global-company-mode))
#+end_src

In case you are using company, the [[http://company-mode.github.io/manual/Getting-Started.html#Usage-Basics][Usage Basics]] page will provide a good walkthrough of the bindings, notable options being:
- =C-n= and =C-p= to navigate up and down the completions listing

** TODO üï≥Ô∏è Terminals and Shells üêö

*** vterm

#+begin_src elisp :tangle init.el
(use-package vterm
  :straight (:type built-in)
  :after evil
  :init (evil-collection-vterm-setup))
#+end_src

**** TODO delete word in vterm prompt changes case

Just type ab, navigate to beginning of word and enter =dw= to see what happens.

**** TODO =M-S-e= triggers eval prompt

Produces an =execute: _= prompt where I suppose we get to enter vterm-related shell commands for execution. What is the deal here.

**** How to enable ffap =find-file-at-point= within vterm

Using =find-file-at-point= inside of vterm does not work atm even though ffap does seem dired-aware.

In dired it does seem to work in a manner that suggests that ffap is either dired-aware or dired overrides ffap.

Somehow the ffap function didn't seem to be overriden in dired, so it seems that the functionality is ffap-native. Looked at =dired-find-file= to get an idea of a possible way to approach this.

Reading [[info:find#Top][find#Top]] for more info.

#+begin_src elisp
(defun vterm-find-file ()
  (interactive)
  ())
#+end_src

*** TODO Debug =evil-collection-vterm-delete=

In vterm:
1. Enter a word after the prompt
2. selecting that word
3. Enter =dw= evil binding (to delete word)

Result: triggers a case change.

*** COMMENT multi-vterm

#+begin_src elisp :tangle init.el
(use-package multi-vterm
  :straight (multi-vterm :type git
                         :host github
                         :repo "suonlight/multi-vterm")
  :config
  ;;(add-hook 'vterm-mode-hook
  ;;          (lambda ()
  ;;            (setq-local evil-insert-state-cursor 'box)
  ;;            (evil-insert-state)))
  (define-key vterm-mode-map [return]                      #'vterm-send-return)

  (setq vterm-keymap-exceptions nil)
  (evil-define-key 'insert vterm-mode-map (kbd "C-e")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-f")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-a")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-v")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-b")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-w")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-u")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-d")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-n")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-m")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-p")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-j")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-k")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-r")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-t")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-g")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-c")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-SPC")    #'vterm--self-insert)
  (evil-define-key 'normal vterm-mode-map (kbd "C-d")      #'vterm--self-insert)
  (evil-define-key 'normal vterm-mode-map (kbd ",c")       #'multi-vterm)
  (evil-define-key 'normal vterm-mode-map (kbd ",n")       #'multi-vterm-next)
  (evil-define-key 'normal vterm-mode-map (kbd ",p")       #'multi-vterm-prev)
  (evil-define-key 'normal vterm-mode-map (kbd "i")        #'evil-insert-resume)
  (evil-define-key 'normal vterm-mode-map (kbd "o")        #'evil-insert-resume)
  (evil-define-key 'normal vterm-mode-map (kbd "<return>") #'evil-insert-resume))
#+end_src

** üìï PDF

*** TODO PDF-Tools

#+begin_src elisp :tangle init.el
(use-package pdf-tools
  :straight (:type built-in)
  :config
  (require 'pdf-occur)
  (pdf-tools-install nil t nil nil)
  (setq-default pdf-view-display-size 'fit-width))
#+end_src

** üìë Project Management

In order to manage projects more conveniently, one can opt for a variety of project management packages. In this section we configure and explain some of the options that I've relied on over time.

*** project.el

First and foremost, project.el (bundled with Emacs) provides some facilities to switch between projects, explore project trees and execute commands (among other features). The project.el bindings are mapped to =C-x p=.

The following links provide some context that can be helpful in helping inform your decision to learn project.el or projectile (or its derivatives):
- [[https://www.reddit.com/r/emacs/comments/nf2k5y/how_does_projectile_compare_to_the_builtin/][How does projectile compare to the built-in project.el? (reddit)]]
- [[https://www.manueluberti.eu/emacs/2020/09/18/project/][It‚Äôs never too late (Manuel Uberti)]]

*** Projectile

[[https://github.com/bbatsov/projectile/][Projectile]] simplifies working by projects by providing some bindings that infer their behavior from a project-type. This means that we can remember single bindings expore our project trees as well as triggering [[https://docs.projectile.mx/projectile/projects.html#configure-a-projects-lifecycle-commands][project lifecycle commands]] such as configure, compile and run test, and use these generalizations across projects -- allowing ourselves to forget some project-specific details. üòå

#+begin_src elisp :tangle init.el
;; https://github.com/bbatsov/projectile/
(use-package projectile
  :straight (projectile :type git
                        :host github
                        :repo "bbatsov/projectile")
  :custom
  (projectile-mode-line-prefix "üóÑÔ∏è")
  :hook (after-init . projectile-mode)
  :bind (:map projectile-mode-map
              ("C-x p" . projectile-command-map)))
#+end_src

We configure Projectile by
1. most generally, [[https://docs.projectile.mx/projectile/projects.html#adding-custom-project-types][defining new project types]] or
2. more specifically, populating the .dir-locals.el file with our needed [[https://docs.projectile.mx/projectile/configuration.html][Projectile configuration]] or [[https://docs.projectile.mx/projectile/projects.html#storing-project-settings][project settings]].

We use =C-x p= as the binding prefix projectile deciding to overide the project.el bindings üôä:
- =C-x p P= to trigger a test command using ~(projectile-test-project ARG)~
- =C-x p L= to trigger a test command using ~(projectile-install-project ARG)~
- =C-x p != to run a one-off shell command using ~(projectile-run-shell-command-in-root)~
- =C-x p x s= run a shell ~(projectile-run-shell)~ (will jump to already running shell unless prefixed)

**** Defining Projectile lifecycle commands dir-locals.el

Look at =projectile-cache-current-file= on tips to implementing file-specific Projectile commands.

The following snippet is a rough example of a Projectile lifecycle command that performs an operation on the currently open file.

#+begin_src elisp
((nil . ((projectile-project-test-cmd . (lambda ()
                                          (shell-command (format "exercism submit %S" (file-truename (buffer-file-name))))
                                          (message "Ran test"))))))
#+end_src

For some reason, changing the .dir-locals.el file requires a reset of the corresponding map which, in the case above, happens to be the =projectile-test-cmd-map=. This hashmap can be reset by navigating to the source where is is defined and reevaluating the defining sexpr.

*** <<perspective>> Perspective

The [[https://github.com/nex3/perspective-el][Perspective]] package provides some conveniences to manage different workspaces. I use perspectives to keep buffers and layouts isolated between different contexts e.g.: sometimes projects, sometimes features, sometimes tasks (e.g.: wedding planning notes and emails, 1-on-1 work-related notes and details, notes and buffers on a particular research topic, etc.).

#+begin_src elisp :noweb yes :tangle init.el
;; https://github.com/nex3/perspective-el
(use-package perspective
  :straight (perspective :type git
                         :host github
                         :repo "nex3/perspective-el")
  :bind (("C-x k" . persp-kill-buffer*)
         ("C-x b" . persp-switch-to-buffer))
  :custom
  (persp-mode-prefix-key (kbd "C-c p") "same as persp-mode")
  (persp-modestring-short t)
  (persp-state-default-file "~/.emacs.d/perspective")
  :config
  (message "Configuring ‚Äòperspective‚Äô")
  <<perspective-config>>
  :init
  (persp-mode))
#+end_src

*** COMMENT persp-mode

Unlike Perspective, [[https://github.com/Bad-ptr/persp-mode.el][persp-mode]] allows us to manage /perspectives/ across frames (i.e.: different desktop windows for Emacs). In my usage of Emacs, this was becoming more of a requirement since I often end up opening Emacs frames where I want the convenience of selecting either of the /perspectives/ that have been curated before. The [[https://github.com/nex3/perspective-el#similar-packages][Perspective documentation]] provides a helpful writeup of the alternative solutions available for perspective-management in Emacs which includes persp-mode.

#+begin_src elisp :noweb yes :tangle init.el
;; https://github.com/Bad-ptr/persp-mode.el
(use-package persp-mode
  :straight (persp-mode :type git
                        :host github
                        :repo "Bad-ptr/persp-mode.el")
  :diminish persp-mode
  :config
  (persp-mode t)
  :custom
  <<persp-mode-custom>>)
#+end_src

The use of persp-mode should not be too challenging since it is forked from the trusted and familiar Perspective.

Here are some of the relevant bindings to remember, provided that =persp-keymap-prefix= is set to the default =C-c p=:
- =C-c p s= *switch* to perspective (existing or new)
- =C-c p S= *switch* to perspective in a window
- =C-c p n= *next* perspective
- =C-c p p= *previous* perspective
- =C-c p r= *rename* perspective
- =C-c p w= *write* perspectives to file
- =C-c p l= *load* perspectives from file
- =C-c p o= turn *off* perspective mode
- =C-c p k= kill buffer from perspective
- =C-c p K= *kill* buffer

Killing a buffer through =C-x k= will only kill the buffer if it is only member of the current perspective i.e.: a buffer that is a member of multiple perspectives will only be removed from the current perspective when the ~kill-buffer~ command is invoked.

**** Customizations

Autoloading of perspectives is sometimes quite disruptive, since the binding is as far away as =C-c p l=, we will opt for manually triggering recovery of perspectives from an autosave file.

#+begin_src elisp :noweb-ref persp-mode-custom
(persp-auto-resume-time 0 "Avoid autoloading perspective")
#+end_src

***** PROTOTYPE Expand persp-auto-save filters to filter out magit buffers
:LOGBOOK:
- State "PROTOTYPE"  from "WIP"        [2022-07-04 Mon 21:01] \\
  We managed to conduct a restart of Emacs and noticed that Magit buffers were no longer persisted, so our filters seem to work.
:END:

Note that variable =persp-save-buffer-functions= (see [[file:straight/repos/persp-mode.el/persp-mode.el::(defcustom persp-save-buffer-functions][source]]) lists some functions that are used as filters to determine which buffers are persisted to the [[file:persp-confs/persp-auto-save][persp-auto-save]] files.

#+begin_src elisp
(list #'(lambda (b)
          (when (persp-buffer-filtered-out-p
                 b persp-filter-save-buffers-functions)
            'skip))
      #'persp-tramp-save-buffer
      #'(lambda (b)
          (when (eq 'dired-mode (buffer-local-value 'major-mode b))
            `(def-buffer ,(buffer-name b)
                         ,(buffer-local-value 'default-directory b)
                         ,(buffer-local-value 'major-mode b))))
      #'(lambda (b)
          `(def-buffer ,(buffer-name b)
                       ,(buffer-file-name b)
                       ,(buffer-local-value 'major-mode b))))
#+end_src

During recovery of perspectives, magit buffers typically show up empty. I should be figuring out how to produce magit buffers in the correct locations but since the usability case for respawning magit views is negligibly small, we will just drop magit buffers from the recovery strategy.

#+begin_src elisp :noweb-ref persp-mode-custom
(persp-filter-save-buffers-functions
 (list (lambda (b) (string-prefix-p "*" (buffer-name b)))
       (lambda (b) (not (null (string-match-p (rx (seq word-boundary "magit"
                                                       (zero-or-more (seq "-" (one-or-more any))) ":")) (buffer-name b)))))
       (lambda (b) (string-match-p
                    (regexp-opt '("mu4e-compose-mode"))
                    (symbol-name (buffer-local-value 'major-mode b)))))
 "Filter out special and magit buffers from saving")
#+end_src

Eventually we should look at [[https://github.com/Bad-ptr/persp-mode.el#custom-saveload-buffer-function-example][Custom save/load buffer function example]] to define persp save/load handlers for magit.

****** Yak Shaving

The [[file:straight/repos/persp-mode.el/persp-mode.el::(defcustom persp-filter-save-buffers-functions][persp-filter-save-buffers-functions]] by default only covers special buffers, being those that start with a =*=.

The following call effectively returns the first filter from the list of filter functions that matches against a buffer and =nil= when nothing matches. We demonstrate it against the buffer named =*scratch*=:

#+begin_src elisp :results verbatim
(persp-buffer-filtered-out-p "*scratch*" persp-filter-save-buffers-functions)
#+end_src

#+RESULTS:
: (#[257 "\300\301\302!\"\207" [string-prefix-p "*" buffer-name] 5 "
: 
: (fn B)"])

The output above looks a bit warbled up because the original value was compiled but after setting is anew, the lambdas are more clearly distinguishable.

**** persp-mode Lighter

#+begin_src :noweb-ref persp-lighter
persp-lighter
#+end_src

**** Integrate with zoom-window

The [[zoom-window][zoom-window]] package can be configured to work with persp-mode

#+begin_src elisp :noweb-ref zoom-window-init
(with-eval-after-load 'persp-mode
  (message "Configuring ‚Äòzoom-window‚Äô to work with ‚Äòpersp-mode‚Äô")
  (customize-set-variable 'zoom-window-use-persp t
                          "Use zoom-window with persp-mode"))
#+end_src

***** TODO Determine if =:defer= can be used to avoid having to define an =eval-after-load= form

I‚Äôm not sure if we can define our =eval-after-load= forms through =:defer= in [[file:straight/repos/use-package/use-package-core.el::`((eval-after-load ',name ',(macroexp-progn body)))))))][use-package-core.el]]) and I don‚Äôt have time to think about it at the moment.

**** Integrate with Perspective

The [[perspective][Perspective]] package can be configured to work with persp-mode by loading it within Perspective's config block.

#+begin_src elisp :noweb-ref perspective-config
(persp-mode t)
#+end_src

**** TODO Fix perspective switching bug

Ocassionally, I end up in a situation where my perspectives are all wonky and perspective switching breaks.

The problematic call is the following:

#+begin_src elisp
(persp-frame-switch)
#+end_src

#+begin_quote
Debugger entered--Lisp error: (wrong-number-of-arguments #<subr persp-activate> 2)
persp-activate(#s(perspective :name "conf" :buffers (#<buffer x.nix<dotfiles>> #<buffer x.nix<nixos-configuration>> #<buffer home-linux.nix> #<buffer utils.nix> #<buffer TAGS> #<buffer README.org<emacs>> #<buffer org.el.gz>) :killed (((min-height . 4) (min-width . 20) (min-height-ignore . 3) (min-width-ignore . 6) (min-height-safe . 1) (min-width-safe . 4) (min-pixel-height . 152) (min-pixel-width . 380) (min-pixel-height-ignore . 114) (min-pixel-width-ignore . 114) (min-pixel-height-safe . 38) (min-pixel-width-safe . 76)) hc (pixel-width . 3192) (pixel-height . 1718) (total-width . 168) (total-height . 45) (normal-height . 1.0) (normal-width . 1.0) (combination-limit) (leaf (pixel-width . 1592) (pixel-height . 1718) (total-width . 84) (total-height . 45) (normal-height . 1.0) (normal-width . 0.4987468671679198) (buffer "README.org<emacs>" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 98310) (start . 96955)) (prev-buffers ("x.nix<dotfiles>" 1 205) ("README.org<emacs>" 13189 13895) ("README.org<product>" 1 68) ("README.org<concept-clj-react>" 1 1) ("20210719134552-elisp.org" 42736 44426) ("home-linux.nix" 1 99) ("x.nix<nixos-configuration>" 1 101) ("utils.nix" 1488 2099) ("keyformat.txt" 1 1) ("nix-develop" 1 92) ("magit-diff: dotfiles" 1 1) ("README.backup.md" 1 1) ("20211215130037-typescript.org" 854 1110) ("dotfiles" 1 188) ("20210607090600-gpg.org" 764 1805) ("references.bib" 2079 3109) ("20210319152815-org_mode.org" 1243 1879) ("gnupg-backup" 1 608) ("README.md" 1 1) ("*scratch*" 1 140))) (leaf (last . t) (pixel-width . 1600) (pixel-height . 1718) (total-width . 84) (total-height . 45) (normal-height . 1.0) (normal-width . 0.5012531328320802) (buffer "org.el.gz" (selected) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 197764) (start . 196780)) (prev-buffers ("20210421011345-philipps_byrne_gmbh.org" 183939 220125) ("org.el.gz" 196780 197828) ("magit: dotfiles" 1 1) ("README.org<emacs>" 99856 115471)))) :local-variables nil :last-switch-time nil :created-time nil :window-configuration nil :point-marker 
persp-frame-switch(nil)
funcall-interactively(persp-frame-switch nil)
command-execute(persp-frame-switch)
#+end_quote

The =persp-frame-switch= function should never be called without valid arguments.

The invalid call also happens when calling the ~persp-frame-switch~ interactive command and selecting an option from the completion list that is no longer in memory as evident from the following trace:

#+begin_quote
Debugger entered--Lisp error: (wrong-number-of-arguments #<subr persp-activate> 2)
persp-activate(#s(perspective :name "conf" :buffers (#<buffer x.nix<dotfiles>> #<buffer x.nix<nixos-configuration>> #<buffer home-linux.nix> #<buffer utils.nix> #<buffer TAGS> #<buffer README.org<emacs>> #<buffer org.el.gz>) :killed (((min-height . 4) (min-width . 20) (min-height-ignore . 3) (min-width-ignore . 6) (min-height-safe . 1) (min-width-safe . 4) (min-pixel-height . 152) (min-pixel-width . 380) (min-pixel-height-ignore . 114) (min-pixel-width-ignore . 114) (min-pixel-height-safe . 38) (min-pixel-width-safe . 76)) hc (pixel-width . 3192) (pixel-height . 1718) (total-width . 168) (total-height . 45) (normal-height . 1.0) (normal-width . 1.0) (combination-limit) (leaf (pixel-width . 1592) (pixel-height . 1718) (total-width . 84) (total-height . 45) (normal-height . 1.0) (normal-width . 0.4987468671679198) (buffer "README.org<emacs>" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 98310) (start . 96955)) (prev-buffers ("x.nix<dotfiles>" 1 205) ("README.org<emacs>" 13189 13895) ("README.org<product>" 1 68) ("README.org<concept-clj-react>" 1 1) ("20210719134552-elisp.org" 42736 44426) ("home-linux.nix" 1 99) ("x.nix<nixos-configuration>" 1 101) ("utils.nix" 1488 2099) ("keyformat.txt" 1 1) ("nix-develop" 1 92) ("magit-diff: dotfiles" 1 1) ("README.backup.md" 1 1) ("20211215130037-typescript.org" 854 1110) ("dotfiles" 1 188) ("20210607090600-gpg.org" 764 1805) ("references.bib" 2079 3109) ("20210319152815-org_mode.org" 1243 1879) ("gnupg-backup" 1 608) ("README.md" 1 1) ("*scratch*" 1 140))) (leaf (last . t) (pixel-width . 1600) (pixel-height . 1718) (total-width . 84) (total-height . 45) (normal-height . 1.0) (normal-width . 0.5012531328320802) (buffer "org.el.gz" (selected) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 197764) (start . 196780)) (prev-buffers ("20210421011345-philipps_byrne_gmbh.org" 183939 220125) ("org.el.gz" 196780 197828) ("magit: dotfiles" 1 1) ("README.org<emacs>" 99856 115471)))) :local-variables nil :last-switch-time nil :created-time nil :window-configuration nil :point-marker 
persp-frame-switch(nil)
funcall-interactively(persp-frame-switch nil)
command-execute(persp-frame-switch record)
execute-extended-command(nil "persp-frame-switch" "pers")
funcall-interactively(execute-extended-command nil "persp-frame-switch" "pers")
command-execute(execute-extended-command)
#+end_quote

To debug

- current perspective is
  #+begin_src elisp
(persp-curr)
  #+end_src
  - which seems to now associate all buffers to the "main" perspective üí•
- all names
  #+begin_src elisp
(persp-all-names)
  #+end_src
  - which only shows "main"
  - somehow the completion list presents remembered perspectives ü§∑üèø‚Äç‚ôÇÔ∏è
- reload
  #+begin_src elisp
(persp-load-state-from-file)
  #+end_src
  - empty call ~(persp-load-state-from-file)~ fails
    #+begin_quote
    Debugger entered--Lisp error: (wrong-number-of-arguments #<subr persp-add-buffer> 4)
    persp-add-buffer(#<buffer magit: dotfiles> nil nil nil)
    #f(compiled-function (b) #<bytecode -0x142e8783c2428156>)(#<buffer magit: dotfiles>)
    mapc(#f(compiled-function (b) #<bytecode -0x142e8783c2428156>) (#<buffer magit: dotfiles> #<buffer dotfiles> #<buffer gnupg-backup> #<buffer magit-process: gnupg-backup> #<buffer magit-diff: gnupg-backup> #<buffer magit: gnupg-backup> #<buffer magit-process: dotfiles> #<buffer magit-diff: dotfiles>))
    #f(compiled-function (name dbufs dwc &optional dparams weak auto hidden) #<bytecode 0x6af63e4156f816a>)(nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (((min-height . 4) (min-width . 10) (min-height-ignore . 3) (min-width-ignore . 3) (min-height-safe . 1) (min-width-safe . 2) (min-pixel-height . 164) (min-pixel-width . 200) (min-pixel-height-ignore . 123) (min-pixel-width-ignore . 60) (min-pixel-height-safe . 41) (min-pixel-width-safe . 40)) leaf (pixel-width . 3192) (pixel-height . 1715) (total-width . 160) (total-height . 42) (normal-height . 1.0) (normal-width . 1.0) (buffer "*scratch*" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 141) (start . 1)))) (def-params nil) t nil nil)
    apply(#f(compiled-function (name dbufs dwc &optional dparams weak auto hidden) #<bytecode 0x6af63e4156f816a>) (nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (((min-height . 4) (min-width . 10) (min-height-ignore . 3) (min-width-ignore . 3) (min-height-safe . 1) (min-width-safe . 2) (min-pixel-height . 164) (min-pixel-width . 200) (min-pixel-height-ignore . 123) (min-pixel-width-ignore . 60) (min-pixel-height-safe . 41) (min-pixel-width-safe . 40)) leaf (pixel-width . 3192) (pixel-height . 1715) (total-width . 160) (total-height . 42) (normal-height . 1.0) (normal-width . 1.0) (buffer "*scratch*" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 141) (start . 1)))) (def-params nil) t nil nil))
    persp-from-savelist-0((def-persp nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (((min-height . 4) (min-width . 10) (min-height-ignore . 3) (min-width-ignore . 3) (min-height-safe . 1) (min-width-safe . 2) (min-pixel-height . 164) (min-pixel-width . 200) (min-pixel-height-ignore . 123) (min-pixel-width-ignore . 60) (min-pixel-height-safe . 41) (min-pixel-width-safe . 40)) leaf (pixel-width . 3192) (pixel-height . 1715) (total-width . 160) (total-height . 42) (normal-height . 1.0) (normal-width . 1.0) (buffer "*scratch*" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 141) (start . 1)))) (def-params nil) t nil nil) #<hash-table equal 8/10 0x134d42d> nil)
    #f(compiled-function (pd) #<bytecode 0x16dab201fd7eeb63>)((def-persp nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (((min-height . 4) (min-width . 10) (min-height-ignore . 3) (min-width-ignore . 3) (min-height-safe . 1) (min-width-safe . 2) (min-pixel-height . 164) (min-pixel-width . 200) (min-pixel-height-ignore . 123) (min-pixel-width-ignore . 60) (min-pixel-height-safe . 41) (min-pixel-width-safe . 40)) leaf (pixel-width . 3192) (pixel-height . 1715) (total-width . 160) (total-height . 42) (normal-height . 1.0) (normal-width . 1.0) (buffer "*scratch*" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 141) (start . 1)))) (def-params nil) t nil nil))
    persps-from-savelist-0(((def-persp nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (... leaf ... ... ... ... ... ... ...)) (def-params nil) t nil nil) (def-persp "notes" ((def-buffer "20210519191436-management.org" "/home/vidbina/org/roam/business/..." org-mode) (def-buffer "20210719134552-elisp.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "20210319000406-emacs.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "20210607090600-gpg.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "Makefile" "/home/vidbina/src/vidbina/gnupg-..." makefile-gmake-mode) (def-buffer "README.md" nil markdown-mode) (def-buffer "20210319152815-org_mode.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "README.org<gnupg-backup>" "/home/vidbina/src/vidbina/gnupg-..." org-mode) (def-buffer "README.backup.md" "/home/vidbina/src/vidbina/gnupg-..." markdown-mode) (def-buffer "references.bib" "/home/vidbina/org/roam/software/..." bibtex-mode) (def-buffer "keyformat.txt" "/home/vidbina/src/gpg/gnupg/agen..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "conf" ((def-buffer "org.el.gz" "/nix/store/9b2cr2b5ldkclxkiascbs..." emacs-lisp-mode) (def-buffer "README.org<emacs>" "/home/vidbina/src/vidbina/dotfil..." org-mode) (def-buffer "TAGS" "/nix/store/9b2cr2b5ldkclxkiascbs..." tags-table-mode) (def-buffer "utils.nix" "/home/vidbina/src/vidbina/nixos-..." nix-mode) (def-buffer "home-linux.nix" "/home/vidbina/src/vidbina/dotfil..." nix-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "product" ((def-buffer "README.org<product>" "/home/vidbina/src/formation.tool..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "clj-react" ((def-buffer "README.org<concept-clj-react>" "/home/vidbina/src/formation.tool..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "pb" ((def-buffer "20210421011345-philipps_byrne_gm..." "/home/vidbina/org/roam/philipps-..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "js" ((def-buffer "20211215130037-typescript.org" "/home/vidbina/org/roam/software/..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "personal" ((def-buffer "personal.org" "/home/vidbina/org/personal.org" org-mode) (def-buffer "20210918225737-hamburg.org" "/home/vidbina/org/roam/asabina/p..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil)) #<hash-table equal 8/10 0x134d42d> "/home/vidbina/.emacs.d/persp-con..." nil nil)
    persps-from-savelist(((def-persp nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (... leaf ... ... ... ... ... ... ...)) (def-params nil) t nil nil) (def-persp "notes" ((def-buffer "20210519191436-management.org" "/home/vidbina/org/roam/business/..." org-mode) (def-buffer "20210719134552-elisp.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "20210319000406-emacs.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "20210607090600-gpg.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "Makefile" "/home/vidbina/src/vidbina/gnupg-..." makefile-gmake-mode) (def-buffer "README.md" nil markdown-mode) (def-buffer "20210319152815-org_mode.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "README.org<gnupg-backup>" "/home/vidbina/src/vidbina/gnupg-..." org-mode) (def-buffer "README.backup.md" "/home/vidbina/src/vidbina/gnupg-..." markdown-mode) (def-buffer "references.bib" "/home/vidbina/org/roam/software/..." bibtex-mode) (def-buffer "keyformat.txt" "/home/vidbina/src/gpg/gnupg/agen..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "conf" ((def-buffer "org.el.gz" "/nix/store/9b2cr2b5ldkclxkiascbs..." emacs-lisp-mode) (def-buffer "README.org<emacs>" "/home/vidbina/src/vidbina/dotfil..." org-mode) (def-buffer "TAGS" "/nix/store/9b2cr2b5ldkclxkiascbs..." tags-table-mode) (def-buffer "utils.nix" "/home/vidbina/src/vidbina/nixos-..." nix-mode) (def-buffer "home-linux.nix" "/home/vidbina/src/vidbina/dotfil..." nix-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "product" ((def-buffer "README.org<product>" "/home/vidbina/src/formation.tool..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "clj-react" ((def-buffer "README.org<concept-clj-react>" "/home/vidbina/src/formation.tool..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "pb" ((def-buffer "20210421011345-philipps_byrne_gm..." "/home/vidbina/org/roam/philipps-..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "js" ((def-buffer "20211215130037-typescript.org" "/home/vidbina/org/roam/software/..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "personal" ((def-buffer "personal.org" "/home/vidbina/org/personal.org" org-mode) (def-buffer "20210918225737-hamburg.org" "/home/vidbina/org/roam/asabina/p..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil)) #<hash-table equal 8/10 0x134d42d> "/home/vidbina/.emacs.d/persp-con..." nil nil)
    persp-load-state-from-file()
    elisp--eval-last-sexp(nil)
    eval-last-sexp(nil)
    funcall-interactively(eval-last-sexp nil)
    command-execute(eval-last-sexp)
    #+end_quote
  - call with existing file ~(persp-load-state-from-file EXISTING_FILE_PATH)~ also fails
    #+begin_quote
    Debugger entered--Lisp error: (wrong-number-of-arguments #<subr persp-add-buffer> 4)
    persp-add-buffer(#<buffer magit: dotfiles> nil nil nil)
    #f(compiled-function (b) #<bytecode -0x142e8783c2428156>)(#<buffer magit: dotfiles>)
    mapc(#f(compiled-function (b) #<bytecode -0x142e8783c2428156>) (#<buffer magit: dotfiles> #<buffer dotfiles> #<buffer gnupg-backup> #<buffer magit-process: gnupg-backup> #<buffer magit-diff: gnupg-backup> #<buffer magit: gnupg-backup> #<buffer magit-process: dotfiles> #<buffer magit-diff: dotfiles>))
    #f(compiled-function (name dbufs dwc &optional dparams weak auto hidden) #<bytecode 0x6af63e4156f816a>)(nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (((min-height . 4) (min-width . 10) (min-height-ignore . 3) (min-width-ignore . 3) (min-height-safe . 1) (min-width-safe . 2) (min-pixel-height . 164) (min-pixel-width . 200) (min-pixel-height-ignore . 123) (min-pixel-width-ignore . 60) (min-pixel-height-safe . 41) (min-pixel-width-safe . 40)) leaf (pixel-width . 3192) (pixel-height . 1715) (total-width . 160) (total-height . 42) (normal-height . 1.0) (normal-width . 1.0) (buffer "*scratch*" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 141) (start . 1)))) (def-params nil) t nil nil)
    apply(#f(compiled-function (name dbufs dwc &optional dparams weak auto hidden) #<bytecode 0x6af63e4156f816a>) (nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (((min-height . 4) (min-width . 10) (min-height-ignore . 3) (min-width-ignore . 3) (min-height-safe . 1) (min-width-safe . 2) (min-pixel-height . 164) (min-pixel-width . 200) (min-pixel-height-ignore . 123) (min-pixel-width-ignore . 60) (min-pixel-height-safe . 41) (min-pixel-width-safe . 40)) leaf (pixel-width . 3192) (pixel-height . 1715) (total-width . 160) (total-height . 42) (normal-height . 1.0) (normal-width . 1.0) (buffer "*scratch*" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 141) (start . 1)))) (def-params nil) t nil nil))
    persp-from-savelist-0((def-persp nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (((min-height . 4) (min-width . 10) (min-height-ignore . 3) (min-width-ignore . 3) (min-height-safe . 1) (min-width-safe . 2) (min-pixel-height . 164) (min-pixel-width . 200) (min-pixel-height-ignore . 123) (min-pixel-width-ignore . 60) (min-pixel-height-safe . 41) (min-pixel-width-safe . 40)) leaf (pixel-width . 3192) (pixel-height . 1715) (total-width . 160) (total-height . 42) (normal-height . 1.0) (normal-width . 1.0) (buffer "*scratch*" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 141) (start . 1)))) (def-params nil) t nil nil) #<hash-table equal 8/10 0x134d42d> nil)
    #f(compiled-function (pd) #<bytecode 0x49d2498a9f3c07>)((def-persp nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (((min-height . 4) (min-width . 10) (min-height-ignore . 3) (min-width-ignore . 3) (min-height-safe . 1) (min-width-safe . 2) (min-pixel-height . 164) (min-pixel-width . 200) (min-pixel-height-ignore . 123) (min-pixel-width-ignore . 60) (min-pixel-height-safe . 41) (min-pixel-width-safe . 40)) leaf (pixel-width . 3192) (pixel-height . 1715) (total-width . 160) (total-height . 42) (normal-height . 1.0) (normal-width . 1.0) (buffer "*scratch*" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 141) (start . 1)))) (def-params nil) t nil nil))
    persps-from-savelist-0(((def-persp nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (... leaf ... ... ... ... ... ... ...)) (def-params nil) t nil nil) (def-persp "notes" ((def-buffer "20210519191436-management.org" "/home/vidbina/org/roam/business/..." org-mode) (def-buffer "20210719134552-elisp.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "20210319000406-emacs.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "20210607090600-gpg.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "Makefile" "/home/vidbina/src/vidbina/gnupg-..." makefile-gmake-mode) (def-buffer "README.md" nil markdown-mode) (def-buffer "20210319152815-org_mode.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "README.org<gnupg-backup>" "/home/vidbina/src/vidbina/gnupg-..." org-mode) (def-buffer "README.backup.md" "/home/vidbina/src/vidbina/gnupg-..." markdown-mode) (def-buffer "references.bib" "/home/vidbina/org/roam/software/..." bibtex-mode) (def-buffer "keyformat.txt" "/home/vidbina/src/gpg/gnupg/agen..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "conf" ((def-buffer "org.el.gz" "/nix/store/9b2cr2b5ldkclxkiascbs..." emacs-lisp-mode) (def-buffer "README.org<emacs>" "/home/vidbina/src/vidbina/dotfil..." org-mode) (def-buffer "TAGS" "/nix/store/9b2cr2b5ldkclxkiascbs..." tags-table-mode) (def-buffer "utils.nix" "/home/vidbina/src/vidbina/nixos-..." nix-mode) (def-buffer "home-linux.nix" "/home/vidbina/src/vidbina/dotfil..." nix-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "product" ((def-buffer "README.org<product>" "/home/vidbina/src/formation.tool..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "clj-react" ((def-buffer "README.org<concept-clj-react>" "/home/vidbina/src/formation.tool..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "pb" ((def-buffer "20210421011345-philipps_byrne_gm..." "/home/vidbina/org/roam/philipps-..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "js" ((def-buffer "20211215130037-typescript.org" "/home/vidbina/org/roam/software/..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "personal" ((def-buffer "personal.org" "/home/vidbina/org/personal.org" org-mode) (def-buffer "20210918225737-hamburg.org" "/home/vidbina/org/roam/asabina/p..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil)) #<hash-table equal 8/10 0x134d42d> "~/.emacs.d/persp-confs/2022.06.0..." nil nil)
    persps-from-savelist(((def-persp nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (... leaf ... ... ... ... ... ... ...)) (def-params nil) t nil nil) (def-persp "notes" ((def-buffer "20210519191436-management.org" "/home/vidbina/org/roam/business/..." org-mode) (def-buffer "20210719134552-elisp.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "20210319000406-emacs.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "20210607090600-gpg.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "Makefile" "/home/vidbina/src/vidbina/gnupg-..." makefile-gmake-mode) (def-buffer "README.md" nil markdown-mode) (def-buffer "20210319152815-org_mode.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "README.org<gnupg-backup>" "/home/vidbina/src/vidbina/gnupg-..." org-mode) (def-buffer "README.backup.md" "/home/vidbina/src/vidbina/gnupg-..." markdown-mode) (def-buffer "references.bib" "/home/vidbina/org/roam/software/..." bibtex-mode) (def-buffer "keyformat.txt" "/home/vidbina/src/gpg/gnupg/agen..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "conf" ((def-buffer "org.el.gz" "/nix/store/9b2cr2b5ldkclxkiascbs..." emacs-lisp-mode) (def-buffer "README.org<emacs>" "/home/vidbina/src/vidbina/dotfil..." org-mode) (def-buffer "TAGS" "/nix/store/9b2cr2b5ldkclxkiascbs..." tags-table-mode) (def-buffer "utils.nix" "/home/vidbina/src/vidbina/nixos-..." nix-mode) (def-buffer "home-linux.nix" "/home/vidbina/src/vidbina/dotfil..." nix-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "product" ((def-buffer "README.org<product>" "/home/vidbina/src/formation.tool..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "clj-react" ((def-buffer "README.org<concept-clj-react>" "/home/vidbina/src/formation.tool..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "pb" ((def-buffer "20210421011345-philipps_byrne_gm..." "/home/vidbina/org/roam/philipps-..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "js" ((def-buffer "20211215130037-typescript.org" "/home/vidbina/org/roam/software/..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "personal" ((def-buffer "personal.org" "/home/vidbina/org/personal.org" org-mode) (def-buffer "20210918225737-hamburg.org" "/home/vidbina/org/roam/asabina/p..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil)) #<hash-table equal 8/10 0x134d42d> "~/.emacs.d/persp-confs/2022.06.0..." nil nil)
    persp-load-state-from-file("~/.emacs.d/persp-confs/2022.06.05")
    funcall-interactively(persp-load-state-from-file "~/.emacs.d/persp-confs/2022.06.05")
    command-execute(persp-load-state-from-file)
    #+end_quote
    - new call with valid file as input fails the same way like an empty call
      #+begin_src elisp
(f-file-p "~/.emacs.d/persp-confs/2022.06.05")
(persp-load-state-from-file "~/.emacs.d/persp-confs/2022.06.05")
      #+end_src

**** TODO Understand why persp-auto-save file is empty [2022-07-25 Mon 08:55]

Sometimes the auto-save file has the following content:

#+begin_src elisp
;; -*- mode: emacs-lisp; eval: (progn (pp-buffer) (indent-buffer)) -*-
((def-persp nil nil
            (def-wconf nil)
            (def-params nil)
            t nil nil))
#+end_src

** Password Store

I use [[https://www.passwordstore.org/][pass]] to manage passwords on my system.

The following configuration, demonstrates how to set up the =auth-source= package to use the password-store backend. You can confirm the backend by verifying that the =auth-sources= customizable variable is set to ~(password-store)~.

#+begin_src elisp
(use-package auth-source
  :straight (:type built-in)

  :config
  (auth-source-pass-enable))
#+end_src

The following is an example of how we access a password in a password store keystore.

#+begin_src elisp
(auth-source-pass-get 'secret "domain.tld/handle/password-YYYYMMDD")
#+end_src

Use the ideas in this section to configure your private Emacs config to setup all of the secrets, passwords and other tokens that you want to load from your password store.

* <<mail>> üìß Mail

For mail, there are a couple of options within Emacs. First, one needs to understand that a mail user agent (MUA) is a tool used to compose and read messages and a mail transfer agent (MTA) is a tool to send messages.

** MUA (Mail User Agent)

You will find the following MTA options in Emacs:
- *message-user-agent*, typically the default
- *sendmail-user-agent*
- *mh-e-user-agent*
- *gnus-user-agent*
- *mu4e-user-agent*, in case you're using mu4e

Read [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Mail-Methods.html][Mail Composition Methods (Emacs Manual)]] for more information on how to compose mail in Emacs.

*** WIP <<mu4e>> Mu4e

[[https://www.djcbsoftware.nl/code/mu/mu4e.html][Mu4e]] is a Maildir-friendly mail client that uses mu as a backend.

#+begin_src elisp :noweb yes :tangle init.el
;; https://www.djcbsoftware.nl/code/mu/mu4e.html
(use-package mu4e
  :after (:all
          <<mu4e-after>>)
  :straight (:type built-in)
  :demand t
  :bind (("C-c M 4" . mu4e))
  :hook (
         <<mu4e-hooks>>)
  :config
  <<mu4e-config>>
  :custom
  <<mu4e-custom>>)
#+end_src

For convenience, remember to prefix the update command by entering it as =C-u u= in a *mu4e-main* buffer or by entering =C-u C-c C-u= from the *mu4e-headers* buffer such that the update commands *run in the background*.

We will load mu4e after the [[message.el]] and [[sendmail.el]] packages are loaded.

#+begin_src elisp :noweb-ref mu4e-after
message
sendmail
#+end_src

**** Customizations

We set mu4e as the MUA:

#+begin_src elisp :noweb-ref mu4e-custom
(mail-user-agent 'mu4e-user-agent "Set mu4e a default MUA")
#+end_src

***** Compose

We enable =format=flowed= to allow mail viewers to self-determine a suitable wrapping strategy. See a [[https://news.ycombinator.com/item?id=20514314][HN thread]] on [[https://useplaintext.email/][Use plaintext email]]. This choice isn't universally supported as you may find in the [[https://wiki.openstack.org/wiki/MailingListEtiquette][Mailing List Etiquette]] on OpenStack.

#+begin_src elisp :noweb-ref mu4e-custom
(mu4e-compose-format-flowed t "Compose messages as format=flowed")
#+end_src

Also remember to bottom-post. This is something that I have to internalize myself.

***** TODO Send Behavior

The pre-context mu4e setup, by default expects a sent folder. By changing the sent messages behavior, we can avoid and then set the behavior again when we context switch.

#+begin_src elisp :noweb-ref mu4e-custom
(mu4e-sent-messages-behavior 'delete "Switch this behavior to 'sent within the appropriate contexts where directory mu4e-sent-folder is correctly set")
#+end_src

***** Confirmation on quiting mu4e

#+begin_src elisp :noweb-ref my4e-custom
('mu4e-confirm-quit nil "Stop asking to quit, it bugs me out")
#+end_src

***** TODO Attaching files through Dired

As outlined in the [[https://www.djcbsoftware.nl/code/mu/mu4e/Attaching-files-with-dired.html][mu4e appendix]], we enable the =dired-mode-hook= (see [[https://www.djcbsoftware.nl/code/mu/mu4e/Dired.html][Dired]]) that enables us to use =C-c RET C-a= to attach files to new or existing mu4e emails.

#+begin_src elisp :noweb-ref mu4e-hooks
;; https://www.djcbsoftware.nl/code/mu/mu4e/Dired.html
(dired-mode . turn-on-gnus-dired-mode)
#+end_src

Require =gnus-dired=:

#+begin_src elisp :noweb-ref mu4e-config
;; https://www.djcbsoftware.nl/code/mu/mu4e/Attaching-files-with-dired.html
(require 'gnus-dired)
#+end_src

The original =gnus-dired='s =gnus-dired-mail-buffers= returns
1. all message buffers in case =gnus-dired-mail-mode= is either =message-user-agent= or =gnus-user-agent= (unlikely to be the case for me since I'm using mu4e or notmuch) or
2. a filtered list of buffers that have =mail-mode= as their major mode.

We override it to return a list of buffers that derive =message-mode=.

#+begin_src elisp :noweb-ref mu4e-config
;; make the `gnus-dired-mail-buffers' function also work on
;; message-mode derived modes, such as mu4e-compose-mode
(defun gnus-dired-mail-buffers ()
  "Return a list of active message buffers."
  (let (buffers)
    (save-current-buffer
      (dolist (buffer (buffer-list t))
        (set-buffer buffer)
        (when (and (derived-mode-p 'message-mode)
                   (null message-sent-message-via))
          (push (buffer-name buffer) buffers))))
    (nreverse buffers)))
#+end_src

We set our preferred mail composition package:

#+begin_src elisp :noweb-ref mu4e-custom
(gnus-dired-mail-mode 'mu4e-user-agent)
#+end_src

***** Use fancy characters

Disabled until we have some font-issues resolved.

#+begin_src elisp :noweb-ref mu4e-custom
(mu4e-use-fancy-chars nil "Use fancy unicode characters for mu4e marks")
#+end_src

***** Headers

#+begin_src elisp :noweb-ref mu4e-custom
(mu4e-headers-fields '((:flags . 6) (:human-date . 12) (:from . 20) (:subject)))
#+end_src

**** PROTOTYPE Disable saving of drafts
:LOGBOOK:
- State "PROTOTYPE"  from "TODO"       [2023-01-31 Tue 07:16] \\
  Introducing this to minimize the draft files noise
:END:

Based on https://emacs.stackexchange.com/a/56334/37975

#+begin_src elisp :noweb-ref mu4e-config
(add-hook 'mu4e-compose-mode-hook #'(lambda () (auto-save-mode -1)))
#+end_src

#+begin_src elisp :noweb-ref mu4e-custom
(mu4e-sent-messages-behavior 'delete)
#+end_src

**** TODO Contexts

In mu4e we can use contexts to manage the different "contexts" in which we write and read email.

We configure mu4e to try to detect a context based using the match or :

#+begin_src elisp :noweb-ref mu4e-custom
(mu4e-context-policy 'ask)
#+end_src

During composing we do the same, just =ask-if-none=:

#+begin_src elisp :noweb-ref mu4e-custom
(mu4e-compose-context-policy 'ask)
#+end_src

Switching contexts during e-mail drafting can be achieved with the =C-c ;= binding. Just remember that.

***** TODO Example

The [[https://www.djcbsoftware.nl/code/mu/mu4e/Contexts-example.html][example contexts in the mu4e documentation]] should be sufficiently detailed to provide you insight into how to write your own. We can write contexts into our configuration as follows:

#+begin_src elisp :noweb-ref mu4e-config
(setq mu4e-contexts
      `( ,(make-mu4e-context
           :name "Sample"
           :enter-func (lambda () (mu4e-message "Into SAMPLE mu4e context"))
           :leave-func (lambda () (mu4e-message "Out of SAMPLE mu4e context"))
           :vars '(( user-mail-address . "foo@example.com")))))
#+end_src

The better approach, however is to write contexts through a personal file that is not tracked in this public repository. 

***** TODO Indexing

I started the config by turning indexing off indexing in order to handle this through a systemd service instead and unburden Emacs but mu4e doesn't play well with not managing indexing itself so we're going to let mu4e handle its index.

#+begin_src elisp :noweb-ref mu4e-custom
(mu4e-index-update-in-background t "Index in background")
#+end_src

****** TODO Debug Mode

#+begin_src elisp :noweb-ref mu4e-custom
(mu4e-mu-debug t "Run mu in debug mode")
#+end_src

****** TODO Strategies

I define two indexing strategies below of which you are only to keep one uncommented at a time.

******* TODO Behavior: Lean Indexing

The [[https://www.djcbsoftware.nl/code/mu/mu4e/Retrieval-and-indexing.html#Speeding-up-indexing][mu4e manual discusses how to speed up indexing]] which is something that we deliberately turn on because indexing takes a long time my machine and effectively locks me out of any mu4e use while ongoing.

#+begin_comment
üí° For the sake of index integrity, consider regularly running a full (clean) re-indexing of your maildirs.
#+end_comment

#+begin_src elisp :noweb-ref mu4e-custom
(mu4e-index-cleanup nil)
#+end_src

#+begin_src elisp :noweb-ref mu4e-custom
(mu4e-index-lazy-check t)
#+end_src

******** WIP Define heavy indexing job post hibernate

Solve the "locked out of mu4e because I'm indexing" problem by defining a heavier indexing job before or after hibernate to just make sure a thorough re-indexing happens before every /session/. Perhaps, before hibernate is better because when returning from suspend, I can imagine that there are plenty of things that I quickly want to get done, while I would be forgiving if I tell the machine to hibernate but it still takes it sweet time to continue a indexing chore before properly suspending.

******* TODO COMMENT Behavior: Thorough Indexing

The [[https://www.djcbsoftware.nl/code/mu/mu4e/Retrieval-and-indexing.html#Speeding-up-indexing][mu4e manual discusses how to speed up indexing]] which is something that we deliberately turn off to maximize index integrity -- even if it will cost a bit more time.

#+begin_src elisp :noweb-ref mu4e-custom
(mu4e-index-cleanup t "Run full cleanup phase after indexing")
#+end_src

#+begin_src elisp :noweb-ref mu4e-custom
(mu4e-index-lazy-check nil "Don't use indexing shortcuts")
#+end_src

See [[https://www.djcbsoftware.nl/code/mu/mu4e/Retrieval-and-indexing.html][Retrieval and indexing with mu4e (mu4e manual)]] for more insight on how to configure mail retrieval and indexing.

***** TODO Updating

****** TODO Retrieve outside of mu4e

I have configured mbsync to retrieve mail in my personal configuration

#+begin_src elisp :noweb-ref mu4e-custom
(mu4e-get-mail-command "true" "Noop during retrieval and just handle indexing")
(mu4e-update-interval 300 "Auto index every 5 minutes")
#+end_src

****** TODO COMMENT Retrieve in mu4e

#+begin_src elisp :noweb-ref mu4e-config
;; https://www.djcbsoftware.nl/code/mu/mu4e/Retrieval-and-indexing.html#Example-setup
(setq mu4e-get-mail-command "offlineimap"   ; or fetchmail, or ...
      mu4e-update-interval nil)             ; update every 5 minutes
#+end_src

**** TODO COMMENT Sendmail with Queueing

Based on Botha's [[https://vxlabs.com/2019/07/03/send-queued-mails-in-background-with-mu4e/][Sending queued mails in the background with mu4e]] article, we will load =smtpmail-async=, configure SMTP behavior and and advise the sender function to get things done async.

#+begin_src elisp :noweb-ref mu4e-after
smtpmail-async
#+end_src

We customize some SMTP variables as needed:

https://www.djcbsoftware.nl/code/mu/mu4e/Queuing-mail.html

#+begin_src elisp :noweb-ref mu4e-custom
;;(send-mail-function 'async-smtpmail-send-queued-mail)
;;(message-send-mail-function 'async-smtpmail-send-queued-mail)
(smtpmail-queue-mail t)
(smtpmail-queue-dir "~/.msmtp.queue")
#+end_src

***** TODO COMMENT Advise to function =smtp-send-queued-mail=

We define some advisers to get the job done (I'm super sleepy right now, so bear with me for the poor prose):

#+begin_src elisp :tangle init.el
(defun async-smtpmail-send-queued-mail (sync-func &rest args)
  (message "Starting asynchronous smtpmail-send-queued-mail")
  (async-start
   `(lambda ()
      (require 'smtpmail)
      ;; see smtpmail-async.el - we inject the same variables
      ,(async-inject-variables
        "\\`\\(smtpmail\\|async-smtpmail\\|\\(user-\\)?mail\\)-\\|auth-sources\\|epg\\|nsm"
        nil
        "\\`\\(mail-header-format-function\\|smtpmail-address-buffer\\|mail-mode-abbrev-table\\)")
      ;; if we don't use the above inject we can pass in specific variables like this:
      ;; (setq smtpmail-queue-dir ,smtpmail-queue-dir)
      ;; (setq smtpmail-smtp-server ,smtpmail-smtp-server)
      (,sync-func))
   (lambda (&optional _unused)
     (message "Done sending queued mail in the background."))))

;; https://emacs.stackexchange.com/a/14827/8743 has more, err, advice.
(advice-add #'smtpmail-send-queued-mail :around #'async-smtpmail-send-queued-mail)
#+end_src

***** WIP COMMENT Debug: not sending

#+begin_src text
Wrote /home/vidbina/mail/asabina-gmbh/Drafts/cur/1658705468.5cae8ee4619f75e9.vidbina-dell-xps-9360:2,DS
[mu4e] Saved (19 lines)
Sending...
Sending via mail...
message-multi-smtp-send-mail: Wrong number of arguments: ((bootstrap-version t) (sync-func &rest args) (message "Starting asynchronous smtpmail-send-queued-mail") (async-start (list 'lambda nil '(require 'smtpmail) (async-inject-variables "\\`\\(smtpmail\\|async-smtpmail\\|\\(user-\\)?mail\\)-\\|auth-sources\\|epg\\|nsm" nil "\\`\\(mail-header-format-function\\|smtpmail-address-buffer\\|mail-mode-abbrev-table\\)") (list sync-func)) #'(lambda (&optional _unused) (message "Done sending queued mail in the background.")))), 0Invalid face attribute :inherit mu4e-contact-face
#+end_src

***** WIP COMMENT Debug: sendmail: TLS handshake failed

#+begin_src text
sendmail: TLS handshake failed: An unexpected TLS packet was received.
sendmail: could not send mail (account personal from /home/vidbina/.config/msmtp/config)
#+end_src

*** READY COMMENT <<notmuch>> Notmuch
:LOGBOOK:
- State "PROTOTYPE"  from "TODO"       [2022-06-23 Thu 21:51] \\
  with linking in place the setup is more or less prototype-worthy
:END:

- Leo Gaskin's [[https://github.com/leotaku/literate-emacs/blob/master/init.org#notmuch][notmuch config]]
- Mu4e, Gnus and Notmuch comparison thread on [[https://www.reddit.com/r/emacs/comments/ebite6/mu4e_vs_gnus_vs_notmuch_for_emacs_email/][reddit]]
- Jethro Kuan's (author of Org-roam) [[https://github.com/jethrokuan/.emacs.d/blob/master/init.el][notmuch config]]

#+begin_src elisp :tangle init.el
;; https://git.notmuchmail.org/git/notmuch
(use-package notmuch
  :straight (:type built-in)
  :if (executable-find "notmuch")
  :commands (notmuch
             notmuch-tree
             notmuch-search
             notmuch-hello)
  :bind (("C-c M n" . notmuch)
         :map notmuch-search-mode-map
         ("SPC" . vidbina/notmuch-toggle-inbox))
  :init
  (evil-collection-notmuch-setup)
  :custom
  (notmuch-always-prompt-for-sender t)
  (notmuch-archive-tags '("-inbox" "-unread"))
  (notmuch-crypto-process-mime t)
  (notmuch-hello-sections '(notmuch-hello-insert-saved-searches))
  (notmuch-labeler-hide-known-labels t)
  (notmuch-message-headers '("Subject" "To" "Cc" "Bcc"))
  (notmuch-search-oldest-first nil)
  :config
  (notmuch-address-harvest)
  (require 'ol-notmuch))
  #+end_src

Notmuch has the following modes:
- *hello* which presents the starting page
- *search* which presents search results to a query
- *tree* which presents a thread and the message hierarchy
- *show* which presents the email

For insight into the evil bindings for notmuch, go have a look at the definition of ~evil-collection-notmuch-setup~ but for convenience, here are some bindings that you will likely rely on quite a bit:
- =cc= or =C= to compose mail with ~notmuch-mua-new-mail~ (like mu4e)
- =cR= reply
- =cf= forward
- === flag
- =+= add tag
- =-= remove tag
- =*= tag all
- =s= search
  - stash search in *search mode*
  - show stash in *show mode*
- =q= bury of kill buffer
- =g?= help or version information at notmuch-hello view
- =p= ~notmuch-show-save-attachments~ (like mu4e)
- =gd= goto address at point

**** PROTOTYPE Face for "deleted" tag

We can customize the face messages that we want to mark as deleted. The relevant section of my custom.el section at [2022-06-30 Thu 13:52] is displayed below for convenience:

#+begin_src elisp
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(default ((t (:inherit nil :height 203))))
 '(notmuch-tag-deleted ((t (:foreground "#a60000" :inverse-video t :strike-through "#a60000")))))
#+end_src

The =notmuch-tag-deleted= bit is customization of interest and it should be managed through the customization facility in Emacs

** MTA (Mail Transport Agent)

We configure *sendmail* to serve as our MTA (Mail Transport Agent) of choice to handle the sending of email. For sending (shipping) mail in Emacs, we have the following options:
- sendmail
- feedmail, which does some "massaging" (think transformations) on outgoing messages
- smtpmail, which directly delivers mail to SMTP mail server from an Emacs buffer
- mailclient, which triggers the system's mail client to continue editing of the message before shipping it off

*** Background

Some of the functions that are relevant:
- *sendmail-send-it*
- *feedmail-send-it*
- *smtpmail-send-it*
- *mailclient-send-it*
- +*message-smtpmail-send-it*+ calls =smtpmail-send-it= after evaluating =message-send-mail-hook= but is obsolete and *message-use-send-mail-function* is recommended instead which does almost the same (running =message-send-mail-hook= and then firing =send-mail-function=)

Since we are using sendmail (or something sendmail-compatible like msmtp), we will be customizing some sendmail.el and message.el variables to refect our setup details.

Piecing the ecosystem of Emacs function and variables together is a lot easier when there is a visual overview, so here goes.

#+begin_src dot :file images/sendmail-func-callgraph.png :exports results
digraph A {
  node [shape=box];
  feedmailsendit [label="feedmail-send-it"];
  mailclientsendit [label="mailclient-send-it"];
  smtpmailsendit [label="smtpmail-send-it"];

  subgraph cluster_message {
    node [shape=box];
    messagesendmailwithsendmail [label="message-send-mail-with-sendmail", style=filled, color=pink];
    hmdefsendmailfn [label="message--default-send-mail-function"];
    messagedefaultsendmailfunction [label="message-default-send-mail-function"];
    messagemultismtpsendmail [label="message-multi-smtp-send-mail"];

    messageusesendmailfunction [label="message-use-send-mail-function"];
    messagesendmailfunction [label="message-send-mail-function"];

    hmdefsendmailfn -> messagedefaultsendmailfunction [label="funcall"];
    messagedefaultsendmailfunction -> feedmailsendit;
    messagedefaultsendmailfunction -> sendmailqueryonce;
    messagedefaultsendmailfunction -> messagesendmailwithsendmail;
    messagedefaultsendmailfunction -> messageusesendmailfunction;
    messagesendmailfunction -> messagesendmailwithsendmail;
    messagemultismtpsendmail -> messagesendmailfunction;
    label="message.el";
    style=dotted;
  }

  subgraph cluster_sendmail {
    node [shape=box];

    sendmailsendit [label="sendmail-send-it", style=filled, color=pink];
    feedmailsendit [label="feedmail-send-it"];
    sendmailfunction [label="send-mail-function",shape=oval];
    sendmailqueryonce [label="sendmail-query-once"];
    sendmailprogram [label="sendmail-program",shape=oval,style=filled,color=yellow];

    sendmailfunction -> sendmailsendit;
    sendmailfunction -> sendmailqueryonce;
    sendmailfunction -> smtpmailsendit;
    sendmailfunction -> feedmailsendit;
    sendmailfunction -> mailclientsendit;
    sendmailsendit -> sendmailprogram;
    messagesendmailwithsendmail -> sendmailprogram;
    label="sendmail.el";
  }
}
#+end_src

#+ATTR_ORG: :width 800
#+ATTR_HTML: :width 100%
#+CAPTION: Exploration of of the callgraph in composing sendmail command strings
#+RESULTS:
[[file:images/sendmail-func-callgraph.png]]

#+NAME: mail-sendmail-and-message
#+begin_details org
#+HTML: <summary>Difference in how sendmail.el and message.el call the sendmail program.</summary>
You'll find that both =message-send-mail-with-sendmail= (from message.el) and =sendmail-send-it= (from sendmail.el) compose sendmail command strings. This is relevant because it could mean that the composition of the sendmail command could be different with differing results depending on which code calls the sendmail program.

Some arguments that may be set differently between message.el and sendmail.el are listed below:
- =-f=
  - message.el: if not =message-sendmail-f-is-evil=, ~(message-sendmail-envelope-from)~
  - sendmail.el: =envelope-from=
- extras
  - message.el: =message-sendmail-extra-arguments=
  - sendmail.el: nothing

Observe the snippets below for a excerpt of how sendmail.el and message.el compose the command string to call the sendmail program:

#+begin_src elisp :exports code
;; sendmail
(append (list (point-min) (point-max)
              sendmail-program
              nil errbuf nil "-oi")
        (and envelope-from
             (list "-f" envelope-from))
        ;; ;; Don't say "from root" if running under su.
        ;; (and (equal (user-real-login-name) "root")
        ;;      (list "-f" (user-login-name)))
        (and mail-alias-file
             (list (concat "-oA" mail-alias-file)))
        (if mail-interactive
            sendmail-error-reporting-interactive
          sendmail-error-reporting-non-interactive)
        ;; Get the addresses from the message
        ;; unless this is a resend.
        ;; We must not do that for a resend
        ;; because we would find the original addresses.
        ;; For a resend, include the specific addresses.
        (or resend-to-addresses '("-t"))
        (if mail-use-dsn
            (list "-N" (mapconcat #'symbol-name
                                  mail-use-dsn ",")))
        )
#+end_src

#+begin_src elisp :exports code
;; message.el
(append (list (point-min) (point-max)
              sendmail-program
              nil errbuf nil "-oi")
        message-sendmail-extra-arguments
        ;; Always specify who from,
        ;; since some systems have broken sendmails.
        ;; But some systems are more broken with -f, so
        ;; we'll let users override this.
        (and (null message-sendmail-f-is-evil)
             (list "-f" (message-sendmail-envelope-from)))
        ;; These mean "report errors by mail"
        ;; and "deliver in background".
        (if (null message-interactive) '("-oem" "-odb"))
        ;; Get the addresses from the message
        ;; unless this is a resend.
        ;; We must not do that for a resend
        ;; because we would find the original addresses.
        ;; For a resend, include the specific addresses.
        (if resend-to-addresses (list resend-to-addresses) '("-t")))
#+end_src

#+end_details

*** <<sendmail.el>> sendmail.el

I have a few sendmail settings that I want loaded, but we bumped into errors here about =sendmail-program= being undefined that suggests that sendmail isn't fully autoloaded at this point in the code and instead of moveing everything to a later point, we will use =with-eval-after-load= instead to trigger our customizations after package loading.

#+begin_src elisp :noweb yes :tangle init.el
(use-package sendmail
  :straight (:type built-in)
  :custom
  <<sendmail-custom>>)
#+end_src

We default by setting the mail functions to their blocking variety:

#+begin_src elisp :noweb-ref sendmail-custom
(send-mail-function 'smtpmail-send-it "Default to block")
#+end_src

**** COMMENT Use msmtp

#+begin_src elisp :noweb-ref sendmail-custom
(sendmail-program (executable-find "msmtp")
                  "Use msmtp as our sendmail compatible sender")
#+end_src

**** COMMENT Asynchronous mail sending with Sendmail

#+begin_src elisp :noweb-ref async-config
(require 'smtpmail-async)
#+end_src

#+begin_src elisp :noweb-ref async-custom
(send-mail-function 'async-smtpmail-send-it)
(message-send-mail-function 'async-smtpmail-send-it)
#+end_src

#+begin_src elisp :noweb-ref mu4e-after
smtpmail-async
#+end_src

**** Enable debugging mode

For visibility of our SMTP traffic, we enable debugging of SMTP output to a buffer named =*trace of SMTP session to <SOMEWHERE>*=.

#+begin_src elisp :noweb-ref sendmail-custom
(smtpmail-debug-info t "Enable debugging")
#+end_src

**** COMMENT Set msmtpq as sendmail-compatible program

Let's use =msmtp=, which is sendmail compatible, as the executable to be called. For a snappier experience one may also consider using =msmtpq= to locally queue messages in order to improve the UX.

#+begin_src elisp :noweb-ref sendmail-custom
(sendmail-program (executable-find "msmtpq")
                  "Use msmtp as our sendmail compatible sender")
#+end_src

Consult the [[https://marlam.de/msmtp/][msmtp website]] for more information.

**** Envelope From

#+begin_center
‚ö†Ô∏è This section may be moot as we will be using message.el facilities (identifiable by =message-=-prefixed function and variable names) for the sending of mail and message.el  does not seemt to rely on the sendmail.el-specific from-logic but reimplements its own. See the [[mail-sendmail-and-message][summary detailing some differences in how message.el and sendmail.el call the sendmail program]].
#+end_center

Check out the definition of function =sendmail-send-it= for a glimpse into how sendmail is being called. With variable =mail-specify-envelope-from= set to a non-=nil= value, this function calls ~(mail-envelope-from)~, which always returns the =From:= header of the e-mail when variable =mail-envelope-from= is set to ='header=, or defaults to =user-mail-address=.

In our case, instead of setting /from/ throught the =-f= argument we can use the =-a account= CLI option to specify the context for sendmail. We still have to provide some logic to make this work but disabling sendmail from accidentally setting =-f envelope-from= when calling sendmail is a good starting point to avoid some embarassing mishaps.

#+begin_src elisp :noweb-ref sendmail-custom
(mail-specify-envelope-from nil "Don't try to be smart, use user-mail-address")
(mail-envelope-from nil "Don't try to be smart, use user-mail-address")
#+end_src

#+begin_center
üí° My msmtp configuration does not define a default account in order to make account management very explicit. I don't accidentally want emails leaving my machine from a wrong SMTP server because msmtp assumed a default account.
#+end_center

*** <<message.el>> message.el

#+begin_src elisp :noweb yes :tangle init.el
(use-package message
  :straight (:type built-in)
  :custom
  <<message-custom>>)
#+end_src

We set the mail directory:

#+begin_src elisp :noweb-ref message-custom
(message-directory "~/mail/")
#+end_src

**** Set MTA

The message.el package provides a more general interfaces for message sending, so we will configure message.el to use sendmail as out MTA of choice:

#+begin_src elisp :noweb-ref message-custom
(message-send-mail-function 'message-send-mail-with-sendmail "Use sendmail as our MTA")
#+end_src

**** Envelope From

#+begin_src elisp :noweb-ref message-custom
(message-sendmail-f-is-evil t "Avoid setting -f (--from) when calling sendmail")
(message-sendmail-envelope-from 'header "Use From: header")
#+end_src

**** Misc

#+begin_src elisp :noweb-ref message-custom
(message-kill-buffer-on-exit t "Kill a buffer once a message is sent")
#+end_src

* üèÅ Finale

To keep our init as general as possible we store private information and language configurations in separate files since these are inherently personal concerns. This configuration will try to load [[file:lang.el]] and [[file:personal.el]] if these exist.

#+begin_src elisp :tangle init.el
(message "üí• Debug on error is %s" debug-on-error)

(load "~/.emacs.d/lang.el")
(load "~/.emacs.d/personal.el")
#+end_src

** Customizations

Furthermore we load customization since some configurations and changes to our Emacs setup will be persisted through the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Customizations.html][customization system]].

#+begin_src elisp :tangle init.el
;; https://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Customizations.html
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+end_src

* üìõ Personal Details

#+begin_quote
üí° You can copy the content in this section to your own personal.org file in this directory and configure all the =:tangle= arguments to output to =personal.el= to cook up your own personal part of your configuration through literal programming. Remember that you can tangle an Org-file into the resulting code with the ~(org-babel-tangle)~ command (mapped to =C-c C-v t= by default).
#+end_quote

Populate a [[file:personal.el]] file which defines your name, your e-mail details and some other very personal configuration bits such as theme customizations or personalized keybindings. Use the following snippet as an example of a configuration that may work.

#+begin_quote
üí° Tangling this section/file should produce [[file:personal-example.el]] that you can use as a reference for your own file.
#+end_quote

#+begin_src elisp :tangle personal-example.el
(setq user-full-name "David Asabina"
      inhibit-startup-screen t
      frame-title-format '(multiple-frames "%b" ("" "Emacs :: %b")))
#+end_src

** COMMENT Reenable some disabled commands

In order to meet new Emacs users half-way in terms of UX, some features/commands have been [[https://www.emacswiki.org/emacs/DisabledCommands][disabled by default]]. The [[https://www.emacswiki.org/emacs/BasicNarrowing][narrowing]] functionality allows one to narrow a buffer to a subset of it's original content. In Org-mode I often narrow to a chapter (subtree in an Org document) in order to reduce my context a bit (reduce the noise and enhance my focus). So, let's reenable some of the disabled commands needed for narrowing.

#+begin_src elisp :tangle personal-example.el
(put 'narrow-to-region 'disabled nil)
(put 'narrow-to-page 'disabled nil)
#+end_src

** Org-capture Templates

#+begin_src elisp :noweb yes :tangle personal-example.el
(setq org-capture-templates
      (list
       <<my-org-capture-templates>>
       nil))
#+end_src

Because templates expressed as string literals are difficult to read, debug and edit, we opt for a form that more closely represents the visual form that our templates will take on (i.e.: show real whitespacing for structure). The snippets in this section are tangled into real Org files which are referred to when setting =org-capture-template=.

‚ö†Ô∏è Please keep in mind that this section tangles into the absolute the relative path =templates/= which can wreak havoc on your setup if you already have files in that directory that you will need.

#+begin_src org :tangle templates/default.org
,* %^{Title}

Source: %u, %c

%i
#+end_src

Which can be configured using the following template entry:

#+begin_src elisp :noweb-ref my-org-capture-templates
(list "w" "Default Template" 'entry
      '(file+headline "~/org/protocol/capture.org" "Notes")
      `(file ,(expand-file-name "templates/default.org"))
      :empty-lines 1)
#+end_src

**** TODOs

#+begin_src org :tangle templates/todo.org
,* TODO %?

%i

%a
#+end_src

#+begin_src elisp :noweb-ref my-org-capture-templates
(list "t" "Todo" 'entry
      '(file+headline "~/org/todo.org" "Tasks")
      `(file ,(expand-file-name "templates/todo.org")))
#+end_src

**** Links

***** Capture template for a basic Link

For links we define the basic template:

#+begin_src org :tangle templates/link.org
,* TODO Read _%:description_

Source: %:annotation%?
#+end_src

Which we map to =L=:

#+begin_src elisp :noweb-ref my-org-capture-templates
(list "L" "Link Only" 'entry
      '(file+headline "~/org/protocol/capture.org" "Links")
      `(file ,(expand-file-name "templates/link.org"))
      :empty-lines 2)
#+end_src

***** Capture template for Link with Text

For links with additional text we define the template:

#+begin_src org :tangle templates/link-with-text.org
,* TODO Read %^{title}

Source: %:annotation

,#+begin_quote
%i
,#+end_quote%?
#+end_src

which we map to =p=:

#+begin_src elisp :noweb-ref my-org-capture-templates
(list "p" "Link with Selected Text" 'entry
      '(file+headline "~/org/protocol/capture.org" "Links")
      `(file ,(expand-file-name "templates/link-with-text.org"))
      :empty-lines 2)
#+end_src

** Email

*** Citation line

In order to keep things lean, I've defined my own citation line that easy enough to parse as opposed to the default line.

#+begin_src elisp :tangle personal-example.el
(setq message-citation-line-format "On %d.%m.%Y, %f wrote:\n"
      message-citation-line-function #'message-insert-formatted-citation-line)
#+end_src

*** üìß Mu4e

**** TODO Contexts

In order to get mail to work for multiple mailboxes you will need to configure [[https://www.djcbsoftware.nl/code/mu/mu4e/Contexts.html][mu4e contexts]]. Refer to the [[https://www.djcbsoftware.nl/code/mu/mu4e/Contexts-example.html][examples]] in the documentation for some guidance on how to define contexts.

#+begin_src elisp :tangle personal-example.el
;; TODO fill in the blanks for mu4e-contexts
(setq mu4e-contexts `())
#+end_src

**** COMMENT Signing

#+begin_src elisp :tangle personal-example.el
(add-hook 'mu4e-compose-mode-hook 'mml-secure-sign-pgpmime)
#+end_src

**** COMMENT HTML Mail Escape-hatch

In order to conveniently view HTML mail which may not always be presented in a pleasantly readable manner inside of E-macs, you may appreciate using the escape hatch and viewing such pages in a proper browser. The view-actions menu can be pulled up by executing ~(mu4e-view-action)~ or pressing =A= while in the mu4e mail view.

#+begin_src elisp :tangle personal-example.el
;; https://www.djcbsoftware.nl/code/mu/mu4e/Reading-messages.html
(add-to-list 'mu4e-view-actions
             '("ViewInBrowser" . mu4e-action-view-in-browser) t)
#+end_src

#+begin_quote
üí° Since there is so much trash hidden in HTML mails (e.g.: pixels), I tend to paste (and follow) these links in private, incognito or profile-isolated browser tabs instead. Perhaps something you can consider if you you're not in the mood to be too generous (or nonchalant) with your data.
#+end_quote

**** TODO COMMENT Debug sendmail issue

#+begin_src text
QuitInvalid face attribute :inherit mu4e-contact-face
Invalid face attribute :inherit mu4e-contact-face [2 times]
#+end_src

Finding this after attempts to sendmail and then noticing that Emacs hangs. I need to figure out async sendmail configuration. This all started when I tried to set up sending aliases but to be fair, yesterday ([2022-07-07 Thu 23:47]) our DNS config broke (due to a domain going into redemption status) so perhaps I need to retry in a few hours.

*** Notmuch

https://notmuchmail.org/emacstips/

#+begin_src elisp :tangle personal-example.el
(setq notmuch-saved-searches
      '((:name "inbox" :query "tag:inbox" :key "i")
        (:name "unread" :query "tag:unread" :key "u")
        (:name "flagged" :query "tag:flagged" :key "f")
        (:name "sent" :query "tag:sent" :key "t")
        (:name "drafts" :query "tag:draft" :key "d")
        (:name "all mail" :query "*" :key "a")))
#+end_src

** ü•≥ Personal Helpers

Here be dragons! üêâ This is my personal collection of helpers that I use for little things like switching themes, managing wrapping inside of buffers, managing opening of URL's and more junk. I will not explain these as these are simple enough and I'm not expecting me needing to explain this to myself or others (you likely will want to write your own).

*** Themes

#+begin_src elisp :tangle personal-example.el
(defcustom vidbina/theme-should-be-dark nil
  "Non-nil means that the theme should be dark"
  :type 'boolean
  :group 'display)

(defun vidbina/theme-switch-to-choice ()
  "Switch to the theme of choice"
  (message "ü¶ã Switching to vidbina's theme")
  (if vidbina/theme-should-be-dark
      (vidbina/theme-switch-to-dark)
    (vidbina/theme-switch-to-light)))

(defun vidbina/theme-switch-to-dark ()
  "Switch to the dark theme"
  (interactive)
  (modus-themes-load-vivendi)
  (setq org-format-latex-options
        '(:scale 2 :foreground "White" :background "Transparent")
        zoom-window-mode-line-color "DodgerBlue4")
  (message "üåë Theme is dark")
  (customize-save-variable 'vidbina/theme-should-be-dark t))

(defun vidbina/theme-switch-to-light ()
  "Switch to the light theme"
  (interactive)
  (modus-themes-load-operandi)
  (setq org-format-latex-options
        '(:scale 2 :foreground "Black" :background "Transparent")
        zoom-window-mode-line-color "Gold")
  (message "üåï Theme is light")
  (customize-save-variable 'vidbina/theme-should-be-dark nil))

(defun vidbina/theme-toggle ()
  "Toggle theme"
  (interactive)
  (if vidbina/theme-should-be-dark
      (vidbina/theme-switch-to-light)
    (vidbina/theme-switch-to-dark)))

(add-hook 'after-init-hook 'vidbina/theme-switch-to-choice)
#+end_src

*** Org-Export

#+begin_src elisp :tangle personal-example.el
(defun vidbina/toggle-local-org-export-use-babel ()
  "Toggle buffer-local org-export-use-babel"
  (interactive)
  (if org-export-use-babel
      (setq-local org-export-use-babel nil)
    (setq-local org-export-use-babel t))
  (message (format "‚ùì org-export confirm = %s" org-export-use-babel)))

(defun vidbina/toggle-local-org-confirm-babel-evaluate ()
  "Toggle buffer-local org-confirm-babel-evaluate"
  (interactive)
  (if org-confirm-babel-evaluate
      (setq-local org-confirm-babel-evaluate nil)
    (setq-local org-confirm-babel-evaluate t))
  (message (format "‚òëÔ∏è Org Babel confirmation is %s" org-confirm-babel-evaluate)))
#+end_src

*** Wrapping

#+begin_src elisp :tangle personal-example.el
(defun vidbina/wrap ()
  "Toggle wrapping using adaptive-wrap-prefix-mode and visual-line-mode"
  (interactive)
  (let ((vidbina/wrap-set
         (lambda (state)
           (progn
             (if state
                 (progn
                   (visual-line-mode +1)
                   (adaptive-wrap-prefix-mode +1))
               (visual-line-mode -1)
               (adaptive-wrap-prefix-mode -1))
             (setq-local vidbina/wrap--state state)
             (message (format "üéÅ state=%s wrap -> %s and line -> %s" state adaptive-wrap-prefix-mode visual-line-mode))))))
    (unless (boundp 'vidbina/wrap--state)
      (setq-local vidbina/wrap--state nil))
    (funcall vidbina/wrap-set (not vidbina/wrap--state))))
#+end_src

#+begin_src elisp :tangle personal-example.el

;; https://stackoverflow.com/questions/12663061/emacs-auto-scrolling-log-buffer
(defun vidbina/tail-buffer ()
  (setq-local window-point-insertion-type t))
#+end_src

*** Web-Browsing

#+begin_src elisp :tangle personal-example.el
(defun vidbina/browse-url-xsel (url &optional ignored)
  (shell-command (format "echo \"%s\" | xsel -ib" url)))

(setq browse-url-browser-function 'vidbina/browse-url-xsel)

(defun vidbina/browse-to-current-file ()
  "Open saved HTML file with default browser"
  (progn
    (when (derived-mode-p 'html-mode)
      (progn
        (message (concat "Browse " buffer-file-name))
        (browse-url (file-truename buffer-file-name))))))

(add-hook 'after-save-hook 'vidbina/browse-to-current-file)
#+end_src

*** Notmuch Inbox Toggler

#+begin_src elisp :tangle personal-example.el
(defun vidbina/notmuch-toggle-inbox ()
  "toggle inbox tag of message"
  (interactive)
  (if (member "inbox" (notmuch-search-get-tags))
      (notmuch-search-tag (list "-inbox"))
    (notmuch-search-tag (list "+inbox"))))

(evil-collection-define-key 'normal 'notmuch-search-mode-map
  "i" 'vidbina/notmuch-toggle-inbox)
#+end_src

*** Mail Signature Helpers

#+begin_src elisp :tangle personal-example.el
(defun vidbina/mail-sig-match (pattern from)
  "Matches From field to a regex"
  (string-match-p pattern from))

(defun vidbina/mail-sig-file (path)
  "Retrieves a signature text by path"
  (format "%s" (with-temp-buffer
                          (insert-file-contents path)
                          (buffer-string))))

(defun vidina/mail-sig ()
  "Returns signature based on From field"
  (let ((from-field (message-field-value "From")))
    (message "Trying out signature for %S" from-field)
    (pcase (or from-field "")
      ((pred (vidbina/mail-sig-match "@example.com"))
       (vidbina/mail-sig-file "/home/example/my-example.sig"))
      (_ (format "Be kind! ü§ó")))))

(setq message-signature #'vidbina/mail-sig)
#+end_src

*** Org-roam UI Navigation

#+begin_src elisp :tangle personal-example.el
(defcustom vidbina/orui-node-zoom-padding 10
  "Padding to pass to org-roam-ui when navigating with vidbia-org-roam-ui-node-zoom"
  :type 'number
  :group 'display)

(defun vidbina/orui-node-zoom-padding-set ()
  "Set the padding for org-roam-ui-node-zoom"
  (interactive)
  (let ((padding (read-number "üîç:" vidbina/orui-node-zoom-padding)))
    (customize-save-variable 'vidbina/orui-node-zoom-padding padding)))

(defun vidbina/orui-node-zoom ()
  "Zoom to org-roam-ui node with custom padding"
  (interactive)
  (let ((id (org-roam-id-at-point))
        (padding vidbina/orui-node-zoom-padding))
    (org-roam-ui-node-zoom id nil padding)
    (message "üï∏Ô∏è ORUI zoom üîç %s to %s" id padding)))
#+end_src

*** Helper for Desktop Entries to handle different MIME types

We can configure [[https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html][desktop entries (freedesktop.org)]] that open URI's in a new frame using the =--create-frame= (shorthand =-c=) argument while also setting the xproperties through =--frame-parameters= (shorthand =-F=) that may aid a window manager in positioning the windows correctly. I learned about defining frame parameters first through a [[https://stackoverflow.com/questions/16012024/using-emacsclient-instead-of-emacs-translating-arguments][StackOverflow thread]] thread. The following snippet provides a demonstration on how to open a frame through the aforementioned parameters:

#+begin_src bash :async
emacsclient -F '((name . "Dired"))' --create-frame -a emacs --eval "(let ((path \"/tmp\")) (delete-other-windows-internal) (message (concat \"Dired will open: \" path)) (dired path) path)"
#+end_src

#+RESULTS:
: /tmp

Note that eval has to be a single expression. In the following example we wrap multiple sexps in a =progn= form to qualify as a single expression:

#+begin_src bash :async
emacsclient -F '((name . "experiment"))' --create-frame -a emacs --eval "(progn (message \"hi there\") (message \"bye\"))"
#+end_src

Considering how verbose the eval value is and how error prone modifying this may be, we define a helper function for simplicity.

When create-frame is set, we create a new frame with =make-frame-command= and then clear that frame from any other windows through the =delete-other-windows-internal= command. This is useful because the creation of a new frame doesn't always yield a "clean frame" and could therefore be rather noisy (as it may display the multiple windows that were in the previously active frame).

#+begin_src elisp :tangle personal-example.el
(defun vidbina-mime-handle--open (window-name func target &optional create-frame)
  "Spawn a new frame with the proper qualities"
  ;;(if create-frame (select-frame (make-frame `((name . ,window-name)))))
  (message (concat "MIME handler opening " target))
  (if create-frame (progn
                     (select-frame (make-frame-command))
                     (delete-other-windows-internal)))
  (funcall func target)
  (message "MIME handler opened: \"%s\" in \"%s\"" target window-name))
#+end_src

The helper can be tested through the snippet below and should be less disruptive when the =create-frame= argument is set since:
1. it opens up a new frame (leaving existing frames as-is)
2. reduces the new frame to a single window where only the opened location is presented (for focus)

#+begin_src elisp
(vidbina-mime-handle--open "Dired" #'dired "/tmp" 'create-frame)
#+end_src

#+begin_quote
‚ö†Ô∏è The setting of the create-frame argument may only be necessary when you are not using the =--create-frame= CLI argument when invoking the =emacsclient= command.
#+end_quote

The defined function can be used inside of a =Exec= key of a [[https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-0.9.5.html
][Desktop entry]] i.e.: a .desktop file.

#+begin_src sh :async :results none
emacsclient -a emacs -F "((name . \"emacs-dired\"))" --eval "(vidbina-mime-handle--open \"Dired\" #'dired \"/tmp\" 'create-frame)"
#+end_src

**** Specialized User-friendly Helpers

Invoking =vidbina-mime-handle--open= through an =Exec= key in a desktop entry gets messy because we're entering a sexp that references function symbols. Just keeping everything escaped correctly is already a non-trivial problem (for me). It gets even worse when trying to formulate such command invocations inside of a declarative Nix-based configuration where we introduce another level of "escaping" special characters. üò≠

At some point it becomes too Inception-esque to reasonably assume that future me will be able to use it with relative ease. Specialized helpers are therefore formulated to greatly reduce the complexity of the information to be entered into a /Desktop Entry/'s =Exec= key.

#+begin_src elisp :tangle personal-example.el
(defun vidbina-mime-handle-open-directory (window-name target &optional create-frame)
  "Open a directory in a new frame"
  (vidbina-mime-handle--open window-name #'dired target create-frame))
#+end_src

#+begin_src elisp :tangle personal-example.el
(defun vidbina-mime-handle-open-message-in-mu4e (window-name target &optional create-frame)
  "Open a message in a new frame"
  (vidbina-mime-handle--open window-name #'mu4e target create-frame))
#+end_src

*** Conveniences

**** WIP Store input to kill-ring

Writing to the kill ring is done on a buffer-basis. Sometimes one just want to yank (in vim-lingo) or kill (in Emacs-lingo) a value to the kill-ring for later reference.

#+begin_src elisp :tangle personal-example.el
(defun vidbina/kill (object)
  "Yank object"
  (with-temp-buffer
    (insert object)
    (kill-region (point-min) (point-max))))
#+end_src

**** WIP Open process buffer below active buffer

#+begin_src elisp :tangle personal-example.el
(defun vidbina/open-proc-below (proc)
  "Open proc buffer below the current buffer"
  (save-excursion
    (split-window-below)
    (evil-window-down 1)
    (switch-to-buffer (process-buffer proc))
    (evil-window-up 1)))
#+end_src

**** WIP Remove text properties

#+begin_src elisp :tangle personal-example.el
(defun vidbina/unpropertize (string)
  "Remove the text properties from a string"
  (let* ((s string)
         (start 0)
         (end (length string)))
    (set-text-properties start end nil s)
    s))

(defalias 'vidbina/depropertize 'vidbina/unpropertize)
;; https://nullprogram.com/blog/2019/12/10/
(put 'vidbina/depropertize 'byte-optimizer 'byte-compile-inline-expand)
#+end_src

**** WIP Copy VC branch for later use

Sometimes, I just need the current branch name to paste into an email or somewhere else. The =M-w= binding, mapped to ~(magit-copy-buffer-revision)~, typically only provides a rev which isn't always sufficiently informative and only works within a select few major (magit) modes.

#+begin_src elisp :tangle personal-example.el
(defun vidbina/magit-branch ()
  "Copy, kill (in Emacs lingo) or yank (in vim lingo) the current branch name"
  (interactive)
  (let ((target (magit-get-current-branch)))
    (vidbina/kill target)
    (message target)))
#+end_src

** TODO Misc

*** Global Keybindings

#+begin_src elisp :tangle personal-example.el
(global-set-key (kbd "C-c v l") 'vidbina/theme-switch-to-light)
(global-set-key (kbd "C-c v d") 'vidbina/theme-switch-to-dark)
(global-set-key (kbd "C-c v TAB") 'vidbina/wrap)
(global-set-key (kbd "C-c v \\") 'visual-fill-column-mode)
(global-set-key (kbd "C-c v SPC") 'whitespace-mode)
(global-set-key (kbd "C-c v c") 'completion-at-point)
(global-set-key (kbd "C-c v O") 'vidbina/orui-node-zoom-padding-set)
(global-set-key (kbd "C-c v _") 'vidbina/tail-buffer)
(global-set-key (kbd "C-c v .") 'vidbina/orui-node-zoom)

(global-set-key (kbd "C-c v z") 'zoom-window-zoom)

(global-set-key (kbd "C-c l") 'org-store-link)
(global-set-key (kbd "C-c a") 'org-agenda)
#+end_src

*** Visual Aids

#+begin_src elisp :tangle personal-example.el
(setq fill-column 1)

(setq whitespace-style '(trailing tabs newline tab-mark newline-mark))
#+end_src

*** Org Conveniences

#+begin_src elisp :tangle personal-example.el
;; https://orgmode.org/manual/Handling-Links.html
(setq org-return-follows-link t)

(setq org-log-into-drawer "LOGBOOK")

;; Allow for resizing of images
(setq org-image-actual-width nil)

(setq org-html-head-extra
      "<link rel=\"alternate stylesheet\" type=\"text/css\" href=\"~/org/style.css\" />")
;; https://www.gnu.org/software/emacs/manual/html_node/emacs/Position-Info.html
#+end_src

*** Reload inline images after Org export

#+begin_src elisp :tangle personal-example.el
;; https://joy.pm/post/2017-09-17-a_graphviz_primer/
(defun my/fix-inline-images ()
  (when org-inline-image-overlays
    (org-redisplay-inline-images)))

(add-hook 'org-babel-after-execute-hook 'my/fix-inline-images)
#+end_src

*** <<mode-line>> Customize Mode-line

For additional context, one can display /mode line/ or /header line/ elements along the bottom and top of a window respectively.

#+begin_src elisp :noweb yes :tangle personal-example.el
;; https://www.gnu.org/software/emacs/manual/html_node/elisp/Mode-Line-Variables.html
;; http://emacs-fu.blogspot.com/2011/08/customizing-mode-line.html
(setq-default mode-line-format
              (list "%e"
                    ;; ** when modified
                    ;; -- if not modified
                    ;; %% when read-only
                    ;; %+ read-only but modified
                    mode-line-modified

                    <<persp-lighter>>

                    mode-line-frame-identification
                    mode-line-buffer-identification

                    ;; https://evil.readthedocs.io/en/latest/overview.html?highlight=mode-line#modes-and-states
                    ;; <N> normal state
                    ;; <I> insert state
                    ;; <V> visual state
                    ;; <R> replace state
                    ;; <O> operator-pending state
                    ;; <M> motion state
                    ;; <E> emacs state
                    (propertize evil-mode-line-tag
                     'face 'italic
                     'mouse-face 'bold-italic)

                    mode-line-modes
                    (propertize "(%c,%l)%p ")
                    "‚àé"))
(message "üïπÔ∏è Mode-line set")
#+end_src

You can force update the mode line in the =setq= doesn't quite get the job done:

#+begin_src elisp :results none
(force-mode-line-update t)
#+end_src

**** TODO Debug why evil-mode-line-tag in the mode-line is not updating

I stubbed a helper to try to coerce a modeline update since I noticed on [2023-01-24 Tue 20:49] (while enroute to CDMX üá≤üáΩ) that the mode-line was not updating for the evil mode lighter.

#+begin_src elisp :tangle personal-example.el
(defun vidbina/refresh-mode-line ()
  (interactive)
  (message "Updating mode-line %s" evil-mode-line-tag)
  (force-mode-line-update t)
  (evil-refresh-mode-line))
#+end_src

In Org and Elisp buffers the mode line is not updating but in the =*Messages*= buffer, I have observed

** Security

*** Org-crypt

In order to [[https://orgmode.org/worg/org-tutorials/encrypting-files.html][encrypt entries of Org files]], the package org-crypt needs to be configured.

#+begin_src elisp :tangle personal-example.el
(require 'org-crypt)
(org-crypt-use-before-save-magic)
#+end_src

**** Usage

Usage of org-crypt is as simple as tagging the heading of a section to be encrypted with =:crypt:=. With the =org-crypt-key= variable set to =nil=, symmetric encryption is used. By setting this variable to a string, or by setting the =CRYPTKEY= property as demonstrated below, we can encrypt against a GPG public key of choice.

#+begin_example org
,* For all eyes

This is nothing special

,* For my eyes only :crypt:
:PROPERTIES:
:CRYPTKEY: 0xffffffffffffffffffffffffffffffffffffffff
:END:

This would be encrypted upon safe üòâ

,* Local File Variables

Disable auto-save since I'm using crypt in this file.

# Local Variables:
# auto-save-default: nil
# End:
#+end_example

****** TODO Verify if =epa-file-encrypt-to= works as expected

An alternate approach would be to append the =epa-file-encrypt-to= variable to the local variables list. The benefit of this is that one can encrypt a file for multiple recipients. I haven't tested this yet. ü§î

* üí¨ Languages

Populate a =lang.el= file which defines all of the major-modes and language-related tooling that are relevant to you. In my case I have simply defined a symlink from [[file:lang.example.el][lang.example.el]] to lang.el. The literal configuration in this section defines my own languages setup. YMMV! ü§∑üèø‚Äç‚ôÇÔ∏è

** Natural Language

*** Spell Checking

Use the built-in ispell for spell checking.

This configuration is derived from the article [[https://200ok.ch/posts/2020-08-22_setting_up_spell_checking_with_multiple_dictionaries.html][Setting up spell checking with multiple dictionaries in Emacs (by Alain M. Lafon from 200ok.ch)]].

**** Ported use-package configuration

#+begin_src elisp :tangle lang.example.el
;; https://200ok.ch/posts/2020-08-22_setting_up_spell_checking_with_multiple_dictionaries.html
(use-package ispell
  :straight (:type built-in)
  :custom
  (ispell-program-name "hunspell")
  ;; Configure German, Swiss German, and two variants of English.
  (ispell-dictionary "en_US,de_DE,nl")
  ;; For saving words to the personal dictionary, don't infer it from
  ;; the locale, otherwise it would save to ~/.hunspell_de_DE.
  (ispell-personal-dictionary "~/.hunspell_personal")
  (ispell-personal-dictionary "~/.hunspell_personal")
  :config
  ;; https://www.emacswiki.org/emacs/FlySpell#h5o-14
  (add-to-list 'ispell-skip-region-alist '("^#+BEGIN_SRC" . "^#+END_SRC"))

  ;; ispell-set-spellchecker-params has to be called
  ;; before ispell-hunspell-add-multi-dic will work
  (ispell-set-spellchecker-params)
  (ispell-hunspell-add-multi-dic ispell-dictionary)
  ;; The personal dictionary file has to exist, otherwise hunspell will
  ;; silently not use it.
  (unless (file-exists-p ispell-personal-dictionary)
    (write-region "" nil ispell-personal-dictionary nil 0)))
#+end_src

**** COMMENT FlySpell

#+begin_src elisp :tangle lang.example.el
#+end_src

**** COMMENT Original with-eval-after-load configuration

#+begin_src elisp :tangle lang.example.el
;; https://200ok.ch/posts/2020-08-22_setting_up_spell_checking_with_multiple_dictionaries.html
(with-eval-after-load "ispell"
  (setq ispell-program-name "hunspell")
  ;; Configure German, Swiss German, and two variants of English.
  (setq ispell-dictionary "en_US,de_DE,nl")
  ;; ispell-set-spellchecker-params has to be called
  ;; before ispell-hunspell-add-multi-dic will work
  (ispell-set-spellchecker-params)
  (ispell-hunspell-add-multi-dic ispell-dictionary)
  ;; For saving words to the personal dictionary, don't infer it from
  ;; the locale, otherwise it would save to ~/.hunspell_de_DE.
  (setq ispell-personal-dictionary "~/.hunspell_personal")

  ;; The personal dictionary file has to exist, otherwise hunspell will
  ;; silently not use it.
  (unless (file-exists-p ispell-personal-dictionary)
    (write-region "" nil ispell-personal-dictionary nil 0)))
#+end_src

** Markup Languages

*** COMMENT Org

#+begin_src elisp :tangle lang.example.el
;; https://www.gnu.org/software/emacs/manual/html_node/elisp/Hooks-for-Loading.html
;; https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-gnuplot.html#sec-4
(with-eval-after-load 'org
  (message "Loading org-babel-language mappings")
  (org-babel-do-load-languages 'org-babel-load-languages
                               '((shell . t)
                                 (clojure .  t)
                                 (gnuplot . t)
                                 (haskell . t)
                                 (makefile . t)
                                 ;; (nix . t) ;; TODO: Figure out why broken
                                 (python . t))))
#+end_src

*** Markdown

#+begin_src elisp :tangle lang.example.el
;; https://jblevins.org/projects/markdown-mode/
(use-package markdown-mode
  :straight (markdown-mode :type git
                           :host github
                           :repo "jrblevin/markdown-mode")
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init
  (setq markdown-command "multimarkdown"))
#+end_src

** Serialization Languages/Formats

*** JSON

[[https://github.com/joshwnj/json-mode][JSON-mode]] provides a major-mode and some keybindings to simplify working with JSON.

#+begin_src elisp :tangle lang.example.el
;; https://github.com/joshwnj/json-mode
(use-package json-mode
  :straight (json-mode :type git
                       :host github
                       :repo "joshwnj/json-mode"))
#+end_src

Some of the relevant keybindings are:
- =C-c C-f= format region or buffer with =json-reformat=
- =c-c P= copy path to object at point to the kill ring

**** JSON Reformat

[[https://github.com/gongo/json-reformat][JSON Reformat]] provides convenience helpers to reformat JSON in string or region.

#+begin_src elisp :tangle lang.example.el
;; https://github.com/gongo/json-reformat
(use-package json-reformat
  :straight (json-reformat :type git
                           :host github
                           :repo "gongo/json-reformat"))
#+end_src

**** JSON Snatcher: Extract Element Paths within a JSON Structure

[[https://github.com/Sterlingg/json-snatcher][JSON Snatcher]] allows extraction of "addresses" or "paths" to an item within a JSON structure i.e.: /snatching/.

#+begin_src elisp :tangle lang.example.el
;; https://github.com/Sterlingg/json-snatcher
(use-package json-snatcher
  :straight (json-snatcher :type git
                           :host github
                           :repo "Sterlingg/json-snatcher"))
#+end_src

**** Jsonnet

#+begin_src elisp :tangle lang.example.el
;; https://github.com/tminor/jsonnet-mode
(use-package jsonnet-mode
  :straight (jsonnet-mode :type git
                          :host github
                          :repo "tminor/jsonnet-mode"))
#+end_src

*** YAML

#+begin_src elisp :tangle lang.example.el
;; https://github.com/yoshiki/yaml-mode
(use-package yaml-mode
  :straight (yaml-mode :type git
                       :host github
                       :repo "yoshiki/yaml-mode"))
#+end_src

** Viz Languages for graphing, plotting and more

*** PlantUML

#+begin_src elisp :tangle lang.example.el
;; https://github.com/skuro/plantuml-mode
(use-package plantuml-mode
  :straight (plantuml-mode :type git
                           :host github
                           :repo "skuro/plantuml-mode")
  :after org
  :config
  ;; https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-dot.html
  (setq org-plantuml-exec-mode 'plantuml)

  (setq plantuml-default-exec-mode 'executable)
  (org-babel-do-load-languages 'org-babel-load-languages
                               (append org-babel-load-languages
                                       '((plantuml . t)))))
#+end_src

*** Graphviz

#+begin_src elisp :tangle lang.example.el
;; https://github.com/ppareit/graphviz-dot-mode
(use-package graphviz-dot-mode
  :straight (graphviz-dot-mode :type git
                               :host github
                               :repo "ppareit/graphviz-dot-mode")
  :after org
  :config
  (setq graphviz-dot-indent-width 2)
  (org-babel-do-load-languages 'org-babel-load-languages
                               (append org-babel-load-languages
                                       '((dot . t)))))
#+end_src

*** Gnuplot

#+begin_src elisp :tangle lang.example.el
;; https://github.com/emacsorphanage/gnuplot
;; also https://github.com/bruceravel/gnuplot-mode
;; also https://github.com/rudi/gnuplot-el
(use-package gnuplot
  :straight (gnuplot :type git
                     :host github
                     :repo "emacsorphanage/gnuplot")
  :after org
  :config
  (org-babel-do-load-languages 'org-babel-load-languages
                               (append org-babel-load-languages
                                       '((gnuplot . t)))))
#+end_src

** DSL

The selected nomer is a poor choice if you think about it. ü§î Plotting languages are arguably domain-specific, markup languages are arguably domain specific -- naming is hard. ü§∑üèø‚Äç‚ôÇÔ∏è

*** Shell

#+begin_src elisp :tangle lang.example.el
(with-eval-after-load 'org
  (message "Load Shell into Org Babel")
  (org-babel-do-load-languages 'org-babel-load-languages
                               (append org-babel-load-languages
                                       '((shell . t)))))
#+end_src

*** Dockerfile

#+begin_src elisp :tangle lang.example.el
;; https://github.com/spotify/dockerfile-mode
(use-package dockerfile-mode
  :straight (dockerfile-mode :type git
                             :host github
                             :repo "spotify/dockerfile-mode"))
#+end_src

*** Octave

[[https://www.gnu.org/software/emacs/manual/html_mono/octave-mode.html][Octave]] mode provides support for the [[https://www.gnu.org/software/octave/][Octave scientific programming language]] which is a popular FLOSS alternative to Matlab. From a glance at the [[https://github.com/emacs-mirror/emacs/commit/be64c05d81d6191397fa96e050b8b3ad8134b62b][Emacs git history]] it seems that this feature has been bundled in emacs for a while now, so we will simply assume it's here and add the language to the =org-babel-load-languages= list to enable Org Babel exports.

#+begin_src elisp :tangle lang.example.el
(with-eval-after-load 'org
  (message "Load Octave into Org Babel")
  (org-babel-do-load-languages 'org-babel-load-languages
                               (append org-babel-load-languages
                                       '((octave . t)))))
#+end_src

*** Nix

#+begin_src elisp :tangle lang.example.el
;; https://github.com/NixOS/nix-mode
(use-package nix-mode
  :straight (nix-mode :type git
                      :host github
                      :repo "NixOS/nix-mode")

  :custom
  (nix-nixfmt-bin "nixpkgs-fmt"))
#+end_src

**** COMMENT LSP: Use rnix-lsp

https://github.com/nix-community/rnix-lsp

#+begin_src elisp :tangle lang.example.el
(add-to-list 'eglot-server-programs '(nix-mode . ("rnix-lsp")))
#+end_src

**** TODO COMMENT Test nixpkgs-fmt

For formatting, we install Steve Purcell's nixpkgs-fmt.el:

#+begin_src elisp :tangle lang.example.el
;; https://github.com/purcell/emacs-nixpkgs-fmt
(use-package nixpkgs-fmt
  :straight (nixpkgs-fmt :type git
                         :host github
                         :repo "purcell/emacs-nixpkgs-fmt"))
#+end_src

**** WIP Org-babel support for nix shells

It is possible to define shell source blocks that can be evaluated through ob-shell but these environments don't quite seem to be Nix aware. I've explored using the [[envrc][envrc]] package but these only seem to configure a) local buffers exec paths and environment variables and b) command invocations through =shell-command-to-string= neither of which cover configuration of ob-shell invocations.

***** Generate shebang lines for nix shells

In order to use nix shells in literate programs, we need an ability to eval shell code blocks in a Nix-aware manner. The standard shell executor, copies the contents of a code block into the tmp directory and executes it there. Since nix-shells are location dependent (because the shell.nix or any other .nix file in the source directory may be required to adequately run them), we provide a means to define a shebang line for nix-shell runs.

****** PROTOTYPE nix-shell ob-shell shebang generator

Let's define a function to allow us to dynamically generate a valid shebang for shell blocks that will spawn a nix-shell to run the code in.

#+begin_src elisp :tangle personal-example.el :results none
(defun vidbina/ob-shell-nix-shebang (&optional shell-file)
  "Shebang line for a nix-shell environment based on the buffer directory"
  (let ((shell-file (or (when (stringp shell-file) shell-file) "shell.nix"))
        (nix-file (expand-file-name shell-file
                                    (file-name-directory (buffer-file-name)))))
    (format "#!/usr/bin/env nix-shell\n#!nix-shell -i bash %s" nix-file)))
#+end_src

Testing against [[file:../shell.nix]] which should roughly contain a superset of:

#+begin_src nix
# save this as shell.nix
{ pkgs ? import <nixpkgs> {}}:

pkgs.mkShell {
  nativeBuildInputs = [ pkgs.hello ];
}
#+end_src

we can define a shell block with the shebang helper in the following manner to run the code inside of a nix-shell:

#+begin_src org
,#+begin_src bash :shebang (vidbina/ob-shell-nix-shebang) :results verbatim
hello
,#+end_src
#+end_src

which can be executed as follows with the result listed thereafter:

#+begin_src bash :shebang (vidbina/ob-shell-nix-shebang "../shell.nix") :results verbatim
hello
#+end_src

#+RESULTS:
: Hello, world!

The following example should fail because the shebang helper checks that the supplied argument is a valid string that can be expanded into a path:

#+begin_src bash :shebang (vidbina/ob-shell-nix-shebang (list "a")) :results verbatim
hello
#+end_src

****** CANCELED COMMENT nix-develop ob-shell shebang generator
:LOGBOOK:
- State "CANCELED"   from "TODO"       [2022-06-01 Wed 22:54] \\
  Between =nix-shell= and =nix develop=, only =nix-shell= allows usage as a shell interpreter which is why a shebang interpreter line only works for =nix-shell=. Any attempt to achieve the same with =nix develop= is just going to fail, so I'm attempting a comint-based approach instead.
:END:

#+begin_src elisp :tangle personal-example.el :results none
(defun vidbina/ob-shell-nix-develop-shebang ()
  "Shebang line for a nix develop environment based on the buffer directory"
  (let ((nix-directory (file-name-directory (buffer-file-name))))
    (format "#!/usr/bin/env -vS nix develop --inputs-from %s" nix-directory)))
#+end_src

****** References

- https://www.reddit.com/r/NixOS/comments/r15hx4/nix_shell_vs_nix_develop/
- https://blog.ysndr.de/posts/guides/2021-12-01-nix-shells/

***** Define org-babel-execute for nix-develop

****** Background

Refer to [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-shell.html#org9ad9ef2
][Shell Code Blocks in Babel]] for details on how Org-babel executes shell blocks.

:CODESTUDY:
The =org-babel-shell-initialize= function defines specialized ob-execute handlers for every one of the supported shells in =org-babel-shell-names= (of which bash, sh and zsh are members).

#+begin_src elisp :results none
(defun org-babel-shell-initialize ()
  "Define execution functions associated to shell names.
This function has to be called whenever `org-babel-shell-names'
is modified outside the Customize interface."
  (interactive)
  (dolist (name org-babel-shell-names)
    (eval `(defun ,(intern (concat "org-babel-execute:" name))
	       (body params)
	     ,(format "Execute a block of %s commands with Babel." name)
	     (let ((shell-file-name ,name))
	       (org-babel-execute:shell body params))))
    (eval `(defalias ',(intern (concat "org-babel-variable-assignments:" name))
	     'org-babel-variable-assignments:shell
	     ,(format "Return list of %s statements assigning to the block's \
variables."
		      name)))
    (eval `(defvar ,(intern (concat "org-babel-default-header-args:" name)) '()))))
#+end_src

The generalized ob-exec (short form for Org-babel execute ü§¶üèø‚Äç‚ôÇÔ∏è) handler =org-babel-execute:shell= is the entrypoint for all shell execution tasks and is called by =org-babel-execute-src-block= which packages like [[ob-async]] retrofit (through the advice facility) to provide async execution capability.

#+begin_src elisp :results none
(defun org-babel-execute:shell (body params)
  "Execute a block of Shell commands with Babel.
This function is called by `org-babel-execute-src-block'."
  (let* ((session (org-babel-sh-initiate-session
		   (cdr (assq :session params))))
	 (stdin (let ((stdin (cdr (assq :stdin params))))
                  (when stdin (org-babel-sh-var-to-string
                               (org-babel-ref-resolve stdin)))))
	 (results-params (cdr (assq :result-params params)))
	 (value-is-exit-status
	  (or (and
	       (equal '("replace") results-params)
	       (not org-babel-shell-results-defaults-to-output))
	      (member "value" results-params)))
	 (cmdline (cdr (assq :cmdline params)))
         (full-body (concat
		     (org-babel-expand-body:generic
		      body params (org-babel-variable-assignments:shell params))
		     (when value-is-exit-status "\necho $?"))))
    (org-babel-reassemble-table
     (org-babel-sh-evaluate session full-body params stdin cmdline)
     (org-babel-pick-name
      (cdr (assq :colname-names params)) (cdr (assq :colnames params)))
     (org-babel-pick-name
      (cdr (assq :rowname-names params)) (cdr (assq :rownames params))))))
#+end_src

The results of the =org-babel-execute:shell= call is a table as indicated by the =org-babel-reassemble-table=.
:END:

Note that the =org-babel-sh-evaluate= function is the main worker we need to pay attention to. It roughly handles 4 cases:
1. when =stdin= or =cmdline= are defined \to external shell script w/ stdin
2. when =session= is defined \to session evaluation
3. if =shebang= is not empty, external shell script w/ or w/o shebang
4. otherwise, ~(org-babel-eval EXEC_FILE BODY)~

#+begin_src elisp :results verbatim
(let ((session-name "*dummy-session*")
      (body "echo hi")
      (params '())
      (stdin nil)
      (cmdline nil))
  (org-babel-sh-initiate-session session-name)
  (org-babel-sh-evaluate session-name body params stdin cmdline))
#+end_src

:CODESTUDY:
:END:

#+begin_src elisp :results output
(org-babel-eval "xargs echo" "hi")
#+end_src

#+RESULTS:

It takes a session that is initiated with "none" by default resulting to:

#+begin_src elisp :results verbatim
(org-babel-sh-initiate-session)
#+end_src

#+RESULTS:
: nil

Initiating a session with a name yields a namesake buffer:

#+begin_src elisp :results verbatim
(org-babel-sh-initiate-session "my-temporary-session")
#+end_src

#+RESULTS:
: #<buffer my-temporary-session>

Note that =params= can be set through code-block headers

#+begin_src bash :session "*my-bash-session*" :results verbatim
echo "hi"
#+end_src

#+RESULTS:
: hi

****** TODO Define nix-develop ob-execute handler

The nix-develop prompt will either default to "> " or the value of the =nixConfig.bash-prompt= attribute.

:BACKGROUND:
The =nixConfig.bash-prompt{,-{prefix,suffix}}= can be defined to specify the =PS1= variable within the /nix develop shell/ and is defined in the [[https://github.com/NixOS/nix/blob/bf89cd95a4af35ab15f7fad3186c8f6190f87c84/src/nix/develop.cc
][nix/src/nix/develop.cc]].
:END:

******* Prompt

We describe our prompt matcher through the following regexp:

#+begin_src elisp :noweb-ref nix-develop-prompt-regexp :results none
"^>\s+"
#+end_src

We verify the previously defined regexp by calling the =re-search-forward=

#+begin_src elisp :noweb yes :results none
(re-search-forward <<nix-develop-prompt-regexp>> nil t)
#+end_src

Execution of the previously listed =re-search-forward= call should move the cursor to the ">   here" line in the following block:

#+begin_quote
>no
...
$ not a valid prompt
>   here
> here too
#+end_quote

Define the previously defined regexp as the default nix-develop prompt:

#+begin_src elisp :noweb yes :noweb-ref nix-develop-mode :results none
(defcustom nix-develop-default-prompt-regexp <<nix-develop-prompt-regexp>>
  "Custom prompt for nix-develop"
  :type 'string
  :group 'nix-develop)

#+end_src

******* Execute Handler

In order to process code blocks through Org-Babel execute, we define a =org-babel-execute= handler.

#+begin_src elisp :noweb-ref nix-develop-ob-execute :results none
(defun org-babel-execute:nix-develop (body params)
  "Execute a block of nix develop commands with Babel."
  (save-window-excursion
    (let* ((shell-buffer (org-babel-sh-initiate-session "*nix-develop*"))
           (prompt-regexp nix-develop-default-prompt-regexp))
      (org-babel-comint-with-output
          (shell-buffer org-babel-sh-eoe-output t body)
        (dolist (line (append (list "nix develop")
                              (split-string (org-trim body) "\n")
                              (list org-babel-sh-eoe-indicator)))
          (insert line)
          (comint-send-input nil t)
          (while (save-excursion
                   (goto-char comint-last-input-end)
                   (not (re-search-forward
                         prompt-regexp nil t)))
            (accept-process-output
             (get-buffer-process (current-buffer)))))))))
#+end_src

****** TODO Define syntax major mode for highlighting

We define sparse keymap:

#+begin_src elisp :noweb-ref nix-develop-mode :results none
(defvar nix-develop-mode-map
  (let ((map (make-sparse-keymap)))
    map))

#+end_src

Define a syntax table that is inherits from =shell-mode= since we're expecting code blocks to only contain shell-like syntax:

#+begin_src elisp :noweb-ref nix-develop-mode :results none
(defvar nix-develop-mode-syntax-table
  (make-syntax-table shell-mode-syntax-table))

#+end_src

Derive a major mode from comint-mode because we want to do the interactive thing:

#+begin_src elisp :noweb-ref nix-develop-mode :results none
(define-derived-mode nix-develop-mode comint-mode "Nix Develop"
  "Major mode for `nix-develop'"
  (setq comint-prompt-regexp nix-develop-default-prompt-regexp))

#+end_src

******* Example: Code blocks of different major-modes

#+begin_src shell :results verbatim
echo "hi"
for i in a b; do testing; done
#+end_src

#+begin_src sh :results verbatim
echo "hi"
for i in a b; do testing; done
#+end_src

#+begin_src nix-develop :results verbatim
echo "hi"
for i in a b; do testing; done
#+end_src

****** Compose nix-develop-mode and ob-execute handler

#+begin_src elisp :noweb yes :tangle lang.example.el :results none
<<nix-develop-mode>>
<<nix-develop-ob-execute>>

(provide 'nix-develop-mode)
#+end_src

***** TODO Prep Reddit question

#+begin_src markdown
I've noticed that calling `define-derived-mode` multiple times and then refreshing syntax highlighing on a code block (by reentering the syntax descriptor) to another buffer to test that mode in a code block doesn't seem to reflect the changes made in the `define-derived-mode` call.

As an example let's define a dummy mode blah and use it in a code block as follows:

```
,#+begin_src blah :results verbatim
echo "hi"
,#+end_src
```

A. Deriving a mode from shell-mode

```
(define-derived-mode blah-mode
  sh-mode "Nix Develop"
  "Major mode for `nix-develop`")
```

B. Deriving a mode from sh-mode

```
(define-derived-mode blah-mode
  emacs-lisp-mode "Nix Develop"
  "Major mode for `nix-develop`")
```

Running A and then opening/reloading the buffer (through `revert-buffer-quick`) and then running B and reloading the buffer again doesn't seem to render different results in the buffer.

When we reload Emacs and run B, the rendering in the source block seems quite different.

```
,#+begin_src blah :results verbatim
echo "hi"
,#+end_src
```
#+end_src

#+begin_src markdown
I am aware that I can define a nix-shell shebang as follows

```shell
#!/usr/bin/env nix-shell
#!nix-shell -i bash /PATH/TO/shell.nix
```

but I am trying to figure out how to spawn a nix shell interpreter in a Flake-based configuration where I may have to use nix-develop
#+end_src

*** Web

#+begin_src elisp :tangle lang.example.el
;; https://github.com/fxbois/web-mode
(use-package web-mode
  :straight (web-mode :type git
                      :host github
                      :repo "fxbois/web-mode"))
#+end_src

**** Vue

#+begin_src elisp :tangle lang.example.el
;; https://github.com/fxbois/web-mode
(use-package web-mode
  :straight (web-mode :type git
                      :host github
                      :repo "fxbois/web-mode"))
#+end_src

** General Purpose Programming Languages

*** Go (Golang)

#+begin_src elisp :tangle lang.example.el
;; https://github.com/dominikh/go-mode.el
(use-package go-mode
  :straight (go-mode :type git
                     :host github
                     :repo "dominikh/go-mode.el"))
#+end_src

*** JavaScript (ECMAScript or ES)

Since JavaScript is everywhere, let's make sure we can at least read it with ease.

#+begin_src elisp :tangle lang.example.el
;; https://github.com/redguardtoo/js-comint
(use-package js-comint
  :straight (js-comint :type git
                       :host github
                       :repo "redguardtoo/js-comint")
  :hook (inferior-js-mode . (lambda ()
                              (add-hook 'comint-output-filter-functions 'js-comint-process-output)))
  :config
  (define-key js-mode-map [remap eval-last-sexp] #'js-comint-send-last-sexp)
  (define-key js-mode-map (kbd "C-c b") 'js-send-buffer)
  :custom
  (js-indent-level 2))
#+end_src

**** TypeScript

Superset of JavaScript that folks really should be using instead of just vanilla JS but we're not here to judge. ü§∑üèø‚Äç‚ôÇÔ∏è

#+begin_src elisp :tangle lang.example.el
;; https://github.com/emacs-typescript/typescript.el
(use-package typescript-mode
  :straight
  (typescript-mode :type git
                   :host github
                   :repo "emacs-typescript/typescript.el")
  :delight
  (typescript-mode "ts")
  :custom
  (typescript-indent-level 2))
#+end_src

***** Tide

#+begin_src elisp :noweb yes :tangle lang.example.el
;; https://github.com/ananthakumaran/tide
(use-package tide
  :straight
  (tide :type git
        :host github
        :repo "ananthakumaran/tide")
  <<tide-tsx-config>>
  :init
  (evil-collection-tide-setup)
  :delight
  (tide-mode "üåä")
  :after (typescript-mode evil-collection)
  :hook ((typescript-mode . tide-setup)
         (typescript-mode . tide-hl-identifier-mode))
  :custom
  (tide-always-show-documentation nil "Don't show docs if only type info is available to minimize disruption"))
#+end_src

- =g d= *go* to *definition*
- =g j= find next error or reference
- =g k= find prev error or reference
- =K= to show docs

****** COMMENT Config

#+begin_comment
‚ö†Ô∏è Commenting out this block because web-mode fucks up tide-mode to the points that I can't really use tide-mode. I'm better off enabling tide-mode when I need it.
#+end_comment

#+begin_src elisp :noweb-ref tide-tsx-config
:config
#+end_src

******* TSX

#+begin_src elisp :noweb-ref tide-tsx-config
;; https://github.com/ananthakumaran/tide#tsx
(require 'web-mode)
(add-to-list 'auto-mode-alist '("\\.tsx\\'" . web-mode))
(add-hook 'web-mode-hook
          (lambda ()
            (when (string-equal "tsx" (file-name-extension buffer-file-name))
              (setup-tide-mode))))
;; enable typescript-tslint checker
(flycheck-add-mode 'typescript-tslint 'web-mode)
#+end_src

******* JSX

#+begin_src elisp :noweb-ref tide-tsx-config
;; https://github.com/ananthakumaran/tide#jsx
(add-to-list 'auto-mode-alist '("\\.jsx\\'" . web-mode))
(add-hook 'web-mode-hook
          (lambda ()
            (when (string-equal "jsx" (file-name-extension buffer-file-name))
              (setup-tide-mode))))
;; configure jsx-tide checker to run after your default jsx checker
(flycheck-add-mode 'javascript-eslint 'web-mode)
(flycheck-add-next-checker 'javascript-eslint 'jsx-tide 'append)
#+end_src

***** TODO COMMENT Look into tsx-mode.el

#+begin_src elisp :tangle lang.example.el
;; https://github.com/orzechowskid/tsx-mode.el
(use-package tsx-mode
  :straight
  (tsx-mode :type git
            :host github
            :repo "orzechowskid/tsx-mode.el"))
#+end_src

*** Java

#+begin_src elisp :tangle lang.example.el
;; https://emacs-lsp.github.io/lsp-java/
(use-package lsp-java
  :straight (lsp-java :type git
                      :host github
                      :repo "emacs-lsp/lsp-java"))
#+end_src

*** Clojure

#+begin_src elisp :noweb yes :tangle lang.example.el
;; https://github.com/clojure-emacs/clojure-mode
(use-package clojure-mode
  :straight (clojure-mode :type git
                          :host github
                          :repo "clojure-emacs/clojure-mode")
  :config
  <<clojure-config>>)
#+end_src

The =ob-clojure= package provides Org-Babel support for Clojure code blocks.

#+begin_src elisp :noweb-ref clojure-config
(require 'ob-clojure)
#+end_src

Refer to the [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-clojure.html][Org-babel-clojure documentation]] for instructions on how to install your environment to use Clojure with Emacs.

**** CIDER

#+begin_src elisp :tangle lang.example.el
;; https://github.com/clojure-emacs/cider
(use-package cider
  :straight (cider :type git
                   :host github
                   :repo "clojure-emacs/cider")
  :config
  (setq org-babel-clojure-backend 'cider
        cider-lein-parameters "with-profile -user repl :headless :host localhost"))
#+end_src

*** Kotlin

#+begin_src elisp :tangle lang.example.el
;; https://github.com/Emacs-Kotlin-Mode-Maintainers/kotlin-mode
(use-package kotlin-mode
  :straight (kotlin-mode :type git
                         :host github
                         :repo "Emacs-Kotlin-Mode-Maintainers/kotlin-mode"))
#+end_src

*** Swift

#+begin_src elisp :tangle lang.example.el
;; https://github.com/swift-emacs/swift-mode
(use-package swift-mode
  :straight (swift-mode :type git
                        :host github
                        :repo "swift-emacs/swift-mode"))
#+end_src

*** Haskell

In order to conveniently read and write Haskell, I rely on [[https://github.com/haskell/haskell-mode][haskell-mode]]. Note that [[https://gitlab.com/tseenshe/haskell-tng.el][haskell-tng]] is a fork from haskell-mode that may be worth looking into in your case. read the [[http://haskell.github.io/haskell-mode/manual/latest/][manual]] for more information.

In order to configure interactive mode, we follow the [[https://haskell.github.io/haskell-mode/manual/latest/Interactive-Haskell.html#Customizations][setup instructions from the manual]].

#+begin_src elisp :tangle lang.example.el
;; https://github.com/haskell/haskell-mode
(use-package haskell-mode
  :straight (haskell-mode :type git
                          :host github
                          :repo "haskell/haskell-mode")
  :config
  (require 'haskell-interactive-mode)
  (require 'haskell-process)
  :hook ((haskell-mode . haskell-unicode-input-method-enable)
         (haskell-mode . interactive-haskell-mode))
  :custom
  (haskell-process-suggest-remove-import-lines t)
  (haskell-process-auto-import-loaded-modules t)
  (haskell-process-log t)
  (haskell-stylish-on-save t))
#+end_src

Please note that [[https://wiki.haskell.org/GHC/GHCi][GHCi]], [[https://github.com/ndmitchell/hlint][HLint]] and [[https://github.com/haskell/stylish-haskell][stylish-haskell]] are needed for this configuration to work.

**** Haskell Environment Configuration in Nix

For convenience, I use direnv to manage my environments. Considering that I am a Nix user and the configuration described above needs GHCi, Hlint and stylish-haskell installed, I just have to see to it that a project directory tree contains an .envrc file that contains the =use nix= string to relegate env configuration to the nix configuration and then populate default.nix to contain description of the needed environment.

So, =.envrc= should contain the following:

#+begin_src conf
use nix
#+end_src

and my =default.nix= file will contain something to the tune of the snippet below.

#+begin_src nix
{ sources ? import ./nix/sources.nix }:

let
  nixpkgs = import sources.nixpkgs {};
in
nixpkgs.mkShell {
  buildInputs = with nixpkgs.haskellPackages; [
    ghci
    hlint
    stylish-haskell
  ];
}
#+end_src

To add another layer of convenience or complexity, depending on how you want to look at it ü§∑üèø‚Äç‚ôÇÔ∏è, I manage my nix packages with [[https://github.com/nmattia/niv][niv]] in order to decouple the project packages from my system configuration (i.e.: every project installs packages in reference to a pinned package repository that remains the same even if the system repository changes over time which improves reproducability). This is where the =./nix/sources.nix= bit comes into the picture -- that's a niv thing. In order to populate the =nix/sources.nix= and =nix/sources.json= files that nix needs, I have to run =niv init= inside of the directory where the default.nix resides. After all of this is done, we have to allow direnv to evaluate the files within the directory to autoload our environment. I sometimes do this within emacs with ~(envrc-allow)~ but you can also do this from a terminal with the command =direnv allow=.

*** Elm

#+begin_src elisp :tangle lang.example.el
;; https://github.com/jcollard/elm-mode
(use-package elm-mode
  :straight (elm-mode :type git
                      :host github
                      :repo "jcollard/elm-mode"))
#+end_src

*** Rust

#+begin_src elisp :tangle lang.example.el
;; https://github.com/rust-lang/rust-mode
(use-package rust-mode
  :straight (rust-mode :type git
                       :host github
                       :repo "rust-lang/rust-mode"))
#+end_src

** Misc

Misc bells and whistles from formatting aids to LLM-enabled magic.

*** EditorConfig

#+begin_src elisp :tangle lang.example.el
;; https://github.com/editorconfig/editorconfig-emacs#readme
(use-package editorconfig
  :straight (editorconfig :type git
                          :host github
                          :repo "editorconfig/editorconfig-emacs")
  :config
  (editorconfig-mode 1)
  :delight
  (editorconfig-mode "üéõÔ∏è"))
#+end_src

**** TODO Debug editorconfig conflict

See https://github.com/editorconfig/editorconfig-emacs/issues/264 regarding =indent_size= being ignored editorconfig is being ignored.

*** üåà Rainbow Delimiters

#+begin_src elisp :tangle lang.example.el
;; https://github.com/Fanael/rainbow-delimiters
(use-package rainbow-delimiters
  :straight (rainbow-delimiters :type git
                                :host github
                                :repo "Fanael/rainbow-delimiters")
  :hook ((emacs-lisp-mode . rainbow-delimiters-mode)
         (prog-mode . rainbow-delimiters-mode))

  ;; ;; https://github.com/patrickt/emacs
  ;; ((prog-mode) . rainbow-delimiters-mode)
  )
#+end_src

*** COMMENT tree-sitter

#+begin_quote
‚ö†Ô∏è Commented in order to test the [[https://lists.gnu.org/archive/html/emacs-devel/2022-11/msg01443.html][built-in/integrated tree-sitter in Emacs 29+]] as per the recommendation on the [[https://github.com/emacs-tree-sitter/elisp-tree-sitter][elisp-tree-sitter README]].
#+end_quote

Based on the [[https://vxlabs.com/2022/06/12/typescript-development-with-emacs-tree-sitter-and-lsp-in-2022/][TypeScript development with Emacs, tree-sitter and LSP in 2022]] article by vxlabs.

#+begin_src elisp :tangle lang.example.el
;; https://github.com/emacs-tree-sitter/elisp-tree-sitter
(use-package tree-sitter
  :straight (tree-sitter :type git
                         :host github
                         :repo "emacs-tree-sitter/elisp-tree-sitter")
  :config
  ;; activate tree-sitter on any buffer containing code for which it has a parser available
  (global-tree-sitter-mode)
  ;; you can easily see the difference tree-sitter-hl-mode makes for python, ts or tsx
  ;; by switching on and off
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)
  :delight
  (tree-sitter-mode "üå≤"))

;; https://github.com/emacs-tree-sitter/tree-sitter-langs
(use-package tree-sitter-langs
  :straight (tree-sitter-langs :type git
                               :host github
                               :repo "emacs-tree-sitter/tree-sitter-langs")
  :after tree-sitter)
#+end_src

*** <<highlight-indent-guides>> Highlight Indent Guides

#+begin_src elisp :tangle lang.example.el
;; https://github.com/DarthFennec/highlight-indent-guides
(use-package highlight-indent-guides
  :straight (highlight-indent-guides :type git
                                     :host github
                                     :repo "DarthFennec/highlight-indent-guides")
  :custom
  (highlight-indent-guides-method 'column))
#+end_src

*** <<paredit>> Paredit

In order to simplify editing LISPs, [[https://github.com/emacsmirror/paredit][paredit]] can be used to assist in keeping forms balanced (i.e.: ensuring that a form always has as many opening as closing parenthesis).

#+begin_src elisp :noweb yes :tangle lang.example.el
;; https://github.com/emacsmirror/paredit
(use-package paredit
  :straight (paredit :type git
                     :host github
                     :repo "emacsmirror/paredit")
  <<paredit-config>>)
#+end_src

**** Set lighter

#+begin_src elisp :noweb-ref paredit-config
:delight
(paredit-mode "üõù")
#+end_src

**** Set global binding

Enable paredit mode using the =C-c v (= binding.

#+begin_src elisp :noweb-ref paredit-config
:bind (("C-c v (" . paredit-mode))
#+end_src

**** Usage

Once paredit mode is enabled, we can do the following:
- =C-right= slurp
  - src_elisp[:exports code]{(a (here) b)} \to  src_elisp[:exports code]{(a (here b))}
- =C-left= barf
  - src_elisp[:exports code]{(a (here b))} \to  src_elisp[:exports code]{(a (here) b)}
- =M-S= split sexp
  - with point before =b=, src_elisp[:exports code]{(a b)} \to  src_elisp[:exports code]{(a) (b)}
- =C-M-b= / =C-M-f= move backward/forward
- =C-M-u= / =C-M-n= move backward/forward out of enclosing list

You can enter a special edit mode by placing point on the codeblock below and entering =C-c '=.

#+begin_src elisp
'(a (here) b)

(progn
  (message "hi")
  (+ 40 2) :42)

(progn
  (let ((a 4))
    '(a (b c) d)
    (+ (* 12 3)
       (1+ 12))))


(+ 1 (* 2 3) 4)
#+end_src

*** <<inheritenv>> inheritenv

The [[https://github.com/purcell/inheritenv][inheritenv]] package configures background processes to adopt the =process environment= and =exec-path= of the calling Emacs buffer. This package is used by [[envrc][envrc]] which means that we don't really have to do anything if we configure the envrc to run the show for us.

#+begin_src elisp :tangle lang.example.el
;; https://github.com/purcell/inheritenv
(use-package inheritenv
  :straight (inheritenv :type git
                        :host github
                        :repo "purcell/inheritenv"))
#+end_src

*** <<envrc>> envrc

By using the [[https://github.com/purcell/envrc][envrc]] package, buffer-local variables can be managed through the configuration of the [[https://direnv.net/][direnv]] .envrc file.

#+begin_src elisp :tangle lang.example.el
;; https://github.com/purcell/envrc
(use-package envrc
  :straight (envrc :type git
                   :host github
                   :repo "purcell/envrc")
  :after inheritenv
  :delight
  (envrc-mode "üì¶")
  :hook (after-init . envrc-global-mode)
  :bind-keymap ("C-c e" . envrc-command-map))
#+end_src

We bind =C-c e= to envrc to simplify access to mode toggles and reloading facilities.

The use of this package, will arm =shell-command-to-string= to call [[inheritenv][inheritenv]] through the =envrc-propagate-environment= call.

**** TODO Configure exec path

When using changes to the path may go unnoticed to Emacs which results to shell blocks in Org files not having the proper path configurations and therefore not being able to find the right executables.

#+begin_src elisp :tangle lang.example.el
;; https://github.com/purcell/exec-path-from-shell
(use-package exec-path-from-shell
  :straight (exec-path-from-shell :type git
                                  :host github
                                  :repo "purcell/exec-path-from-shell")
  :config (when (daemonp)
            (exec-path-from-shell-initialize)))
#+end_src

https://emacs.stackexchange.com/questions/53773/best-way-to-make-org-babel-blocks-aware-of-my-path-and-other-environment-variab

**** Example Usage

As a Nix ‚ùÑÔ∏è user, there are a few [[https://github.com/direnv/direnv/wiki/Nix][options]] available for managing direnv environments of which [[https://github.com/nix-community/nix-direnv][nix-direnv]] happened to be an easier and faster option. As an example, observe the following shell.nix:

#+begin_src nix :tangle playground/nix-direnv/shell.nix
# save this as shell.nix
{ pkgs ? import <nixpkgs> {}}:

pkgs.mkShell {
  nativeBuildInputs = [ pkgs.hello ];
}
#+end_src

along with the following *.envrc*

#+begin_src bash :tangle playground/nix-direnv/.envrc
use nix
#+end_src

which defines an environment that is configured upon directory entry.

Dropping into an appropriate shell through Projectile shell ~(projectile-run-shell)~ (or similar) commands should result to a pre-configured environment.

#+begin_center
Update the following snippet by tangling it and trying out the code blocks by opening the resulting buffer [[file:playground/nix-direnv/README.org]] and then copying the results back into the Org block. A bit tedious, but the safer way to test this since =org-edit-special= buffers are not file buffers and thus any ~(buffer-file-name)~ calls will come up empty.
#+end_center

#+begin_src org :tangle playground/nix-direnv/README.org
,#+title: Experimenting with envrc binary access

Just trying to get a handle of what we can reach from Emacs Org-Babel when utilizing envrc to manage environments.

,* Calling envrc binaries through =shell-command-to-string=

[[https://github.com/purcell/inheritenv#make-emacs-temp-buffers-inherit-buffer-local-environment-variables][Thanks to inheritenv]], the =shell-command-to-string= function can be used to run commands within the envrc environment.

,** With envrc-global-mode disabled

Without envrc enabled, the hello binary is not accessible.

,#+begin_src elisp
(envrc-mode -1)
(shell-command-to-string "hello")
,#+end_src

,#+RESULTS:
: zsh:1: command not found: hello

,** With envrc-global-mode enabled

With envrc enabled, the hello binary is found and successfully executed.

,#+begin_src elisp
(envrc-mode 1)
(shell-command-to-string "hello")
,#+end_src

,#+RESULTS:
: Hello, world!

,* Calling envrc binaries through a shell block

Regardless of the envrc enabled state, calling of envrc managed binaries seems to be a problem directly from bash blocks. The following block will therefore error out with a "bash: line 1: hello: command not found".

,#+begin_src org
,,#+begin_src bash :results none
hello
,,#+end_src
,#+end_src

,#+begin_src bash :results none
hello
,#+end_src

,#+begin_center
‚ö†Ô∏è Surely I must have overlooked the idiomatic way to configure Emacs to run ob-shell inside of nix shells so please shoot me a note if you know what I'm missing here. ü§∑üèø‚Äç‚ôÇÔ∏è
,#+end_center

By defining a shebang header argument, we can inform Emacs how to run the code in a shell block but a simple shebang may not suffice as is evident by the "error: getting status of '/tmp/babel-K6A1O8/shell.nix': No such file or directory" error that is being throw when I run the following:

,#+begin_src org
,,#+begin_src bash :shebang "#!/usr/bin/env nix-shell" :results none
hello
,,#+end_src
,#+end_src

,#+begin_src bash :shebang "#!/usr/bin/env nix-shell" :results none
hello
,#+end_src

The ob-shell implementation copies the contents of a code block into a temporary directory, which breaks a nix-shell setup since the copy operation does not copy along the .nix files. I considered, figuring out how to copy shell.nix over and then realized that shell.nix may import other files which opens a can of worms of which context to copy over to guarantee that the setup will work reliably. The safer way to go is to create a dynamic shebang that refers back to a shell.nix in the source directory and not the temporary directory.

,#+begin_src elisp
(defun vidbina/ob-shell-nix-shebang ()
  "Shebang line for a nix-shell environment based on the buffer directory"
  (let ((nix-directory (expand-file-name "shell.nix" (file-name-directory (buffer-file-name)))))
    (format "#!/usr/bin/env nix-shell\n#!nix-shell -i bash %s" nix-directory)))
,#+end_src

Note that we assume that there is a shell.nix in the buffer directory. This will break if we define our shell under a different filename but I felt that assuming that a shell.nix existed was safer bet than assuming that I would know how many nix files (in whichever directory structure) to copy over to a temporary directory. ü§∑üèø‚Äç‚ôÇÔ∏è

,#+begin_src org
,,#+begin_src bash :shebang (vidbina/ob-shell-nix-shebang) :results verbatim
hello
,,#+end_src
,#+end_src

,#+begin_src bash :shebang (vidbina/ob-shell-nix-shebang) :results verbatim
hello
,#+end_src

,#+RESULTS:
: Hello, world!
#+end_src

*** AIDE

In order to use OpenAI's GPT models directly inside of Emacs, we are using the AIDE package.

#+begin_src elisp :tangle lang.example.el
;; https://github.com/junjizhi/aide.el
(use-package aide
  :straight (aide :type git
                  :host github
                  :repo "vidbina/aide.el"
                  :branch "vidbina/retrieve-secret-through-function")
  :custom
  (aide-completions-model "text-davinci-003")
  (aide-openai-api-key-getter (lambda ()
                                (auth-source-pass-get 'secret "openai.com/david@asabina.de/api-key-2022.02.18"))))
#+end_src

A newer version of the =aide-openai-complete= that uses a more general path but specified the model in the JSON payload is:

#+begin_src elisp
(defun aide-openai-complete (api-key prompt)
  "Return the prompt answer from OpenAI API.
API-KEY is the OpenAI API key.

PROMPT is the prompt string we send to the API."
  (let ((result nil)
        (auth-value (format "Bearer %s" api-key)))
    (request
      "https://api.openai.com/v1/completions"
      :type "POST"
      :data (json-encode `(("prompt" . ,prompt)
                           ("model" . ,aide-completions-model)
                           ("max_tokens" . ,aide-max-tokens)
                           ("temperature" . ,aide-temperature)
                           ("frequency_penalty" . ,aide-frequency-penalty)
                           ("presence_penalty" . ,aide-presence-penalty)
                           ("top_p" . ,aide-top-p)))
      :headers `(("Authorization" . ,auth-value) ("Content-Type" . "application/json"))
      :sync t
      :parser 'json-read
      :success (cl-function
                (lambda (&key data &allow-other-keys)
                  (setq result (alist-get 'text (elt (alist-get 'choices data) 0))))))
    result))
#+end_src

#+begin_src elisp
(aide-openai-complete (funcall aide-openai-api-key-getter) "Define an agenda for a meeting")
#+end_src

*** COMMENT WIP gpt-elisp

Just trying out [[https://github.com/beguene/emacs-gpt][emacs-gpt]] for the lols.

#+begin_src elisp :tangle lang.example.el
(use-package gpt-elisp
  :straight (gpt-elisp :local-repo "~/src/beguene/emacs-gpt")
  :custom
  (gpt-elisp-edit-api-key-getter (lambda ()
                                   (auth-source-pass-get 'secret "openai.com/david@asabina.de/api-key-2022.02.18"))))
#+end_src

** LSP

*** TODO Eglot

#+begin_src elisp :tangle lang.example.el
;; https://github.com/joaotavora/eglot
(use-package eglot
  :straight (eglot :type git
                   :host github
                   :repo "joaotavora/eglot")
  :bind (:map eglot-mode-map ("C-h j" . xref-find-definition)))
#+end_src

*** COMMENT Emacs LSP

**** LSP-mode

#+begin_src elisp :tangle lang.example.el
;; https://emacs-lsp.github.io/lsp-mode/page/installation/#vanilla-emacs
(use-package lsp-mode
  :straight (lsp-mode :type git
                      :host github
                      :repo "emacs-lsp/lsp-mode")
  :bind (:map lsp-mode-map ("TAB" . completion-at-point))
  :init
  (setq-default read-process-output-max (* 1024 1024))
  (setq  gc-cons-threshold (* 100 1024 1024))
  ;;(setq lsp-keymap-prefix "C-c C-M-l")
  ;;(setq lsp-log-io t) ;; ‚ö†Ô∏è turn off for performance
  :hook ((java-mode . lsp)
         (go-mode . lsp))
  :commands
  (lsp lsp-deferred)
  ;;:config
  ;;(define-key lsp-mode-map (kbd "C-c C-M-l") lsp-command-map)
  ;;(lsp-enable-which-key-integration t)
  )
#+end_src

**** LSP-ui

#+begin_src elisp :tangle lang.example.el
;; https://emacs-lsp.github.io/lsp-mode/page/installation/#use-package
;; https://config.daviwil.com/emacs
;; https://github.com/emacs-lsp/lsp-ui
(use-package lsp-ui
  :straight t
  :hook (lsp-mode . lsp-ui-mode)
  :config
  (setq lsp-ui-sideline-enable t
        lsp-ui-sideline-show-hover nil
        lsp-ui-doc-position 'bottom)
  (lsp-ui-doc-show))
#+end_src

**** Ivy Integration

The Ivy completion framework can be used in combination with Emacs LSP through the native [[https://github.com/emacs-lsp/lsp-ivy][lsp-ivy integration]].

#+begin_src elisp :tangle lang.example.el
;; https://github.com/emacs-lsp/lsp-ivy
(use-package lsp-ivy
  :straight t
  :hook (lsp-mode . lsp-ivy-mode))
#+end_src

**** Treemacs Integration

The Treemacs tree layout explorer can be used in combination with Emacs LSP through the [[https://github.com/emacs-lsp/lsp-treemacs][lsp-treemacs integration]].

#+begin_src elisp :tangle lang.example.el
;; https://github.com/emacs-lsp/lsp-treemacs
(use-package lsp-treemacs
  :straight t
  :commands lsp-treemacs-errors-list
  :after lsp-mode)
#+end_src

**** Docker Integration

In order to use LSP with projects where the language servers runs inside Docker containers, one can use the [[https://github.com/emacs-lsp/lsp-docker][lsp-docker integration]].

#+begin_src elisp :tangle lang.example.el
;; https://github.com/emacs-lsp/lsp-docker
(setq lsp-docker-client-configs
      '((:server-id bash-ls :docker-server-id bashls-docker :server-command "bash-language-server start")
        (:server-id clangd :docker-server-id clangd-docker :server-command "clangd")
        (:server-id css-ls :docker-server-id cssls-docker :server-command "css-languageserver --stdio")
        (:server-id dockerfile-ls :docker-server-id dockerfilels-docker :server-command "docker-langserver --stdio")
        (:server-id gopls :docker-server-id gopls-docker :server-command "gopls")
        (:server-id html-ls :docker-server-id htmls-docker :server-command "html-languageserver --stdio")
        (:server-id pyls :docker-server-id pyls-docker :server-command "pyls")
        (:server-id ts-ls :docker-server-id tsls-docker :server-command "typescript-language-server --stdio")))
#+end_src

#+begin_src elisp :tangle lang.example.el
;; https://github.com/emacs-lsp/lsp-docker
(use-package lsp-docker
  :straight (lsp-docker :type git
                        :host github
                        :repo "emacs-lsp/lsp-docker")
  :after lsp-mode
  ;;:init
  ;;(setq lsp-docker-client-packages '()
  ;;      lsp-docker-client-configs '())
  :config
  (lsp-docker-init-clients :path-mappings '(("/home/vidbina/src" . "/projects"))
                           ;;:docker-image-id "vidbina/lsp-docker-langservers:latest"
                           :client-packages lsp-docker-default-client-packages
                           :client-configs lsp-docker-default-client-configs
                           ;;:client-configs '((:server-id 'clangd
                           ;;                              :docker-server-id 'examplels-docker
                           ;;                              :docker-image-id "vidbina/lsp-docker-langservers:latest"
                           ;;                              :docker-container-name "vidbina-lsp-clangd"
                           ;;                              :server-command "ccls"
                           ))
#+end_src

***** TODO Language-specific configuration

Refactor the =lsp-docker-client-configs= such that the LSP config for every language is defined within the language's chapter within this config.

* Developer Notes

** Tangle Helper

The =my-dotfiles-tangle-wrapper= helper allows us to spawn an Emacs session with our freshly tangled configuration in order to spot early errors.

#+CAPTION: Screenshot of the a blank Emacs session automatically started by the tangle helper.
[[file:images/screenshot-tangle-helper-full.png]]

#+begin_src elisp :results none
(defun my-dotfiles-tangle-wrapper (orig-fun &rest args)
  (message "Wrapping %S with %S" orig-fun args)
  (let ((res (apply orig-fun args))
        (command "emacs")
        (args (list "-q"
                    "--load=init.el"
                    "--debug-init"
                    "--name=Emacs Test"
                    (format "--file=%s" buffer-file-name))))
    (apply #'start-process `("emacs-for-org-cite-export" nil ,command ,@args))
    (message "Done and got %S" res)
    res))
#+end_src

*** Enable

Enable the tangle helper by running the following snippet with ~(org-ctrl-c-ctrl-c)~ mapped by default to =C-c C-c=.

#+begin_src elisp :results none
(advice-add 'org-babel-tangle :around #'my-dotfiles-tangle-wrapper)
#+end_src

*** Disable

Disable the tangle helper by running the following snippet with ~(org-ctrl-c-ctrl-c)~ mapped by default to =C-c C-c=.

#+begin_src elisp :results none
(advice-remove 'org-babel-tangle #'my-dotfiles-tangle-wrapper)
#+end_src

* <<nix-config>> Nix ‚ùÑÔ∏è Home-manager Configuration

[[https://github.com/nix-community/home-manager][Home-manager]] allows management of a user environment through Nix -- the package-manager and language.

** General

We use Nix (the language) to define our Emacs builds for GNU/Linux and Darwin (macOS) systems. For both systems, we need to specify the inputs (sources), setup the emacs configuration directory and build and install Emacs.

*** Nix Sources

The Nix configuration will be importing the sources managed through [[https://github.com/nmattia/niv][niv]] and captured in the [[file:../nix/sources.nix]] file.

#+begin_src nix :noweb-ref nix-let-bindings
sources = import ../nix/sources.nix;
#+end_src

#+begin_center
üí° I don't manage my home-configuration through [[https://nix-community.github.io/home-manager/index.html#ch-nix-flakes][Nix Flakes]] because parts of my home-manager  configuration depends on files that I can't track in Git for privacy reasons. Nix Flakes doesn't play ball well when files are in play that aren't tracked, so I opted out of Flake-based usage and opted for managing versions with niv.
#+end_center

*** Setup Emacs configuration directory

We instruct home-manager to symlink the current directory into the [[file:~/.emacs.d]] destination.

#+begin_src nix :noweb-ref nix-home-emacsdir-source
home.file.".emacs.d".source = config.lib.file.mkOutOfStoreSymlink ./.;
#+end_src

*** <<nix-overlays-source>> Overlays

The [[https://github.com/nix-community/emacs-overlay][emacs-overlay]] project is used to build the bundles of Emacs that we want on our systems.

#+begin_src nix :noweb-ref nix-let-bindings
emacs-overlay-src = sources."emacs-overlay";
#+end_src

Refer to the definitions for the [[nix-overlays-linux][Linux]] and [[nix-overlays-darwin][Darwin (macOS)]] overlays to understand what we're bundling into our Emacs builds.

*** Install Emacs

Home-manager enables the installation of Emacs through the =programs= facility. For the different systems that we use, we will define custom packages through [[nix-overlays-source][overlays]].

#+begin_src nix :noweb-ref nix-home-programs
programs.emacs = {
  enable = true;
  package = pkgs.my-emacs;
};
#+end_src

**** Helpers

#+begin_src nix :noweb-ref nix-let-bindings
baseCommand = windowName:
  builtins.concatStringsSep " " [
    "emacsclient -a emacs"
    ''-F "((name . \\\"${windowName}\\\"))"''
    "-c"
  ];
#+end_src

** <<nix-config-linux>> üêß GNU/Linux

On GNU/Linux, home-manager allows for the installation of the Linux packages, configuration of systemd services, configuration of overlays and registration of XDG mimeApps entries in order to produce a "working environment". The complete GNU/Linux configuration looks as follows but is explained in the following subsections:

#+begin_src nix :noweb yes :tangle default.nix
# Tangled from README.org
{ config, pkgs, lib, options, ... }:

let
  <<nix-let-bindings>>
in
{
  <<nix-home-emacsdir-source>>

  home.packages = with pkgs; [
    cask

    <<nix-linux-packages>>
  ];

  <<nix-home-programs>>

  <<nix-linux-services>>

  <<nix-linux-overlays>>

  <<nix-linux-mime>>
}
#+end_src

*** <<nix-overlays-linux>> Overlays

Using [[https://github.com/nix-community/emacs-overlay][emacs-overlay]], we define an Emacs build that bundles packages that are difficult to install just with straight on account of non-elisp dependencies such as system dependencies that may require special privileges of a specialized build process.

#+begin_src nix :noweb yes :noweb-ref nix-linux-overlays
nixpkgs.overlays = [
  (import emacs-overlay-src)

  (self: super:
    let
      <<nix-linux-overlay-defs>>
    in
    {
      my-emacs = (pkgs.buildEnv {
        name = "my-emacs";
        paths = [
          <<nix-linux-overlay-emacs-paths>>
        ];
      });
    })
];
#+end_src

**** emacs

We bundle emacs through a bunch of helpers that set whatever flags we need set and also take case of factoring our wanted package repositories into the mix.

#+begin_src nix :noweb yes :noweb-ref nix-linux-overlay-defs
emacs = (pkgs.emacsGit.override {
  nativeComp = true;
  withSQLite3 = true;
  withGTK2 = false;
  withGTK3 = false;
});
bundled-emacs = emacs.pkgs.withPackages (epkgs: (
  with epkgs; [
    notmuch
    vterm
    pdf-tools
  ]
));
#+end_src

We define the paths for our custom emacs build seperately below:

#+begin_src nix :noweb yes :noweb-ref nix-linux-overlay-emacs-paths
bundled-emacs
pkgs.clang
pkgs.cmake
pkgs.coreutils
pkgs.fd
pkgs.multimarkdown
#+end_src

***** ripgrep

We build ripgrep for Doom Emacs. I haven't even used Doom Emacs for a long time but the setting is still here and perhaps I can rely on this again for a faster grepping experience:

#+begin_src nix :noweb yes :noweb-ref nix-linux-overlay-defs
ripgrep-for-doom-emacs = (pkgs.ripgrep.override {
  withPCRE2 = true;
});
#+end_src

We also add the custom ripgrep to our Emacs paths to factor it into the build:

#+begin_src nix :noweb yes :noweb-ref nix-linux-overlay-emacs-paths
ripgrep-for-doom-emacs
#+end_src

***** COMMENT Jupyter

Jupyter for Emacs is probably here to allow me to run Python code from my buffers.

#+begin_src nix :noweb yes :noweb-ref nix-linux-overlay-defs
jupyter-for-emacs = (pkgs.python38.withPackages (ps: with ps; [
  jupyter
]));
#+end_src

We also add the custom Jupyter package to our Emacs paths to factor it into the build:

#+begin_src nix :noweb yes :noweb-ref nix-linux-overlay-emacs-paths
jupyter-for-emacs
#+end_src

*** Packages
:PROPERTIES:
:header-args: :noweb-sep "\n\n"
:END:

**** mu

***** COMMENT mu: basic package

#+begin_src nix :noweb-ref nix-linux-packages
mu
#+end_src

***** TODO Explore if we can drop the overriden package instead of basic

The overriden package may no longer be necessary at this point. Tried to build previously with this "plain" mu and that worked so I think we're ready to move along and park the overriden stuff.

***** mu: overriden package

Commenting this out because of collision issues in nix:

#+begin_src text
these 5 derivations will be built:
  /nix/store/4n1wx8smvbfq6y8kpbm6r5i4770sklas-home-manager-path.drv
  /nix/store/idhr83djdm2aw18limb945sx4bl6iwaw-activation-script.drv
  /nix/store/pvls44m9w4c54gw9m99ddxmpckiggl4n-hm_fontconfigconf.d10hmfonts.conf.drv
  /nix/store/z2ab1bnwny925kmjrnkx24dlsm7sn9fg-home-manager-files.drv
  /nix/store/1p4mmm2wp83zl243q4ygqbhdyzyhhh3k-home-manager-generation.drv
building '/nix/store/4n1wx8smvbfq6y8kpbm6r5i4770sklas-home-manager-path.drv'...
error: collision between `/nix/store/nipkc69mampc75hqf2bscrak6pbs90vr-mu-1.8.11/share/emacs/site-lisp/mu4e/mu4e-search.elc' and `/nix/store/ssi8wd226dka2a4wv9yfw0hrnmpw1948-mu-1.8.13-1b2fb3b9bd737b09ec8b0168394d8a219b42e0d9/share/emacs/site-lisp/mu4e/mu4e-search.elc'
error: builder for '/nix/store/4n1wx8smvbfq6y8kpbm6r5i4770sklas-home-manager-path.drv' failed with exit code 25;
       last 1 log lines:
       > error: collision between `/nix/store/nipkc69mampc75hqf2bscrak6pbs90vr-mu-1.8.11/share/emacs/site-lisp/mu4e/mu4e-search.elc' and `/nix/store/ssi8wd226dka2a4wv9yfw0hrnmpw1948-mu-1.8.13-1b2fb3b9bd737b09ec8b0168394d8a219b42e0d9/share/emacs/site-lisp/mu4e/mu4e-search.elc'
       For full logs, run 'nix log /nix/store/4n1wx8smvbfq6y8kpbm6r5i4770sklas-home-manager-path.drv'.
error: 1 dependencies of derivation '/nix/store/1p4mmm2wp83zl243q4ygqbhdyzyhhh3k-home-manager-generation.drv' failed to build
make[1]: *** [Makefile:15: nix-switch] Error 1
make[1]: Leaving directory '/home/vidbina/src/vidbina/dotfiles'
make: *** [Makefile:9: all] Error 2
#+end_src

I believe that I installed this a long time ago because I needed to pin the version of mu but with the current updates on both the nixos-configuration and the dotfiles managed through home-manager, this may no longer be necessary.

#+begin_src nix :noweb-ref nix-linux-packages
(mu.overrideAttrs (oldAttrs:
  let
    rev = "4924daef6cdafec26cbbfe82de8cf52736d745f8";
  in
  {
    version = "1.8.11-${rev}";
    src = fetchFromGitHub {
      inherit rev;
      owner = "djcb";
      repo = "mu";
      sha256 = "sha256-IEfwAAUqEGtN4vww0pfW7iuIY/U3eqzC+MJsqtossCw=";
    };
    emacs = my-emacs;
  }))
#+end_src

**** Shorthand to emacsclient

#+begin_src nix :noweb-ref nix-linux-packages
(writeScriptBin "e" ''
  exec emacsclient -a emacs -c "$@"
'')
#+end_src

**** Emacs Org-Protocol

https://orgmode.org/worg/org-contrib/org-protocol.html

#+begin_src nix :noweb-ref nix-linux-packages
(makeDesktopItem {
  name = "emacs-org-protocol";
  exec = "${(baseCommand "emacs-org-protocol")} %u";
  comment = "Org Protocol";
  desktopName = "org-protocol";
  categories = [
    "Utility"
    "Database"
    "TextTools"
    "TextEditor"
    "Office"
  ];
  mimeTypes = [
    "x-scheme-handler/org-protocol"
  ];
  terminal = false;
})
#+end_src

***** Bookmarks

#+begin_src javascript
javascript:location.href = 'org-protocol://sub-protocol://' + encodeURIComponent(location.href) + '/' + encodeURIComponent(document.title) + '/' + encodeURIComponent(window.getSelection())
#+end_src

https://www.reddit.com/r/firefox/comments/k64ha0/fix_allow_this_site_to_open_the_protocol_link/

****** Store link

#+begin_src javascript
javascript:location.href='org-protocol://store-link://'+encodeURIComponent(location.href)
#+end_src

****** Capture

#+begin_src javascript
javascript:location.href = 'org-protocol://capture://' + encodeURIComponent(location.href) + '/' + encodeURIComponent(document.title) + '/' + encodeURIComponent(window.getSelection())
#+end_src

**** Emacs mu4e

#+begin_src nix :noweb yes :noweb-ref nix-linux-packages
<<nix-linux-packages-desktop-emacs-mu4e>>

<<nix-linux-packages-wrapper-emacs-mu4e>>
#+end_src

#+begin_src nix :noweb-ref nix-linux-packages-desktop-emacs-mu4e
# https://www.emacswiki.org/emacs/MailtoHandler
# https://dev.spacekookie.de/kookie/nomicon/commit/9e5896496cfd5da5754018887f7ad3b256b3ad80.diff
(makeDesktopItem {
  name = "emacs-mu4e";
  exec = "emacs-mu4e %u";
  comment = "Emacs mu4e";
  desktopName = "emacs-mu4e";
  type = "Application";
  categories = [
    "Network"
    "Email"
  ];
  mimeTypes = [
    # Email
    "x-scheme-handler/mailto"
    "message/rfc822"
  ];
  terminal = false;
})
#+end_src

#+begin_src nix :noweb-ref nix-linux-packages-wrapper-emacs-mu4e
(writeScriptBin "emacs-mu4e" ''
  set -e
  target_path=$@
  echo "Target: $target_path"

  exec emacsclient -a emacs -c -F "((name . \"emacs-dired\"))" -e "(vidbina-mime-handle-open-message-in-mu4e \"emacs-dired\" \"$target_path\")"
'')
#+end_src

**** Dired

#+begin_src nix :noweb yes :noweb-ref nix-linux-packages
<<nix-linux-packages-desktop-emacs-dired>>

<<nix-linux-packages-wrapper-emacs-dired>>
#+end_src

#+begin_src nix :noweb-ref nix-linux-packages-desktop-emacs-dired
# https://emacs.stackexchange.com/questions/13927/how-to-set-emacs-as-the-default-file-manager
(makeDesktopItem {
  name = "emacs-dired";
  exec = "emacs-dired %f";
  comment = "Emacs Dired";
  desktopName = "emacs-dired";
  categories = [
    "Utility"
    "FileManager"
    "FileTools"
  ];
  mimeTypes = [
    "inode/directory"
    "inode/symlink"
  ];
  terminal = false;
})
#+end_src

#+begin_src nix :noweb-ref nix-linux-packages-wrapper-emacs-dired
(writeScriptBin "emacs-dired" ''
  set -e
  target_path=$(printf '%q\n' "$@" | xargs realpath -e)
  echo "Sanitized target to: $target_path"

  exec emacsclient -a emacs -c -F "((name . \"emacs-dired\"))" -e "(vidbina-mime-handle-open-directory \"emacs-dired\" \"$target_path\")"
'')
#+end_src

*** Service

#+begin_src nix :noweb-ref nix-linux-services
services.emacs = {
  # Restart using `systemctl --user restart emacs`
  enable = true;
  package = pkgs.my-emacs;

  client.enable = true;
};
#+end_src

*** XDG mimeApps

#+begin_src nix :noweb-ref nix-linux-mime
xdg.mimeApps.defaultApplications = {
  "inode/directory" = [ "emacs-dired.desktop" ];
  "inode/symlink" = [ "emacs-dired.desktop" ];

  "message/rfc822" = [ "emacs-mu4e.desktop" ];
  "x-scheme-handler/mailto" = [ "emacs-mu4e.desktop" ];

  "x-scheme-handler/org-protocol" = [ "emacs-org-protocol.desktop" ];
};
#+end_src

** PROTOTYPE <<nix-config-darwin>> üçè Darwin

On Darwin, the home-manager configuration is simpler (and more restricted) than the GNU/Linux configuration. For starters, we don't have the ability to configure services (since Darwin doesn't support systemd).

#+begin_src nix :noweb yes :tangle default-darwin.nix
# Tangled from README.org
{ config, pkgs, lib, options, ... }:

let
  <<nix-let-bindings>>
in
{
  <<nix-home-emacsdir-source>>

  <<nix-home-programs>>

  <<nix-darwin-overlays>>
}
#+end_src

*** <<nix-overlays-darwin>> Overlays

#+begin_center
üêâ This has not been sufficiently tested so use with caution. I'm using NixOS mainly, so anything Darwin-related has probably been run once on a MacBook that I haven't touched for a good 4 months at the time of writing (being [2022-06-30 Thu 18:31]).
#+end_center

Using [[https://github.com/nix-community/emacs-overlay][emacs-overlay]], we compose a custom Emacs build that looks quite similar to the GNU/Linux configuration sans the graphical facilities and native compilation capabilities. Furthermore, the Darwin configuration has some =makeDesktopItem= packages bundled within it.

#+begin_center
ü§î Looking at the [[https://nixos.wiki/wiki/Emacs][NixOS Emacs wiki entry]], it may be worthwhile to revaluate what the difference between =emacsGit=, used in my GNU/Linux config, and =emacsPgtkGcc= (now known as =emacsPgtkNativeComp=) really is.
#+end_center

#+begin_src nix :noweb-ref nix-darwin-overlays
nixpkgs.overlays = [
  (import emacs-overlay-src)

  (self: super: {
    my-emacs =
      let
        emacs = pkgs.emacsPgtkGcc;
        emacsWithPackages = (pkgs.emacsPackagesNgGen emacs).emacsWithPackages;
        bundled-emacs = emacsWithPackages (epkgs: (
          with epkgs; [
            notmuch
            vterm
            pdf-tools
          ]
        ) ++ (
          with epkgs.melpaStablePackages; [
          ]
        ) ++ (
          with epkgs.melpaPackages; [
          ]
        ));
        ripgrep-for-doom-emacs = (pkgs.ripgrep.override {
          withPCRE2 = true;
        });
        jupyter-for-emacs = (pkgs.python38.withPackages (ps: with ps; [
          jupyter
        ]));
      in
      (pkgs.buildEnv {
        name = "my-emacs";
        paths = [
          bundled-emacs
          pkgs.clang
          pkgs.cmake
          pkgs.coreutils
          pkgs.fd
          pkgs.multimarkdown
          jupyter-for-emacs
          ripgrep-for-doom-emacs

          # for Emacs
          (pkgs.makeDesktopItem {
            name = "org-protocol";
            exec = "${bundled-emacs}/bin/emacsclient --create-frame %u";
            comment = "Org Protocol";
            desktopName = "org-protocol";
            type = "Application";
            mimeTypes = [ "x-scheme-handler/org-protocol" ];
          })

          # for Emacs
          # https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-0.9.5.html
          # https://www.emacswiki.org/emacs/MailtoHandler
          # https://dev.spacekookie.de/kookie/nomicon/commit/9e5896496cfd5da5754018887f7ad3b256b3ad80.diff
          (pkgs.makeDesktopItem {
            name = "emacs-mu4e";
            exec = ''
              ${bundled-emacs}/bin/emacsclient --create-frame --eval "(browse-url-mail \"%u\")"
            '';
            comment = "Emacs mu4e";
            desktopName = "emacs-mu4e";
            type = "Application";
            mimeTypes = [
              # Email
              "x-scheme-handler/mailto"
              "message/rfc822"
            ];
          })
        ];
      });
  })
];
#+end_src

**** emacsPgtkNativeComp vs emacsGit

Looking at [[https://github.com/nix-community/emacs-overlay/blob/master/default.nix][emacs-overlay default.nix]], the diff between =emacsGit= and =emacsPgtkNativeComp= is basically that the latter extends the former with native compilation. ü§∑üèø‚Äç‚ôÇÔ∏è

Perhaps we use differing builds because of issues like [[https://github.com/nix-community/emacs-overlay/issues/187][emacs-overlay issue 187]] but I simply can't recall how I settled on the current design.

***** Expansion

For reference's sake, observe how the definition of =emacsGit= wraps =mkGitEmacs=:

#+begin_src nix
emacsGit = mkGitEmacs "emacs-git" ./repos/emacs/emacs-master.json { withSQLite3 = true; };
#+end_src

****** TL;DR

The =emacsPgtkNativeComp= definition calls =mkPkgEmacs= and is listed below:

#+begin_src nix
emacsPgtkNativeComp = mkPgtkEmacs "emacs-pgtk-native-comp" ./repos/emacs/emacs-master.json { nativeComp = true; withSQLite3 = true; };
#+end_src

The =mkPgtkEmacs= definition just provides a wrapper around =mkGitEmacs=, removes the =--with-xft= configuration flag and adds the =--with-pgtk= flag.

#+begin_src nix
mkPgtkEmacs = namePrefix: jsonFile: { ... }@args: (mkGitEmacs namePrefix jsonFile args).overrideAttrs (
  old: {
    configureFlags = (super.lib.remove "--with-xft" old.configureFlags)
      ++ super.lib.singleton "--with-pgtk";
  }
);
#+end_src

****** Conclusion

It is fair to assume that =emacsPgtkNativeComp= expands to the following:

#+begin_src nix
(mkGitEmacs "emacs-pgtk-native-comp" ./repos/emacs/emacs-master.json {
  nativeComp = true;
  withSQLite3 = true;
}).overrideAttrs (old: {
  configureFlags = (super.lib.remove "--with-xft" old.configureFlags)
                   ++ super.lib.singleton "--with-pgtk";
});
#+end_src

The only diff being the change of name of the package, the attribute set (which now sets =nativeComp= to true) and the =configureFlags= override. Perhaps it is time to use =emacsPgtkNativeComp= for all builds after all. ü§∑üèø‚Äç‚ôÇÔ∏è

* Footnotes

[fn:6] Different variants of Markdown may have slightly differing and sometimes conflicting notation for some simple formatting markers such as the ones needed to underline, boldface or italicize text.

[fn:4] By allowing the Emacs package system to load packages prior to engaging our selected package manager, it becomes harder to establish where package-related state gets introduced. By choosing to manage all packages declaratively (through code) through a single package manager, one creates a situation that is easier to debug (single actor to observe) and reproduce (by reevaluating the configuration) while being a tad more deterministic (reduced ability of imperatively grown global state to break the configuration).

[fn:3] Remember that we're just using =~/.emacs.d= to simplify the text, but if you use another /[[emacsconfdir][emacs configuration directory]]/ you'll need to substitute every occurence of that path accordingly)

[fn:2] I am the /perpetual beginner/ üå± so I'm mostly writing this for my future self. üòÖ

[fn:1] Literal in the "Literal Programming" way as coined by Donald Knuth. There are a bunch of interesting bytes on the topic at [[http://literateprogramming.com/][literateprogramming.com]] and numerous other resources that can be link-followed when starting from one of the more recent related HN threads as per [2022-06-30 Thu] to the article [[https://news.ycombinator.com/item?id=31301777#31302835][Donald Knuth was framed (2020)]].

[fn:5] Keywords can be recognized by the =:= (colon character) prefix.

* Local Variables

For convenience, we call =delete-trailing-whitespace= as outlined in an [[https://www.mail-archive.com/emacs-orgmode@gnu.org/msg112517.html][emacs-orgmode mailing thread]] to automatically clean up trailing whitespaces that may be artifact from tangling noweb refs that
1. contain line-breaks and are being indented or
2. have no noweb-ref writes

;;; Local Variables:
;;; eval: (add-hook 'org-babel-post-tangle-hook #'delete-trailing-whitespace)
;;; eval: (add-hook 'org-babel-post-tangle-hook #'save-buffer :append)
;;; End:
