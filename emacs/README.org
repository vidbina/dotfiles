#+OPTIONS: html5-fancy:t
#+HTML_DOCTYPE: html5
#+STARTUP: overview
#+TODO: TODO WIP PROTOTYPE(p@) READY(p@) | DONE CANCELED(c@)
#+TITLE: Emacs 🦬 Configuration

This is an emoji-heavy 😅 literal[fn:1] configuration for [[https://www.gnu.org/software/emacs/][Emacs]] which is definitely not as feature complete like some distros out there (think: [[https://github.com/hlissner/doom-emacs][Doom Emacs]] or [[https://www.spacemacs.org/][Spacemacs]]) but may still provide you a pragmatic and easily parsable configuration that sticks to standard tooling 🧰 and patterns while providing sufficient context as to what is happening such that beginners[fn:2] can also have a good time cooking 👨🏿‍🔬 up or tweaking 👨🏿‍🔧 their configurations.

* Installation

I manage both my Emacs installation and my Emacs configuration declaratively. A [[nix-config][home-manager configuration written in Nix]] manages the version and bundle of Emacs on my system while classic Emacs LISP manages the Emacs configuration itself.

#+begin_center
⚠️ In case you don't use Nix ❄️ or can't be bothered to dive into it (in the same way I can't be bothered to remember the different build instructions for the tools that I depend on), please skip the part where I [[install-hm][install Emacs with home-manager]] and focus on the [[install-manual][manual installation]] instructions instead.
#+end_center

** <<install-hm>> Install with Home-Manager

My Emacs version is pretty up-to-date as per [2022-06-30 Thu 14:06] and was built entirely through my Nix configuration since I don't want to be bothered in terms on tooling in figuring out how to rebuild Emacs from scratch whenever needed.

#+begin_src elisp :results verbatim :exports both
(emacs-version)
#+end_src

#+RESULTS:
: "GNU Emacs 29.0.50 (build 1, x86_64-pc-linux-gnu, X toolkit, cairo version 1.16.0, Xaw scroll bars)"

The good bit about home-manager is that is will go as far as setting up home directories for me as well so there is little that I need to manually do other than the following steps:

1. clone this repo to a path of choice (e.g.: =~/src/THIS_REPO=)
2. to install either
   1. my entire config:
      1. enter root of the repo and
      2. run =make install=
   2. or just my Emacs-related config:
      1. borrow ideas from [[file:default.nix]] (or [[file:default-darwin.nix]] for macOS users) and place them into your own home-manager configuration
3. profit 💰

** <<install-manual>> Install manually

<<emacsconfdir>>
#+begin_center
⚠️ For this configuration we will refer to your /emacs configuration directory/ as =~/.emacs.d= for historic and didactic reasons, but it may be =~/.config/emacs= in your case. Consult [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Find-Init.html][How Emacs Finds Your Init File]] for explanation on how Emacs loads configurations and note that every mention of =~/.emacs.d= in this literate config assumes that you substitute it for your actual /emacs configuration directory/.
#+end_center

Clone this repository and symlink =~/.emacs.d= into the =emacs= directory of this configuration:
1. clone this repo to a path of choice (e.g.: =~/src/THIS_REPO=)
2. symlink =~/.emacs.d=[fn:3] to the =emacs= subdirectory of the cloned project (e.g.: =ln -s ~/src/THIS_REPO/emacs ~/.emacs.d=)
3. optionally, populate =~/.emacs.d/lang.el= or =~/.emacs.d/personal.el= (refer to [[*Usage][Usage]] for instructions)
4. reload your config or restart Emacs (e.g.: I have to run =systemctl --restart emacs.service= on NixOS since I am running Emacs as a systemd-managed service)

⚠️ Note that we are in subdirectory =emacs= of a dotfiles repository here which is all examples of commands or paths are written from the perspective of the [[file:..][top-level]] directory of this repository.

* Usage

Use this configuration by changing [[file:README.org][this README.org file]], the only source of truth, and tangling it to produce the Emacs LISP files [[file:early-init.el]], [[file:init.el]], [[file:lang.el]] and [[file:personal-example.el]] along with the relevant Nix configuration files [[file:default.nix]] and [[file:default-darwin.nix]] using the ~(org-babel-tangle)~ function which is mapped to =C-c C-v C-t= or =C-c C-v t= by default.

The files of this configuration are as follows:
- [[file:README.org]] :: source of truth that describes the entire configuration and tangles into the Elisp files listed below
- [[file:early-init.el]] :: configuration that is loaded before the GUI and package system are started (see [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html][The Early Init File]])
- [[file:init.el]] :: primary configuration file that Emacs loads on start (see [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html][The Emacs Initialization File]]),
- [[file:lang.el]] :: optional configuration file for language-specific settings, and
- [[file:personal-example.el]] :: reference for [[file:personal.el]] where you can add your personally sensitive configuration.
- [[file:personal.el]] :: optional configuration file for personal setting which can be populated by copying [[file:personal-example.el]] for to get started and modifying the code as necessary
- [[file:default.nix]] :: Nix home-manager configuration for GNU/Linux systems
- [[file:default-darwin.nix]] :: Nix home-manager configuration for Darwin system (macOS)

#+begin_src dot :file images/conf-setup.png :exports results
digraph G {
  subgraph cluster_emacs {
    label="Emacs load process"
    node_earlyinit [shape=box, label="early-init.el", style=filled]
    node_init [shape=box, label="init.el", style=filled]
    node_personal [shape=box, label="personal.el", style=filled]
    node_lang [shape=box, label="lang.el", style=filled]

    node_init -> node_personal [label="loads"]
    node_init -> node_lang [label="loads"]
  }

  node_this [shape=box, label="README.org"]
  node_personal_example [shape=box, label="personal-example.el"]
  node_default_nix [shape=box, style=dotted, label="default.nix"]
  node_default_darwin_nix [shape=box, style=dotted, label="default-darwin.nix"]

  node_this -> node_earlyinit [label="tangles to"]
  node_this -> node_init [label="tangles to"]
  node_this -> node_default_nix [label="tangles to", style=dotted]
  node_this -> node_default_darwin_nix [label="tangles to", style=dotted]
  node_personal_example -> node_personal [style=dotted]
}
#+end_src

#+RESULTS:
[[file:images/conf-setup.png]]

For convenience's sake, let's start stubbing some of the files that we will be tangling from this literate configuration.

** early-init.el

The [[file:early-init.el]] will be loaded before our "real configuration" is evaluated. Some configuration settings may have to be set at this stage but this should be used sparingly as it may be an indication of poor configuration when one has to resort too often to configuring at this stage.

#+begin_src elisp :tangle early-init.el
(message "🥱 Loading early-init.el")
#+end_src

** init.el

We enabe lexical binding, since some packages (e.g.: consult) will require this.

#+begin_src elisp :tangle init.el
;; -*- lexical-binding: t -*-
#+end_src


#+begin_src elisp :tangle init.el
(message "🚜 Loading init.el")
#+end_src

* 📦 Package Management

Setting =package-enable-at-startup= to =nil= before the Emacs default package system even loads (i.e.: before *early-init.el*) minimizes the potential for global state to affect the configuration which ends up simplifying this configuration's use[fn:4].

#+begin_src elisp :tangle early-init.el
(setq package-enable-at-startup nil)
#+end_src

** Straight 🍀

[[https://github.com/raxod502/straight.el#getting-started][Straight.el]] 🍀 is a popular package manager used to manage Emacs packages.

The primary advantage of using *straight.el* is the ability to _pin package version in a [[file:straight/versions/default.el][lockfile]]_ (e.g.: =~/.emacs.d/straight/versions/default.el=) in manner quite similar to how popular package managers such as Bundler (Ruby) and NPM (JavaScript) or Yarn (JavaScript) improve reproducibility of a configuration by pinning the versions of their packages in a dependency manifest (e.g.: Gemfile.lock for Bundler, package.lock for NPM and yarn.lock for Yarn).

*** ⚠️ Pre-bootstrap Work-around

The issue is that straight relies on the existence of variables with prefixes that have been renamed from =comp= to =native-comp=. So, if the installed variant of Emacs lacks native compilation capability, then straight will be bumping into undefined symbols.

#+begin_src elisp :tangle init.el
;; https://github.com/raxod502/straight.el/issues/757#issuecomment-839764260
(defvar comp-deferred-compilation-deny-list ())
#+end_src

Installation of the following packages may break when this block is disabled:
- straight
- [[*Org-contrib][org-contrib]]
- [[*Dockerfile][dockerfile-mode]]

*** 🥾 Bootstrap

#+begin_src elisp :tangle init.el
;; https://github.com/raxod502/straight.el#getting-started
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

*** Enabling the commonly-used *use-package* interface

For [[use-package-format][convenience]], we configure *straight.el* to use the *use-package* interface.

#+begin_src elisp :tangle init.el
;; https://github.com/raxod502/straight.el#integration-with-use-package
(straight-use-package 'use-package)
#+end_src

In order to improve visibility over package-related issues, we set =use-package-verbose= such that loading and configuration information is verbosely reported. The reporting output can be examined in the =*Messages*= buffer or in the logging output (.e.g: systemd journal in case Emacs is run as a systemd user unit or service).

#+begin_src elisp :tangle early-init.el
(setq use-package-verbose t)
#+end_src

<<use-package-format>>
If you've used Emacs for a while or have read through a few configurations, you have likely encountered a =use-package= declaration before. An association list (alist) style interface (of keyword[fn:5]-value pairs) is used by *use-package* to provide a pleasantly readable configuration structure.

The [[https://jwiegley.github.io/use-package/keywords/][Keywords]] page provides guidance as to how to use =use-package= keywords and the following snippet demonstrates the general structure of a =use-package= declaration:

#+begin_src elisp :results none
;; Just an example of a use-package form
(use-package my-package-y
  :straight t
  :after
  (:all my-package-a my-package-x)

  :init
  (setq my-package-coefficient 42)
  (message "Just a heads-up: we'll be setting up package y")

  :config
  (my-package-y-run-checks-after-load)
  (my-package-y-check-data-on-filesystem)
  (my-package-y-mode t)

  :bind (("C-c y 1" . my-package-y-do-thing-in-buffer)
         ("C-c y 2" . my-package-y-do-another-thing-in-buffer)))
#+end_src

#+begin_details org
#+HTML: <summary>Historic Context: Before use-package, package-specific configuration declarations may have been spread throughout a configuration and thus difficult to associate or debug.</summary>
For those familiar with classical Emacs configurations, you may recall that it wasn't uncommon to intersperse fragments of configurations of multiple packages in order to get everything loaded in the right order.

Compared to the earlier snippet in which the use of the *use-package* macro was demonstrated, a pre-*use-package* era configuration may have had the relevant declarations for a single package spread throughout a configuration.

#+begin_src elisp :results none
(setq my-package-coefficient 42)
(message "Just a heads-up: we'll be setting up package y")

;; ...

(require 'my-package-a)
(require 'my-package-x)

;; ...

(require 'my-package-y)
(my-package-y-run-checks-after-load)
(my-package-y-check-data-on-filesystem)
(my-package-y-mode t)

(add-hook 'my-package-y-mode
          (lambda ()
            (local-set-key (kbd "C-c y 1") 'my-package-y-do-thing-in-buffer)
            (local-set-key (kbd "C-c y 2") 'my-package-y-do-another-thing-in-buffer))
#+end_src

#+end_details

**** Organization

On the tidying up front, for example, you'll find that the *use-package* macro provides mechanisms to:
1. order the load sequence of packages by defining dependencies by means of the =:after= keyword
2. time application of parts of a configurations before or after /package load/ by means of the =:init= (i.e.: before load) and =:config= (i.e.: after load) keywords
3. bind keychords using the =:bind= keyword

**** Performance

On the performance front, you'll find that the *use-package* macro provides mechanisms to:
1. delay loading of packages by means of the =:defer= or =:demand= keywords
1. delay loading of packages needed in a particular mode or interpreter by means of the =:mode= or =:interpreter= keywords
2. define "as-of-yet not seen" symbols that will be needed for compilation by means of the =:functions= and =:defines= keywords

**** Ordering Management through Hooks

Emacs is a hot mess of global state sorcery and as such it may be useful to load packages or call package-specific functions in a particular order to render a configuration sufficiently functional. 🙊

Using *use-package*, the =:after= and =:hook= keywords are probably the more powerful tools to manage the ordering of your packages.

The Emacs [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Startup-Summary.html#Startup-Summary][Startup Summary]] page outlines when the =before-init-hook=, =after-init-hook=, =emacs-startup-hook= and =window-setup-hook= are run.

For convenience, we define some hook to notify us in the *Messages* buffer when these different milestones are reached.

#+begin_src elisp :tangle early-init.el
(add-hook 'before-init-hook (lambda () (message "🪝 Before init")))
(add-hook 'after-init-hook (lambda () (message "🪝 After init")))
(add-hook 'emacs-startup-hook (lambda () (message "🪝 Emacs startup")))
(add-hook 'window-setup-hook (lambda () (message "🪝 Window setup")))
#+end_src

Through the =:hook= keyword, we can /hook/ operations for a particular package into to the previously listed Emacs lifecycle hooks without leaving the expression for that specific package -- thus keeping all relevant configurations neatly localized.

* 📓 Org

[[https://orgmode.org/worg/org-contrib/org-protocol.html][Org]] is probably the killer app of Emacs and is actually just a clearly standardized markup format. Three ways in which Org discerns itself from Markdown are in that it:
1. has a single clear standard (that is widely used) as opposed to Markdown that has a few variants floating about that exhibit slightly differing behavior[fn:6] and may present a bit of challenge for application developers that wish to implement the standard
2. natively allows for the notation of dates and times which allow for things like time-tracking and planning within a single document.
3. natively provides table support

#+begin_src elisp :noweb yes :tangle init.el :results none
;; https://orgmode.org/worg/org-contrib/org-protocol.html
;; https://github.com/org-roam/org-roam/issues/529
;; https://git.savannah.gnu.org/cgit/emacs/org-mode.git/
(use-package org
  :straight (:type built-in)
  :init
  (setq org-adapt-indentation nil ; https://orgmode.org/manual/Hard-indentation.html
        org-hide-leading-stars nil
        org-odd-levels-only nil)
  :hook
  <<org-hook>>
  <<org-bind>>
  :config
  ;; https://orgmode.org/manual/Capture-templates.html#Capture-templates
  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-c d") 'org-hide-drawer-toggle)
  ;; https://www.reddit.com/r/emacs/comments/ldiryk/weird_tab_behavior_in_org_mode_source_blocks
  (setq org-src-preserve-indentation t
        org-hide-block-startup t)
  <<org-config>>
  :custom
  <<org-custom>>)
  #+end_src

** Customizations

#+begin_src elisp :noweb-ref org-custom
(org-tags-column 0 "Avoid wrapping issues by minimizing tag indentation")
(org-catch-invisible-edits 'error "Disable invisible edits")
(org-src-window-setup 'current-window "Show edit buffer in calling window")
(org-refile-targets '((nil . (:maxlevel . 3))) "Allow refiling to 3rd level headings")
#+end_src

*** Default workflow states

To facilitate my [[https://orgmode.org/manual/Workflow-states.html][workflow states]], we define:
- TODO :: something we want to work on
- WIP :: something that is work-in-progress but not yet "usable"
- PROTOTYPE :: something that is "usable"
- CANCELED :: something that we aborted and we'll have to provide explanation
- +DONE+ :: something that works and is ready for prime-time

#+begin_src elisp :noweb-ref org-custom
(org-todo-keywords '((sequence "TODO(t)" "WIP(w)" "|" "DONE(d)" "CANCELED(@c)")) "Allow fast-selection for my standard TODO states")
#+end_src

After a while, we can drop the =DONE= state from headings to just promote them to regular "features". In fact, we may as well remove 

#+begin_src plantuml :file images/org-default-workflow-states.png :exports results
@startuml

state "TODO" as state_todo #yellow
state "WIP" as state_wip #yellow
state "PROTOTYPE" as state_prototype #yellow
state "CANCELED" as state_canceled #pink
state "DONE" as state_done #lightgreen

[*] -> state_todo
state_todo -> state_wip : stub concept
state_todo --> state_canceled : abort
state_wip -> state_prototype : release alpha/beta
state_wip --> state_canceled : abort
state_prototype -> state_done : release production
state_prototype --> state_canceled : abort
state_canceled --> state_todo : reboot
state_done -> [*]

@enduml
#+end_src

#+RESULTS:
[[file:images/org-default-workflow-states.png]]

** <<org-babel>> Org-Babel

*** PROTOTYPE <<org-babel-tangle>> Asynchronous Tangle
:LOGBOOK:
- State "PROTOTYPE"  from "WIP"        [2022-06-28 Tue 13:34] \\
  initial concept using =find-file= which may be inefficient but we'll eat the gun on account of the ease of use
:END:

Tangling sometimes takes a fair amount of time that we can't always afford to waste by simply waiting. The following =org-babel-tangle-async= function is a wraps the original =org-babel-tangle= call in an async handler in order to allow us to regain control of our buffer while Org does its tangling magic.

#+begin_src elisp :noweb yes :noweb-ref org-config
(defun org-babel-tangle-async (&optional arg target-file lang-re)
  "Call `org-babel-tangle' asynchronously"
  (interactive "P")
  <<org-babel-tangle-async-start>>)
  #+end_src

The =org-babel-map= is defined in org-keys.el and maps =t= and =C-t= to =org-babel-tangle= of which we only need one alternative mapped to the async variant. Since I use lower keystroke variant =C-v C-c t= most, we'll map that one to our async variant.

#+begin_src elisp :noweb-ref org-bind
:bind (:map org-babel-map ("t" . org-babel-tangle-async))
#+end_src

The async handler, doesn't have to copy over the buffer contents since saving is a prerequisite to tangling.

#+begin_src elisp :noweb-ref org-babel-tangle-async-start
(run-hooks 'org-babel-pre-tangle-hook)
#+end_src

The async handler disables the auto-save facility and clears the pre-tangle hooks (perhaps a bad idea 🤷🏿‍♂️). We then just simply check that buffer-file-name is a string representing a valid file name and then open the file, navigate to point and trigger the intended [[(org-babel-tangle-call)][=org-babel-tangle= call]].

#+begin_center
It's unclear if the use of =find-file= is a really bad idea. I've considered that =with-temp-buffer= in combination with =insert= may be faster (see [[http://xahlee.info/emacs/emacs/elisp_find-file_vs_with-temp-buffer.html][Xahlee]]), but since we're tangling we'd need to spawn Org-mode anyways, so using =find-file= handles the major-mode switching for us to ensure that Org facilities are within reach. I may have to initialize packages if we need to mirror more of the configuration of the calling environment but we'll cross that bridge when we get there -- hence /prototype/. 🐉
#+end_center

#+begin_src elisp :noweb-ref org-babel-tangle-async-start
(async-start `(lambda ()
                (if (and (stringp ,buffer-file-name)
                         (file-exists-p ,buffer-file-name))
                    (progn
                      (setq exec-path ',exec-path
                            load-path ',load-path
                            enable-local-eval t
                            auto-save-default nil
                            org-babel-pre-tangle-hook '())
                      (package-initialize)
                      (find-file ,(buffer-file-name))
                      (read-only-mode t)
                      (goto-char ,(point))
                      (org-babel-tangle ,arg ,target-file ,lang-re) ; tangle! (ref:org-babel-tangle-call)
                      buffer-file-name)
                  (error "Not visiting a file")))
             `(lambda (result)
                (message "🧬 Async Org-Babel tangled %s" result)))
#+end_src

** Hide Line numbers when in org-mode

#+begin_src elisp :noweb-ref org-hook
(org-mode . (lambda () (display-line-numbers-mode 0)))
#+end_src

** Tips

*** Peeking through Org buffers

When navigating large buffers of Org, one can quickly peek through parts of the buffer in order to return to continue editing text thereafter. Do this by entering =org-goto= which is bound to =C-c C-j= by default and then using =org-occur= which is bound to =/= by default to have a glance and finally return by =C-g=.

Note that entering org-occur pulls up a buffer that provides some instructions.

** Org-Tempo

[[https://orgmode.org/manual/Structure-Templates.html][Structure templates]] allow one to quickly produce convenient src or quote blocks with just three keypresses. For example
- =< s TAB= to produce a source block
- =< q TAB= to produce a quote block
- =< C TAB= to produce a comment block
- =< h TAB= and =< l TAB= to produce export blocks for HTML and LaTeX respectively

#+begin_src elisp :noweb-ref org-config
;; https://orgmode.org/manual/Structure-Templates.html
(require 'org-tempo)
#+end_src

*** TODO Completions broken: jumping to next link or block instead

#+begin_center
⚠️ Unclear how to reproduce!
#+end_center

- when =ob-async-org-babel-execute-src-block= is highlighted through =C-;=

  =< s TAB= with the cursor at [[cursor]] breaks with the following profile

#+begin_src text
1448  79% - command-execute
1266  69%  - byte-code
1266  69%   - read-extended-command
1266  69%    - completing-read-default
1266  69%     - apply
1266  69%      - vertico--advice
1256  68%       + #<subr completing-read-default>
181   9%  - funcall-interactively
96   5%   - evil-open-below
2   0%    - evil-insert-newline-below
2   0%     - evil-move-end-of-line
2   0%      + move-end-of-line
2   0%    + evil-insert-state
1   0%    + indent-according-to-mode
61   3%   + evil-previous-visual-line
13   0%   + execute-extended-command
11   0%     iedit-next-occurrence
288  15% - ...
288  15%    Automatic GC
48   2% + timer-event-handler
23   1% + evil-normal-post-command
9   0% + redisplay_internal (C function)
2   0% + which-key--hide-popup
2   0% + evil--jump-hook
1   0% + evil-repeat-pre-hook
#+end_src

** Org LaTeX Listing Source Wrapping

By default listings in LaTeX exports don't line-wrap which is really useless when you have blocks with long lines and are hoping for readable output in a printable form-factor -- not to say that you actually print it but hey... your e-reader may want that printable form-factor?!? 🤷🏿‍♂️

The following configuration was stolen from [[https://www.reddit.com/r/emacs/comments/c1b70i/best_way_to_include_source_code_blocks_in_a_latex/][a Reddit thread]].

Figuring out how to get the ouput portrayed in a monospace font was informed by [[https://stackoverflow.com/a/2915765][a StackOverflow answer]] detailing how removal of the =column=flexible= option may help.

#+begin_src elisp :noweb-ref org-config
;; https://www.reddit.com/r/emacs/comments/c1b70i/best_way_to_include_source_code_blocks_in_a_latex/
(add-to-list 'org-latex-packages-alist '("" "listings" nil))
;;(setq org-latex-packages-alist nil)
;;(setq org-latex-listings t)
;;(setq org-latex-listings-options '(("breaklines" "true")))
(setq org-latex-listings t)
(setq org-latex-listings-options
      '(("basicstyle" "\\ttfamily")
        ("breakatwhitespace" "false")
        ("breakautoindent" "true")
        ("breaklines" "true")
        ;;("columns" "[c]fullflexible")
        ("commentstyle" "")
        ("emptylines" "*")
        ("extendedchars" "false")
        ;;("fancyvrb" "true")
        ("firstnumber" "auto")
        ("flexiblecolumns" "false")
        ("frame" "single")
        ("frameround" "tttt")
        ("identifierstyle" "")
        ("keepspaces" "true")
        ("keywordstyle" "")
        ("mathescape" "false")
        ("numbers" "left")
        ("numbers" "none")
        ("numbersep" "5pt")
        ("numberstyle" "\\tiny")
        ("resetmargins" "false")
        ("showlines" "true")
        ("showspaces" "false")
        ("showstringspaces" "false")
        ("showtabs" "true")
        ("stepnumber" "2")
        ("stringstyle" "")
        ("tab" "↹")
        ("tabsize" "4")
        ("texcl" "false")
        ("upquote" "false")))
#+end_src

** ox-clip: export Org fragments into HTML for rich-text input fields

The ox-clip exporters allow us to export fragments of our org documents into rich-text that is ready to paste into inputs on web apps. I use this frequently to copy org pieces into Google Docs or other online rich-text editors.

#+begin_src elisp :tangle init.el
;; https://github.com/jkitchin/ox-clip
;; https://zzamboni.org/post/my-emacs-configuration-with-commentary/
(use-package ox-clip
  :straight (ox-clip :type git
                     :host github
                     :repo "jkitchin/ox-clip")
  :after (org)
  :bind
  ("C-c y" . ox-clip-formatted-copy))
#+end_src

** WIP htmlize

Running ~(straight-dependants "htmlize")~ yields =("ox-clip" ("org-ref" "org-roam-bibtex"))= so we define htmlize to control the version of htmlize that is installed since the implict configuration resulted to an outdated version of htmlize on my system.

:BACKGROUND:
Looking into htmlize started when stumbling upon errors in exporting Org blocks to HTML. Just export this entire file to HTML would eventually fail with =Invalid face: unspecified= to which I authored a [[https://github.com/hniksic/emacs-htmlize/pull/41/files][PR]] with a coarse fix.
:END:

#+begin_src elisp :noweb yes :tangle init.el
;; https://github.com/hniksic/emacs-htmlize
(use-package htmlize
  <<htmlize-straight-github-fork>>
  :init
  ;; https://www.reddit.com/r/orgmode/comments/5uj17n/invalid_face_error_when_publishing_org_to_html/
  (setq org-html-htmlize-output-type 'inline-css)
  :custom
  (htmlize-ignore-face-size t))
#+end_src

:DRAWER:
Running into the following pesky warning which is why this is still in WIP:

When using my fork on Github, I get:

#+begin_src text
Warning (straight): Two different recipes given for "htmlize" (:repo cannot be both "hniksic/emacs-htmlize" and "vidbina/emacs-htmlize") Disable showing Disable logging
#+end_src

When pointing straight to a local directory, I get:

#+begin_src text
Warning (straight): Two different recipes given for "htmlize" (:local-repo cannot be both "emacs-htmlize" and "~/src/vidbina/emacs-htmlize") Disable showing Disable logging
#+end_src

There was a dialog to resolve this by renaming one of the origins to =origin-1= and configuring the new target as =origin= but this broke in a manner that required me to drop into Dired or Magit to fix it anyways. I ended up removing the offending folder in the straight/repos directory.
:END:

*** Source from Github

The original repository is [[https://github.com/hniksic/emacs-htmlize][hniksic/emacs-htmlize]]:

#+begin_src elisp :noweb-ref htmlize-straight-github-original
:straight (htmlize :type git
                   :host github
                   :repo "hniksic/emacs-htmlize")
#+end_src

In order to refer to a self-cooked fix in a local-system independent way, I have a [[https://github.com/vidbina/emacs-htmlize][fork]] with a fix branch.

#+begin_src elisp :noweb-ref htmlize-straight-github-fork
:straight (htmlize :type git
                   :host github
                   :branch "fix-face-size-unspecified-head"
                   :repo "vidbina/emacs-htmlize")
#+end_src

*** Source Locally

For the testing of changes, I may opt to directly refer to a folder local to my system and ignore version control and consider the folder state authoritative to accellerate development.

#+begin_center
⚠️ Setting =:type nil= seems invalid.
#+end_center

#+begin_src elisp :noweb-ref htmlize-straight-local
:straight (htmlize :local-repo "~/src/vidbina/emacs-htmlize")
#+end_src

*** TODO Merge change to =htmlize-face-size= upstream

https://github.com/hniksic/emacs-htmlize/pull/41

** COMMENT ox-slimhtml

https://github.com/balddotcat/ox-slimhtml

#+begin_src elisp :tangle init.el
;; https://github.com/balddotcat/ox-slimhtml
(use-package ox-slimhtml
  :straight (ox-slimhtml :type git
                         :host github
                         :repo "balddotcat/ox-slimhtml")
  :after org
  :config
  (org-export-string-as "org content" 'slimhtml t)
  (org-export-to-buffer 'slimhtml "*slimhtml*")

  (org-export-define-derived-backend
      'custom-html-exporter
      'slimhtml                             ;; org's default exporter is 'html
    :translate-alist
    '((bold . ox-slimhtml-bold)             ;; technically, this is already set
      (special-block . org-html-special-block))))
#+end_src

** TODO Bibliography

*** ol-BibTeX (Org-BibTeX): Bibliography through org properties

The =ol-bibtex= package, previously known as =org-bibtex= and still prefixed as such, allows for the definition of bibliography entries within Org properties.

#+begin_src org
,** Introduction to Flight Test Engineering
:PROPERTIES:
:BIB_TITLE: Introduction to Flight Test Engineering
:BIB_BTYPE: techreport
:BIB_CUSTOM_ID: stoliker2005FTE
:BIB_AUTHOR: F.N. Stoliker
:BIB_INSTITUTION: RTO
:BIB_YEAR: 2005
:BIB_NUMBER: RTO-AG-300-V14
:BIB_DATE: 7/25/2005
:BIB_ADDRESS:
:BIB_MONTH: 07
:BIB_BIB_DOI: 10.14339/RTO-AG-300-V14
:BIB_BIB_ISBN: 92-837-1126-2
:BIB_NOTE:
:BIB_ANNOTE:
:END:

Some notes on this book...
#+end_src

The previously listed Org snippet will produce the following BibTeX entry:

#+begin_src bibtex
                  @techreport{stoliker2005FTE,
                    annote={},
                    note={},
                    isbn={92-837-1126-2},
                    doi={10.14339/RTO-AG-300-V14},
                    month={07},
                    address={},
                    date={7/25/2005},
                    number={RTO-AG-300-V14},
                    year={2005},
                    institution={RTO},
                    author={F.N. Stoliker},
                    custom_id={stoliker2005FTE},
                    title={Introduction to Flight Test Engineering}
                  }
#+end_src

Please note that *ol-bibtex* refers to an internal index =org-bibtex-types= that lists fields for every record type (e.g.: article, book, techreport, etc.) and only honors the entries that are listed therein.

Since, I sometimes need "arbitrary" fields such as =doi= that BibTeX itself may recognize but that the ol-bibtex package will simply ignore (for some bibliography types) as they are not listed in =org-bibtex-types=, it will be necessary to set =org-bibtex-export-arbitrary-types= to honor arbitrary fields which itself will require =org-bibtex-prefix= to also be set (which I set to =BIB_=). The caveat is that setting =org-bibtex-prefix= is an all-or-nothing type of deal and will require us to prefix all BibTeX properties (with =BIB_= in this particular configuration's case).

Another option may be for us to enhance =org-bibtex-headline= to be a bit smarter about honoring "known fields" in a properties block along with "arbitrary fields" as long as they are prefixed. This is only a partial solution as it only solves to problem of converting headlines to BibTeX entries, while the *ol-bibtex* package also helps reading valid BibTeX entries with =org-bibtex-read= and writing them into Org headlines with =org-bibtex-write= where the prefix is used for all entries indicating that prefixing everything is the expected behavior that allows for reliable and consistent bidirectional traffic (Org-to-BibTeX and BibTeX-to-Org).

#+begin_src elisp :tangle init.el
(use-package ol-bibtex
  :straight (:type built-in)
  :after org
  :custom
  (org-bibtex-prefix "BIB_" "Define prefix for arbitrary fields")
  (org-bibtex-export-arbitrary-fields t "Export prefixed fields"))
#+end_src

For reference's sake, note that for headers containing non-prefixed and prefixed fields, *ol-bibtex* will end up exporting the prefixed fields only.

#+begin_src org
,** Introduction to Flight Test Engineering
:PROPERTIES:
:TITLE:    Introduction to Flight Test Engineering
:BTYPE:    techreport
:CUSTOM_ID: stoliker2005FTE
:AUTHOR:   F.N. Stoliker
:INSTITUTION: RTO
:YEAR:     2005
:NUMBER:   RTO-AG-300-V14
:DATE:     7/25/2005
:ADDRESS:
:MONTH:    07
:BIB_DOI:  10.14339/RTO-AG-300-V14
:BIB_ISBN: 92-837-1126-2
:NOTE:
:ANNOTE:
:END:
#+end_src

The example listed above will yield the following BibTeX entry which demonstrates this point.

#+begin_src bibtex
                  @techreport{stoliker2005FTE,
                    isbn={92-837-1126-2},
                    doi={10.14339/RTO-AG-300-V14}
                  }
#+end_src

*** Org-contrib

#+begin_src elisp :tangle init.el
;; https://git.sr.ht/~bzg/org-contrib
(use-package org-contrib
  :straight (org-contrib :type git
                         :host nil
                         :repo "https://git.sr.ht/~bzg/org-contrib")
  :after org)
#+end_src

*** COMMENT Citar (formerly bibtex-actions)

#+begin_src elisp :tangle init.el
;; https://github.com/bdarcus/citar
(use-package citar
  :straight (citar :type git
                   :host github
                   :repo "bdarcus/citar")
  :no-require
  :custom
  (org-cite-insert-processor 'citar)
  (org-cite-follow-processor 'citar)
  (org-cite-activate-processor 'citar)
  :bind
  (:map org-mode-map :package org ("C-c b" . #'org-cite-insert)))
#+end_src

** 🗄️ Org-Roam

A good solution for maintaining a Zettelkasten-inspired note-taking system is [[https://github.com/org-roam/org-roam][Org-Roam]] which allows one to conveniently link related notes together.

#+CAPTION: Screenshot of Org-Roam in use with an Org-Roam-UI note network graph
[[file:images/screenshot-orui-org-cite-dark.png]]

#+begin_src elisp :tangle init.el :noweb yes
;; https://github.com/org-roam/org-roam
(use-package org-roam
  :straight (org-roam :type git
                      :host github
                      :repo "org-roam/org-roam")
  :after org
  :init
  (setq org-roam-v2-ack t)
  <<org-roam-init>>

  :config
  (message "📔 org-roam is loaded")
  <<org-roam-config>>

  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n i" . org-roam-node-insert)
         <<org-roam-bind>>))
#+end_src

*** Org-Roam Directory

#+begin_src elisp :noweb-ref org-roam-init
(let ((directory (file-truename "~/org/roam/")))
  (make-directory directory t)
  (setq org-roam-directory directory))
(setq org-roam-file-extensions '("org" "md"))
#+end_src

*** Database

Set the Org-roam database location:

#+begin_src elisp :noweb-ref org-roam-init
(setq org-roam-db-location (file-truename "~/org/roam/org-roam.db"))
#+end_src

**** WIP <<org-roam-db-sync-async>> Async Org-Roam-DB Sync or rather Non-blocking Org-Roam DB Sync

Yes, naming of this section is problematic but we're trying to conduct the synchronization in an asynchronous manner such that we don't have to block the main thread all the time we conduct an =org-roam-db-sync=.

We define a =vidbina/org-roam-async-forced-sync= interactive function that runs src_elisp[:exports code]{(org-roam-db-sync 'force)} asychronously.

#+begin_src elisp :noweb yes :tangle personal-example.el
(defun vidbina/org-roam-db-async-forced-sync ()
  "Fully sync"
  (interactive)
  <<vidbina/org-roam-db-async-sync>>)
#+end_src

The async handler is defined in the following block which allows us to quickly debug it by triggered ~org-edit-special~ on the block and executing the block by running ~eval-defun~:

#+begin_src elisp :noweb-ref vidbina/org-roam-db-async-sync
(let* ((my-org-roam-vars '("org-roam-directory"
                           "org-roam-db-location"
                           "org-roam-file-extensions"
                           "org-roam-v2-ack"))
       (my-setq-form (async-inject-variables (regexp-opt my-org-roam-vars))))
  (message "Async Org-Roam sync injection form: %s" (pp my-setq-form))
  (async-start `(lambda ()
                  (message "Async Org-Roam sync async process entry")
                  (setq exec-path ',exec-path
                        load-path ',load-path)
                  ,my-setq-form
                  (package-initialize)
                  (require 'org-roam)
                  (message "Async Org-Roam sync dir %s for file extensions %s" org-roam-directory org-roam-file-extensions)
                  (org-roam-db-sync 'force))
               `(lambda (result)
                  (message "Async Org-Roam sync from %s" result))))
#+end_src

We define a binding that calls our async synchronization function:

#+begin_src elisp :noweb-ref org-roam-bind :results none
("C-c n u" . vidbina/org-roam-db-async-forced-sync)
#+end_src

Since I want to handle synchronization of my Org-Roam database manually through my async handler, we disable autosync:

#+begin_src elisp :noweb-ref org-roam-config
(org-roam-db-autosync-disable)
#+end_src

*** Org-Roam-UI

#+begin_src elisp :tangle init.el
;; https://github.com/org-roam/org-roam-ui
(use-package org-roam-ui
  :straight (org-roam-ui :host github
                         :repo "org-roam/org-roam-ui"
                         :branch "main"
                         :files ("*.el" "out"))
  :delight
  (org-roam-ui-mode "🕸️")
  (org-roam-ui-follow-mode "👀")
  :after org-roam
  ;; normally we'd recommend hooking orui after org-roam, but since org-roam does not have
  ;; a hookable mode anymore, you're advised to pick something yourself
  ;; if you don't care about startup time, use
  :bind (("C-c n ." . org-roam-ui-node-zoom)
         ("C-c n ," . org-roam-ui-node-local))
  :hook (after-init . org-roam-ui-mode)
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow nil
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start nil))
#+end_src

*** Incorporate Markdown into your Org-Roam use

It isn't unlikely that you will have some of your notes captured in Markdown files. In order to not have to rewrite these files into Org-files, you can use [[https://github.com/nobiot/md-roam][Md-roam]].

#+begin_src elisp :tangle init.el
;; https://github.com/nobiot/md-roam
(use-package md-roam
  :straight (md-roam :type git
                     :host github
                     :repo "nobiot/md-roam")
  :after org-roam
  :init
  (setq md-roam-use-markdown-file-links t
        md-roam-file_extension-single "md"
        org-roam-tag-sources '(prop md-frontmatter)
        org-roam-title-sources '((mdtitle title mdheadline headline) (mdalias alias))))
#+end_src

*** <<org-roam-bibtex>> Org-Roam-BibTeX (ORB)

#+begin_src elisp :noweb yes :tangle init.el
;; https://github.com/org-roam/org-roam-bibtex
(use-package org-roam-bibtex
  :straight (org-roam-bibtex :type git
                             :host github
                             :repo "org-roam/org-roam-bibtex")
  :after org-roam
  <<org-roam-bibtex-org-ref>>
  )
#+end_src

We add a reminder in the source that usage of org-roam-bibtex in combination with [[org-ref][org-ref]] requires additional configuration -- lest I forget. 😅

#+begin_src elisp :noweb-ref org-roam-bibtex-org-ref
;; NOTE: Using org-ref requires additional configuration
#+end_src

**** COMMENT Using ORB with Org-ref

Since Org-cite is shipped with Org now (as per Org 9.5), we may not need [[org-ref][Org-ref]] anymore. In case you still want to use the org-ref citation package in combination with Org-Roam, the following configurations may come in handy:

#+begin_src elisp :noweb-ref org-roam-bibtex-org-ref
:config
(require 'org-ref)
:custom
(orb-roam-ref-format 'org-ref-v3 "Use new org-ref cite:&links notation in ROAM_REFS property")
#+end_src

** COMMENT <<org-ref>> Org-ref

[[https://github.com/jkitchin/org-ref][Org-ref]] provides a system to define citations and cross-references. With Org-cite becoming part of standard-Org since 9.5, I am trying to use standard Org as much as possible which means dropping Org-ref out of my toolbox for a bit.

#+begin_center
Org-ref has provisions for cross-referencing that Org-cite doesn't quite provide, so you may want to enable Org-ref in your configuration if you use the Org-ref cite syntax or rely on cross-referencing capability.
#+end_center

#+begin_src elisp :tangle init.el
;; https://github.com/jkitchin/org-ref
(use-package org-ref
  :straight (org-ref :type git
                     :host github
                     :repo "jkitchin/org-ref")
  :after (org-roam))
#+end_src

** Org-QL

In order to query Org files with more flexibility, [[https://github.com/alphapapa/org-ql][org-ql]] can come to the rescue.

#+begin_src elisp :tangle init.el
;; https://github.com/alphapapa/org-ql
(use-package org-ql
  :straight (org-ql :type git
                    :host github
                    :repo "alphapapa/org-ql"))
#+end_src

In the most basic usage form you can basically run ~org-ql-search~ and just enter =todo= to get a basic listing.

** <<ob-async>> ob-async

In some cases, code blocks need to be executed in a non-blocking manner (e.g.: when firing up a test instance of emacs or triggering a large file transfer). The [[https://github.com/astahlman/ob-async][ob-async]] package allow async execution of code-blocks by simply adding the =:async= keyword to the a codeblock of interest.

#+begin_center
Since the [[https://blog.tecosaur.com/tmio/2021-05-31-async.html#async-babel-sessions
][introduction of ob-comint.el]] there is support for sessions and async code execution built into Org itself. The only gotcha is that, at the time of writing [2022-06-26 Sun], there is only a Python implementation that is ob-comint compatible while there are implementations for R and Ruby in the works. For other runtimes, ob-async is a bit more flexible because we can use this on any language since there is no requirement on providing a ob-comint-compatible implementation but we simply spawn another Emacs sessions asynchronously to just run the code. Use variable =ob-async-no-async-language-alist= to bypass ob-async for org-babel-languages that provide their own =:async= keyword and async handling workflow.
#+end_center

*** COMMENT Original

#+begin_src elisp :tangle init.el
;; https://github.com/astahlman/ob-async
(use-package ob-async
  :straight (ob-async :type git
                      :host github
                      :repo "astahlman/ob-async"))
#+end_src

*** Fork

In order to fix the ob-async for my own setup, I've [[https://github.com/vidbina/ob-async][forked]] the [[https://github.com/astahlman/ob-async][original repo]] with a few minor changes/fixes.

#+begin_src elisp :tangle init.el
;; https://github.com/vidbina/ob-async
(use-package ob-async
  :straight (ob-async :type git
                      :host github
                      :branch "main"
                      :repo "vidbina/ob-async"))
#+end_src

*** Usage

Under the hood ob-async depends on [[async]] and can be used by specifying an =:async= header on a code block as demonstrated below:

#+begin_src bash :async t :session "*blah*" :results verbatim
sleep 2; echo hi
#+end_src

#+RESULTS:
: 
: hi

*** WIP Debug invalid read read syntax error during variable injection

When injecting variables, the default =ob-async-inject-variables= pattern seems to allow for propertized strings getting injected into the new environment which likely triggers invalid read syntax issues.

#+begin_src text
error in process sentinel: async-when-done: Invalid read syntax: "#"
error in process sentinel: Invalid read syntax: "#"
#+end_src

**** COMMENT Yak Shaving

***** Exploring Text Properties

Since Emacs 28.1, we can check an object for text properties in the following manner which we can use to collect the properties to strip from said object:

#+begin_src elisp
(object-intervals (concat
                   (propertize "foo" 'face 'bold)
                   " and "
                   (propertize "bar" 'face 'italic
                               'mouse-face 'bold-italic)))
#+end_src

The idiomatic async package way to strip an object of its properties is through =async--purecopy=:

#+begin_src elisp
(async--purecopy (concat
                  (propertize "foo" 'face 'bold)
                  " and "
                  (propertize "bar" 'face 'italic
                              'mouse-face 'bold-italic)))
#+end_src

A simple check of property-free-ness could be conducted by an equality check between the purecopy equivalent and the original object using the =equal-including-properties= function:

#+begin_src elisp :results verbatim
(let ((x (concat
          (propertize "foo" 'face 'bold)
          " and "
          (propertize "bar" 'face 'italic
                      'mouse-face 'bold-italic))))
  (list (equal-including-properties "foo and bar" (async--purecopy x))
        (equal-including-properties "foo and bar" x)))
#+end_src

#+RESULTS:
: (t nil)

***** Variable Injection

For debugging purposes, we'll start off by trying to inject variables only when the variable names and properties are property-free.

#+begin_src elisp -n -r :results none
(defun async-inject-variables
    (include-regexp &optional predicate exclude-regexp noprops)
  "Return a `setq' form that replicates part of the calling environment.

It sets the value for every variable matching INCLUDE-REGEXP and
also PREDICATE.  It will not perform injection for any variable
matching EXCLUDE-REGEXP (if present) or representing a `syntax-table'
i.e. ending by \"-syntax-table\".
When NOPROPS is non nil it tries to strip out text properties of each
variable's value with `async-variables-noprops-function'.

It is intended to be used as follows:

    (async-start
       \\=`(lambda ()
          (require \\='smtpmail)
          (with-temp-buffer
            (insert ,(buffer-substring-no-properties (point-min) (point-max)))
            ;; Pass in the variable environment for smtpmail
            ,(async-inject-variables \"\\\\=`\\(smtpmail\\|\\(user-\\)?mail\\)-\")
            (smtpmail-send-it)))
       \\='ignore)"
  `(setq
    ,@(let (bindings)
        (mapatoms
         (lambda (sym)
           (let* ((sname (and (boundp sym) (symbol-name sym)))
                  (value (and sname (symbol-value sym))))
             (when (and sname
                        (eq nil (object-intervals sname)) ; check that sname is props-free
                        (or (null include-regexp)
                            (string-match include-regexp sname))
                        (or (null exclude-regexp)
                            (not (string-match exclude-regexp sname)))
                        (not (string-match "-syntax-table\\'" sname)))
               (unless (or (stringp value)
                           (memq value '(nil t))
                           (numberp value)
                           (vectorp value))
                 (setq my-debug-last-unless-sname sname)
                 (setq value `(quote ,value)))
               (when noprops
                 (setq my-debug-last-noprops-sname sname)
                 (setq value (funcall async-variables-noprops-function
                                      value)))
               (when (or (null predicate)
                         (funcall predicate sym))
                 (setq bindings (cons value bindings)
                       bindings (cons sym bindings)))))))
        bindings)))
#+end_src

From the following error output we instrument =async-handle-result=:

#+begin_src text
Debugger entered--Lisp error: (invalid-read-syntax "#")
async-handle-result((lambda (result) (with-current-buffer #<buffer README.org<concept-clj-react>> (let ((default-directory "/home/vidbina/src/formation.tools/eng/concept-clj-...")) (save-excursion (cond ((member "none" ...) (message "result silenced")) ((member "silent" ...) (message ...)) (t (goto-char #<marker at 2280 in README.org<concept-clj-react>>) (let ... ... ... ...))) (run-hooks 'org-babel-after-execute-hook))))) (async-signal (invalid-read-syntax "#")) #<buffer *emacs*<26>>)
async-when-done(#<process emacs> "finished\n")
#+end_src

Inside =async-handle-result= we evaluated =result= which is already =async-signal (invalid-read-syntax "#")= which leads me to conclude that the caller =async-when-done= is already in an error state. The caller basically populates the value for the arg-of-interest through ~(read (current-buffer))~

#+begin_center
⚠️ I once instrumented =async-when-done= and ended up in a curous GC infinite loop that was difficult to meaningfully debug with GDB on account of lacking symbols.
#+end_center

Note that =(read (current-buffer))= [[(handle-old)]] can be resolved for a hard-coded value like ="hi"= which does complete without error. Furthermore, ~(vidbina/open-proc-below proc)~ [[(handle-dbg)]] is a helper to spawn the proc buffer for improved visibility during debugging. The ~(edebug)~ source breakpoint allows us to stop at this point for further investigation.

#+begin_src elisp -n -r :results none
(defun async-when-done (proc &optional _change)
  "Process sentinel used to retrieve the value from the child process."
  (when (eq 'exit (process-status proc))
    (with-current-buffer (process-buffer proc)
      (let ((async-current-process proc))
        (if (= 0 (process-exit-status proc))
            (if async-callback-for-process
                (if async-callback
                    (prog1
                        (funcall async-callback proc)
                      ;; (edebug)
                      (unless async-debug
                        (kill-buffer (current-buffer))))
                  (set (make-local-variable 'async-callback-value) proc)
                  (set (make-local-variable 'async-callback-value-set) t))
              ;;(vidbina/open-proc-below proc) ;; open a debug window below with the proc results (ref:handle-dbg)
              ;;(edebug)
              (goto-char (point-max))
              (backward-sexp)
              (async-handle-result async-callback (read (current-buffer)) ;; this read fails (ref:handle-old)
                                   (current-buffer)))
          (set (make-local-variable 'async-callback-value)
               (list 'error
                     (format "Async process '%s' failed with exit code %d"
                             (process-name proc) (process-exit-status proc))))
          (set (make-local-variable 'async-callback-value-set) t))))))
#+end_src

Before =async-when-done= is called the proc already exists and contains the following content as the =vidbina/debug-open-proc= call above on line [[(handle-dbg)]] has revealed:

#+begin_src text
Lisp expression: (async-signal (invalid-read-syntax "#"))
#+end_src

This leads us to the caller =async-start-process= which we can debug next, where =proc= calls =apply= against =#'start-process name buf program program-args= as demonstrated in [[(proc-apply)]].

The =async-start-process= function fires another process and attaches callbacks for when its state changes through the =set-process-sentinel= function.

#+begin_src elisp -n -r :results none
(defun async-start-process (name program finish-func &rest program-args)
  "Start the executable PROGRAM asynchronously named NAME.  See `async-start'.
PROGRAM is passed PROGRAM-ARGS, calling FINISH-FUNC with the
process object when done.  If FINISH-FUNC is nil, the future
object will return the process object when the program is
finished.  Set DEFAULT-DIRECTORY to change PROGRAM's current
working directory."
  (let* ((buf (generate-new-buffer (concat "*" name "*")))
         (proc (let ((process-connection-type nil))
                 (apply #'start-process name buf program program-args)))) ;; where the async work happens (ref:proc-apply)
    (with-current-buffer buf
      (set (make-local-variable 'async-callback) finish-func)
      (set-process-sentinel proc #'async-when-done)
      (unless (string= name "emacs")
        (set (make-local-variable 'async-callback-for-process) t))
      proc)))
#+end_src

In my setup, there are the following variables and values:
- program  =/nix/store/9b2cr2b5ldkclxkiascbslrczzg2y5y2-emacs-git-20220101.0/bin/emacs-29.0.50=
- program-args
  - =-Q=
  - =-l=
  - =/home/vidbina/.emacs.d/straight/build/async/async.el=
  - =-batch=
  - =-f=
  - =async-batch-invoke= which is the function that is invoked on the executioner end.
  - =<none>=

Going one level higher, one will notice that =async-start= attempts to serialize =start-func= at line [[(async-serialization)]]. This serialization attempt isn't fool-proof.

#+begin_src elisp -n -r :results none
(defun async-start (start-func &optional finish-func)
  "Execute START-FUNC (often a lambda) in a subordinate Emacs process.
When done, the return value is passed to FINISH-FUNC.  Example:

    (async-start
       ;; What to do in the child process
       (lambda ()
         (message \"This is a test\")
         (sleep-for 3)
         222)

       ;; What to do when it finishes
       (lambda (result)
         (message \"Async process done, result should be 222: %s\"
                  result)))

If FINISH-FUNC is nil or missing, a future is returned that can
be inspected using `async-get', blocking until the value is
ready.  Example:

    (let ((proc (async-start
                   ;; What to do in the child process
                   (lambda ()
                     (message \"This is a test\")
                     (sleep-for 3)
                     222))))

        (message \"I'm going to do some work here\") ;; ....

        (message \"Waiting on async process, result should be 222: %s\"
                 (async-get proc)))

If you don't want to use a callback, and you don't care about any
return value from the child process, pass the `ignore' symbol as
the second argument (if you don't, and never call `async-get', it
will leave *emacs* process buffers hanging around):

    (async-start
     (lambda ()
       (delete-file \"a remote file on a slow link\" nil))
     \\='ignore)

Note: Even when FINISH-FUNC is present, a future is still
returned except that it yields no value (since the value is
passed to FINISH-FUNC).  Call `async-get' on such a future always
returns nil.  It can still be useful, however, as an argument to
`async-ready' or `async-wait'."
  (let ((sexp start-func)
        ;; Subordinate Emacs will send text encoded in UTF-8.
        (coding-system-for-read 'utf-8-auto))
    (setq async--procvar
          (async-start-process
           "emacs" (file-truename
                    (expand-file-name invocation-name
                                      invocation-directory))
           finish-func
           async-quiet-switch "-l"
           ;; Using `locate-library' ensure we use the right file
           ;; when the .elc have been deleted.
           (locate-library "async")
           "-batch" "-f" "async-batch-invoke"
           (if async-send-over-pipe
               "<none>"
             (with-temp-buffer
               (async--insert-sexp (list 'quote sexp))
               (buffer-string)))))
    (if async-send-over-pipe
        (async--transmit-sexp async--procvar (list 'quote sexp))) ;; (ref:async-serialization)
    async--procvar))
#+end_src

#+begin_src elisp
(setq async-debug nil)
#+end_src

**** Root cause

From a deeper analysis of =async-inject-variables= on the ob-async pattern, the following snippet will fail when the variable injection form is not "readable" by the async executor.

#+begin_src elisp -n -r :results none
(read (pp-to-string (async-inject-variables ob-async-inject-variables)))
#+end_src

In some cases, variables like =org-babel-hide-result-overlays= may contain /overlay/ values:

#+begin_src elisp :results verbatim
(overlayp (car org-babel-hide-result-overlays))
#+end_src

#+RESULTS:
: t

A sexp will be sent to the executor after serialization of the sexp through =pp-to-string= and since overlays are serialized into a =#<overlays ...>= format, they are not "readable" in their pretty-printed form:

#+begin_src elisp :results none
(read (#<overlay from 39236 to 39236 in README.org<emacs>>))
#+end_src

**** COMMENT Solution

We can exclude the problem by eliminating "-overlays" from the variable injection form.

#+begin_src elisp -n -r :results none
(read (pp-to-string (async-inject-variables ob-async-inject-variables nil "-overlay")))
#+end_src

We define a rejection pattern:

#+begin_src elisp :tangle init.el
(defvar ob-async-inject-variables-exclude "-overlays"
  "Regex of variables to exclude from injection into the async process.
It's a good idea to exclude any variables that contain overlays.")
#+end_src

We define the execute handler:

#+begin_src elisp :tangle init.el
;;;###autoload
(defun ob-async-org-babel-execute-src-block (&optional orig-fun arg info params)
  "Like org-babel-execute-src-block, but run asynchronously.

Original docstring for org-babel-execute-src-block:

Execute the current source code block.  Insert the results of
execution into the buffer.  Source code execution and the
collection and formatting of results can be controlled through a
variety of header arguments.

With prefix argument ARG, force re-execution even if an existing
result cached in the buffer would otherwise have been returned.

Optionally supply a value for INFO in the form returned by
`org-babel-get-src-block-info'.

Optionally supply a value for PARAMS which will be merged with
the header arguments specified at the front of the source code
block."
  (interactive "P")
  (cond
   ;; If this function is not called as advice, do nothing
   ((not orig-fun)
    (warn "ob-async-org-babel-execute-src-block is no longer needed in org-ctrl-c-ctrl-c-hook")
    nil)
   ;; If there is no :async parameter, call the original function
   ((not (assoc :async (nth 2 (or info (org-babel-get-src-block-info)))))
    (funcall orig-fun arg info params))
   ;; If the src block language is in the list of languages async is not to be
   ;; used for, call the original function
   ((member (nth 0 (or info (org-babel-get-src-block-info)))
            ob-async-no-async-languages-alist)
    (funcall orig-fun arg info params))
   ;; Otherwise, perform asynchronous execution
   (t
    (let ((placeholder (ob-async--generate-uuid)))
      ;; Here begins the original source of org-babel-execute-src-block
      (let* ((org-babel-current-src-block-location
              (or org-babel-current-src-block-location
                  (nth 5 info)
                  (org-babel-where-is-src-block-head)))
             (src-block-marker (save-excursion
                                 (goto-char org-babel-current-src-block-location)
                                 (point-marker)))
             (info (if info (copy-tree info) (org-babel-get-src-block-info))))
        ;; Merge PARAMS with INFO before considering source block
        ;; evaluation since both could disagree.
        (cl-callf org-babel-merge-params (nth 2 info) params)
        (when (org-babel-check-evaluate info)
          (cl-callf org-babel-process-params (nth 2 info))
          (let* ((params (nth 2 info))
                 (cache (let ((c (cdr (assq :cache params))))
                          (and (not arg) c (string= "yes" c))))
                 (new-hash (and cache (org-babel-sha1-hash info)))
                 (old-hash (and cache (org-babel-current-result-hash)))
                 (current-cache (and new-hash (equal new-hash old-hash)))
                 (result-params (cdr (assq :result-params params))))
            (cond
             (current-cache
              (save-excursion		;Return cached result.
                (goto-char (org-babel-where-is-src-block-result nil info))
                (forward-line)
                (skip-chars-forward " \t")
                (let ((result (org-babel-read-result)))
                  (message (replace-regexp-in-string "%" "%%" (format "%S" result)))
                  result)))
             ((org-babel-confirm-evaluate info)
              ;; Insert a GUID as a placeholder in our RESULTS block
              (when (not (or (member "none" result-params)
                             (member "silent" result-params)))
                (org-babel-insert-result placeholder '("replace")))
              (let* ((lang (nth 0 info))
                     ;; Expand noweb references in BODY and remove any
                     ;; coderef.
                     (body
                      (let ((coderef (nth 6 info))
                            (expand
                             (if (org-babel-noweb-p params :eval)
                                 (org-babel-expand-noweb-references info)
                               (nth 1 info))))
                        (if (not coderef) expand
                          (replace-regexp-in-string
                           (org-src-coderef-regexp coderef) "" expand nil nil 1))))
                     (dir (cdr (assq :dir params)))
                     (default-directory
                      (or (and dir (file-name-as-directory (expand-file-name dir)))
                          default-directory))
                     (cmd (intern (concat "org-babel-execute:" lang)))
                     (org-babel-async-content
                      (buffer-substring-no-properties (point-min) (point-max)))
                     result)
                (unless (fboundp cmd)
                  (error "No org-babel-execute function for %s!" lang))
                (message "executing %s code block%s..."
                         (capitalize lang)
                         (let ((name (nth 4 info)))
                           (if name (format " (%s)" name) "")))
                (progn
                  (async-start
                   `(lambda ()
                      ;; TODO: Put this in a function so it can be overidden
                      ;; Initialize the new Emacs process with org-babel functions
                      (setq exec-path ',exec-path)
                      (setq load-path ',load-path)
                      ,(async-inject-variables ob-async-inject-variables nil ob-async-inject-variables-exclude)
                      (package-initialize)
                      (setq ob-async-pre-execute-src-block-hook ',ob-async-pre-execute-src-block-hook)
                      (run-hooks 'ob-async-pre-execute-src-block-hook)
                      (org-babel-do-load-languages 'org-babel-load-languages ',org-babel-load-languages)
                      (let ((default-directory ,default-directory))
                        (with-temp-buffer
                          (insert org-babel-async-content)
                          (,cmd ,body ',params))))
                   `(lambda (result)
                      (with-current-buffer ,(current-buffer)
                        (let ((default-directory ,default-directory))
                          (save-excursion
                            (cond
                             ((member "none" ',result-params)
                              (message "result silenced"))
                             ((member "silent" ',result-params)
                              (message (replace-regexp-in-string "%" "%%" (format "%S" result))))
                             (t
                              (goto-char ,src-block-marker)
                              (let ((file (cdr (assq :file ',params))))
                                (when file
                                  ;; when result type is link, don't write result content to file.
                                  (unless (member "link" ',result-params)
                                    ;; If non-empty result and :file then write to :file.
                                    (when result
                                      (with-temp-file file
                                        (insert (org-babel-format-result
                                                 result (cdr (assq :sep ',params)))))))
                                  (setq result file))
                                ;; Possibly perform post process provided its
                                ;; appropriate.  Dynamically bind "*this*" to the
                                ;; actual results of the block.
                                (let ((post (cdr (assq :post ',params))))
                                  (when post
                                    (let ((*this* (if (not file) result
                                                    (org-babel-result-to-file
                                                     file
                                                     (let ((desc (assq :file-desc ',params)))
                                                       (and desc (or (cdr desc) result)))))))
                                      (setq result (org-babel-ref-resolve post))
                                      (when file
                                        (setq result-params (remove "file" ',result-params))))))
                                (org-babel-insert-result result ',result-params ',info ',new-hash ',lang))))
                            (run-hooks 'org-babel-after-execute-hook)))))))))))))))))
#+end_src

**** DONE Compose PR upstream

See [[https://github.com/astahlman/ob-async/pull/88][PR astahlman/ob-async #88]]

** TODO org-store-link org-mairix-store-gnus links broken

#+begin_center
⚠️ Unclear how to reproduce!
#+end_center

<<cursor>>

#+begin_src text
Debugger entered--Lisp error: (void-function org-mairix-store-gnus-link)
org-mairix-store-gnus-link()
org-store-link(nil 1)
funcall-interactively(org-store-link nil 1)
command-execute(org-store-link record)
execute-extended-command(nil "org-store-link" "org-store-link")
funcall-interactively(execute-extended-command nil "org-store-link" "org-store-link")
command-execute(execute-extended-command)
#+end_src

#+begin_src elisp :results verbatim :wrap src elisp
(org-store-link-functions)
#+end_src

#+RESULTS:
#+begin_src elisp
(org-eww-store-link org-rmail-store-link org-mhe-store-link org-irc-store-link org-info-store-link org-gnus-store-link org-docview-store-link org-bbdb-store-link org-w3m-store-link treemacs-store-org-link org-notmuch-tree-store-link org-notmuch-search-store-link org-notmuch-store-link mu4e-org-store-link org-bibtex-store-link org-link--store-help)
#+end_src

*** What is Mairix

#+begin_quote
mairix is a program for indexing and searching email messages stored in Maildir, MH or mbox folders
#+end_quote

https://github.com/rc0/mairix

** TODO Fix nested code block eldoc recursion issue

When navigating through code blocks inside of Org buffers, we often seem to run into GC issues along with the following errors:

#+begin_src text
eldoc error: (error Lisp nesting exceeds ‘max-lisp-eval-depth’)
#+end_src

Advising =(org-eldoc-documentation-function &rest ARGS)= to skip doc lookup when inside of a code block may be a potential fix here.

* 👁️ Appearance

This section will deal with some of the visual trappings of Emacs. My design goal is to arrive at a rather minimal, or rather clean, design while providing the needed information scope perhaps through toggles (i.e.: showing whitespace characters at command).

** 🙈 Hide GUI Elements

In order to minimize visual noise, let's disable the graphical scroll bars, tool bars and menu bars.

#+begin_src elisp :tangle init.el
;; https://www.emacswiki.org/emacs/ScrollBar
(scroll-bar-mode -1)

;; https://www.emacswiki.org/emacs/ToolBar
(tool-bar-mode -1)

;; https://www.emacswiki.org/emacs/MenuBar
(menu-bar-mode -1)

;; https://www.emacswiki.org/emacs/ShowParenMode
(show-paren-mode 1)
#+end_src

** 🧱 Column Indicator

Display a border at the position to indicate where the right margin is drawn. This should provide authors a sense of where lines should be broken to keep the text relatively readable.

#+begin_src elisp :tangle init.el
;; https://www.emacswiki.org/emacs/FillColumnIndicator
(global-display-fill-column-indicator-mode 1)
#+end_src

#+begin_quote
💡 Even if we have extremely wide displays, reading is a lot easier if the text is width-constrained so do yourself a favor and don't write lines that are painfully long to read.
#+end_quote

** 🏷️ Show Line Numbers

For the sake of ease of navigation and spatial orientation we display line numbers in the left margin.

#+begin_src elisp :tangle init.el
;; https://www.emacswiki.org/emacs/LineNumbers
(global-display-line-numbers-mode 1)
#+end_src

** 🏳️ Whitespace

Visualize white spaces (tabs, spaces, trailing whitespace). The global whitespace mode can be toggled through =(global-whitespace-mode)= in order to reduce the visual noise or enable the whitespace indication.

#+begin_src elisp :tangle init.el
;; https://www.emacswiki.org/emacs/WhiteSpace
;; https://www.emacswiki.org/emacs?action=browse;oldid=WhitespaceMode;id=WhiteSpace
(setq whitespace-style '(empty face lines-tail tabs trailing))

;; http://ergoemacs.org/emacs/whitespace-mode.html
(global-whitespace-mode nil)
#+end_src

** 🎛️ Modeline

The modeline is the bar typically at the bottom of a buffer which provides useful information about the system.

*** WIP <<smart-mode-line>> Smart-mode-line

When switching between different screen configurations, it helps to have the mode-line adapt to the available screen real estate and optimize for readability. This is particularly annoying when I switch to a split-frame layout in which the perspective indicator is out of view.

The [[https://github.com/Malabarba/smart-mode-line][smart-mode-line]] package should improve visbility by truncating certain bits of information based on the available screens space.

#+begin_src elisp :tangle init.el
;; https://github.com/Malabarba/smart-mode-line
(use-package smart-mode-line
  :after
  (:all delight diminish)
  :straight
  (smart-mode-line :type git
                   :host github
                   :repo "Malabarba/smart-mode-line"))
#+end_src

**** TODO Solve mode-line overflow

The current position indicator in [[mode-line]] is not always in view.

This probably has something to do with the manner in which smart-mode-line calculates modeline-width in =sml/generate-minor-modes= when emojis are in play.

*** Delight and Diminish

Since the amount of textual information in the Modeline can get overwhelming at times, we provide horizontally succinct (i.e.: single char) pictographic indicators for the Modeline instead.

#+begin_src elisp :tangle init.el
;; https://git.savannah.nongnu.org/git/delight.git
(use-package delight
  :straight (delight :type git
                     :host nil
                     :repo "https://git.savannah.nongnu.org/git/delight.git")
  :delight
  (auto-revert-mode "♻️")
  (eldoc-mode "el📖")
  (edebug-mode "🐞")
  (global-whitespace-mode)
  (visual-line-mode "🌯")
  (mu4e-main-mode "📫")
  (mu4e-headers-mode "📬")
  (mu4e-view-mode "📧"))

;; https://github.com/myrjola/diminish.el
(use-package diminish
  :straight (diminish :type git
                      :host github
                      :repo "myrjola/diminish.el"))
#+end_src

One can debug the configuration by examining the =minor-mode-alist= variable to verify if the delight/diminish configurations are correctly applied to the configuration variable.

** 🔤 Text

*** Visual Fill Column

For the sake of readability, it helps to wrap text at a fixed column instead of filling up whatever screen real estate that is available to a buffer. The [[https://github.com/joostkremers/visual-fill-column][visual-fill-column]] package by Joost Kremers accomplishes just this and can be toggled by running ~(visual-fill-column-mode)~.

#+begin_src elisp :tangle init.el
;; https://github.com/joostkremers/visual-fill-column
(use-package visual-fill-column
  :straight (visual-fill-column :type git
                                :host github
                                :repo "joostkremers/visual-fill-column"))
#+end_src

#+CAPTION: Demonstration of toggling visual-fill-column mode
[[file:images/demonstration-visual-fill-column.gif]]

**** Global binding for convenience

For convenience, I have defined the following global binding to facilitate my laziness and avoid having to enter =visual-fill-column-mode= which isn't as much of a pain to begin with TBH if you consider that there is completion within Emacs. 🤷🏿‍♂️

#+begin_src elisp
(global-set-key (kbd "C-c v \\") 'visual-fill-column-mode)
#+end_src

*** Adaptive Wrap

By using [[https://elpa.gnu.org/packages/adaptive-wrap.html][adaptive wrap]] mode, wrapping behaviour can be adapted to respect indentation present at the start of a line. This should simply the readability of long lines in e-mail quotes or in nested code.

#+begin_src elisp :tangle init.el
;; https://elpa.gnu.org/packages/adaptive-wrap.html
(use-package adaptive-wrap
  :straight (adaptive-wrap :type git
                           :host github
                           :repo "emacs-straight/adaptive-wrap")
  :config
  (adaptive-wrap-prefix-mode))
#+end_src

Using adaptive wrapping along with visual-fill-column mode may introduce some performance issues especially when longer texts are being soft-wrapped. When dealing with code blocks or tables, adaptie wrapping can be a bit more confusing than helpful which is why it helps to define key bindings to simplify toggling this behaviour. In my case, I have defined the =vidbina/wrap= function to play to control =visual-line-mode= and =adaptive-wrap-mode= in a single operation.

*** Default Text Scale

For global text scaling, the [[https://github.com/purcell/default-text-scale][default-text-scale]] package can be used. Without this package, scaling may require one to resize the text in every buffer independently which is an arduous task.

#+begin_src elisp :tangle init.el
;; https://github.com/purcell/default-text-scale
;; Doesn't work well in emacsclient
(use-package default-text-scale
  :straight (default-text-scale :type git
                                :host github
                                :repo "purcell/default-text-scale")
  :hook ((after-init . default-text-scale-mode)))
#+end_src

The package sets the height attribute of the default face, which can be retrieved by the following code:

#+begin_src elisp
(face-attribute 'default :height)
#+end_src

In my configuration, I have updated the height of the default face through the =customize-face= interface (see [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Specific-Customization.html][Customizing Specific Items]] for more instruction on how to customize faces in Emacs) and applied and saved these changes to allow different machines/environments to load their customization that don't make much sense tracking in git (see the section on our [[*Customizations][custom.el file]] which allows for this).

⚠️ When updating the font face through the =customize-face= interface see to it that you uncheck all non-height attributes to ensure that the customization written into custom.el only sets height information as in the snippet example below:

#+begin_src elisp
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(default ((t (:height 241)))))
#+end_src

**** TODO Investigate if the =server-after-make-frame-hook= is a sane configuration option

The call to =default-text-scale-reset= has been configured in the =server-after-make-frame-hook= since I was having some trouble using this package when using Emacs in client/server mode as opposed to standalone mode.

I don't quite use Emacs in standalone mode anymore, unless I'm debugging my config (by invoking =emacs --debug-init=), but AFAIK, the =server-after-make-frame-hook= was necessary to ensure that =default-text-scale-reset= is only called once the a GUI frame is ready, thus allowing default-text-scale to calculculate text scale.

Note that =default-text-scale--update-for-new-frame= is called in =after-make-frame-functions=, so perhaps this is already sufficient to ensure that all frames have the same scaling for text.

** 🎨 Rainbow Mode

[[https://github.com/emacsmirror/rainbow-mode][Rainbow mode]] allows the coloring or color codes within buffers such as #ff0000 and #0f0.

#+begin_src elisp :tangle lang.example.el
;; https://github.com/emacsmirror/rainbow-mode
(use-package rainbow-mode
  :straight (rainbow-mode :type git
                          :host github
                          :repo "emacsmirror/rainbow-mode"))
#+end_src

** 💄 Themes

*** COMMENT Leuven Theme

#+begin_src elisp :tangle init.el
;; https://github.com/fniessen/emacs-leuven-theme
(use-package leuven-theme
  :straight (leuven-theme :type git
                          :host github
                          :repo "fniessen/emacs-leuven-theme"))
#+end_src

*** Modus Themes

In order to avoid overthinking themes, I've opted for Prot's [[https://gitlab.com/protesilaos/modus-themes][Modus themes]] which offers a highly readable color scheme from an accessibility perspective.

#+CAPTION: Screenshot of this Emacs configuration in dark-mode
[[file:images/screenshot-README-dark.png]]

#+CAPTION: Screenshot of this Emacs configuration in light-mode
[[file:images/screenshot-README-light.png]]

#+begin_src elisp :tangle init.el
;; https://gitlab.com/protesilaos/modus-themes
(use-package modus-themes
  :straight (modus-themes :type git
                          :host gitlab
                          :repo "protesilaos/modus-themes")
  :config
  (modus-themes-load-themes)
  :init
  (setq modus-themes-bold-constructs t
        modus-themes-org-blocks 'gray-background
        modus-themes-region '(bg-only no-extend accented)
        modus-themes-prompts '(intense)
        modus-themes-fringes '(intense)
        modus-themes-hl-line '(accented)
        modus-themes-paren-match '(bold intense)
        modus-themes-syntax '(yellow-comments green-strings alt-syntax)
        modus-themes-headings '((1 . (background overline))
                                (2 . (background overline rainbow))
                                (t . (background overline rainbow)))
        modus-themes-scale-headings t))
#+end_src

** Dired-k

The standard Emacs directory editor named dired doesn't ship with convenient highlighting or coloring of the listed files. The dired-k package adds some flair to the dired ouput.

#+begin_src elisp :tangle init.el
;; https://github.com/emacsorphanage/dired-k
(use-package dired-k
  :straight (dired-k :type git
                     :host github
                     :repo "emacsorphanage/dired-k")
  :init
  (setq dired-k-style 'git)
  :hook (dired-initial-position-hook . dired-k))
#+end_src

* 🌷 Misc

** 🪟 Windows

*** 🏗️ Buffer Placement

#+begin_src elisp :tangle init.el
(setq display-buffer-alist
      (let* ((sidebar-width '(window-width . 85))
             (sidebar-parameters '(window-parameters . ((no-other-window . t))))
             (sidebar (list '(side . left) sidebar-width sidebar-parameters)))
        (list (cons (regexp-opt-group '("*org-roam*"))
                    (cons #'display-buffer-in-side-window
                          `((slot . 0) ,@sidebar)))
              (cons (regexp-opt-group '("*Dictionary*"))
                    (cons #'display-buffer-in-side-window
                          `((slot . -1) ,@sidebar)))
              (cons (regexp-opt-group '("*Help*" "*Info*" "*info*"))
                    (cons #'display-buffer-in-side-window
                          `((slot . 5) ,@sidebar)))
              (cons (regexp-opt-group '("*Shortdoc"))
                    (cons #'display-buffer-in-side-window
                          `((slot . 6) ,@sidebar)))
              (cons (regexp-opt-group '("*Warnings*"))
                    (cons #'display-buffer-in-side-window
                          `((slot . 10) ,@sidebar))))))
#+end_src

*** 🔍 <<zoom-window>> Zoom-window: Zoom to a single window

In order to single out a particular window in order to return to the preceding layout shortly thereafter again, one may use the [[https://github.com/emacsorphanage/zoom-window][zoom-window]] package. It's a great way to clear some screen real estate and obtain some focus.

#+begin_src elisp :noweb yes :tangle init.el
;; https://github.com/emacsorphanage/zoom-window
(use-package zoom-window
  :straight (zoom-window :type git
                         :host github
                         :repo "emacsorphanage/zoom-window")
  :init
  (message "Configuring ‘zoom-window’")
  <<zoom-window-init>>)
#+end_src

*** 🪄 Ace Window

In order to quickly jump between windows by numbers, we can use the [[https://github.com/abo-abo/ace-window][ace-window]] package. This eliminates the need for the tedious next/previous window bindings (either native Emacs or evil).

#+begin_src elisp :tangle init.el
;; https://github.com/abo-abo/ace-window
;; https://jao.io/blog/2020-05-12-ace-window.html
(use-package ace-window
  :straight (ace-window :type git
                        :host github
                        :repo "abo-abo/ace-window")
  :bind (("M-o" . ace-window)))
#+end_src

**** TODO Debug hangin =M-o= call on function =null= help page

When the help page for function =null= is open, the =M-o= binding just ends up hanging up Emacs *sometimes*. Can't reproduce it yet. 😭

#+begin_src elisp
(describe-function #'null)
#+end_src

#+RESULTS:
#+begin_example
null is a built-in function in ‘C source code’.

(null OBJECT)

Return t if OBJECT is nil, and return nil otherwise.

  Other relevant functions are documented in the list group.
  Probably introduced at or before Emacs version 1.9.
  This function does not change global state, including the match data.

#+end_example

***** Profiler output from the =null= help page

****** Memory

#+begin_src text
  1,362,566,599  99% - command-execute
  1,359,050,303  99%  - funcall-interactively
  1,355,593,128  99%   - ace-window
  1,355,593,128  99%    - ace-select-window
  1,355,593,128  99%     - aw-select
  1,355,592,072  99%      - avy-read
         22,136   0%       - aw--lead-overlay
          6,336   0%        + #<compiled 0x21abf780a0956>
          6,136   0%          aw--point-visible-p
          5,280   0%        - aw--overlay-str
          2,112   0%         - select-window
          2,112   0%          - apply
          2,112   0%             ad-Advice-select-window
          2,112   0%         + #<compiled 0x21a7852646156>
          4,224   0%        - select-window
          4,224   0%         - apply
          4,224   0%            ad-Advice-select-window
      3,457,175   0%   + execute-extended-command
      3,515,240   0%  + byte-code
        249,481   0% + timer-event-handler
         47,172   0% + redisplay_internal (C function)
             24   0% + eldoc-schedule-timer
             21   0% + #<compiled 0xdb7dccf4d947c67>
              0   0%   ...
#+end_src

****** CPU

#+begin_src text
        6135  59% - ...
        6135  59%    Automatic GC
        3875  37% + command-execute
         285   2% + timer-event-handler
           1   0%   redisplay_internal (C function)
#+end_src

***** Profiler output from when trying to window switch with =persp-string-match-p= help page open

****** Memory

#+begin_src text
     11,653,264  97% - command-execute
      7,258,981  60%  - byte-code
      7,258,938  60%   - read-extended-command
      7,258,938  60%    - completing-read-default
      7,258,938  60%     - apply
      7,257,882  60%      - vertico--advice
      7,177,718  60%       + #<subr completing-read-default>
      4,394,283  36%  - funcall-interactively
      3,697,527  31%   - execute-extended-command
      3,697,431  31%    - command-execute
      3,697,415  31%     - funcall-interactively
            631   0%      - profiler-start
            631   0%         apply
             96   0%    + run-at-time
        694,580   5%   + ace-window
          2,112   0%   + digit-argument
        131,812   1% + redisplay_internal (C function)
         86,886   0% + timer-event-handler
         36,345   0% + internal-echo-keystrokes-prefix
          8,184   0%   evil-repeat-pre-hook
          1,098   0% + #<compiled 0xdb7dccf4d947c67>
          1,056   0% + which-key--hide-popup
          1,056   0% + undo-auto--add-boundary
              0   0%   ...
#+end_src

****** CPU

#+begin_src text
        7930  99% - command-execute
        6878  86%  - funcall-interactively
        6873  86%   - ace-window
        6873  86%    - ace-select-window
        6873  86%     - aw-select
        6844  86%      + #<subr F616e6f6e796d6f75732d6c616d626461_anonymous_lambda_26>
          28   0%      + avy-read
           1   0%      + mapcar
           5   0%   + execute-extended-command
        1052  13%  + byte-code
           2   0% + redisplay_internal (C function)
           2   0% + timer-event-handler
           1   0%   evil-esc
           0   0% + ...
#+end_src

***** Profiler output

This run was particularly problematic, as you can tell it has basically consumed a crapload of memory and GC seems to be going wild.

****** Memory

#+begin_src text
  7,441,616,899  99% - command-execute
  7,435,010,443  99%  - funcall-interactively
  7,424,303,916  99%   - ace-window
  7,424,303,916  99%    - ace-select-window
  7,424,303,916  99%     - aw-select
  7,424,302,860  99%      - avy-read
    133,056,380   1%       - aw--lead-overlay
        129,404   0%          aw--point-visible-p
          5,280   0%        + aw--overlay-str
          5,280   0%        + #<compiled 0x47199a3e5d956>
          4,224   0%        + select-window
          1,056   0%        aw--make-backgrounds
      8,762,616   0%   + describe-function
      1,936,327   0%   + execute-extended-command
      5,284,212   0%  + byte-code
      1,321,188   0%  + help-fns--describe-function-or-command-prompt
        130,504   0% + redisplay_internal (C function)
         92,686   0% + timer-event-handler
          5,224   0% + eldoc-schedule-timer
          2,112   0% + jit-lock--antiblink-post-command
          1,098   0% + #<compiled 0xdb7dccf4d947c67>
              0   0%   ...
#+end_src

****** CPU

#+begin_src text
       36661  66% - ...
       36661  66%    Automatic GC
       18178  33% + command-execute
           8   0% + timer-event-handler
           3   0% + redisplay_internal (C function)
#+end_src

*** Avy

In order to speed up text navigation, one can use [[https://github.com/abo-abo/avy][avy]] to produce jump points that one can navigate through single keystrokes.

In order to jump to bind in the snippet below, one can grep for bind which is often fast enough or... one can trigger ~(avy-goto-char)~, type =b= and then observe how the different occurrences of b provide an indication of the character (or sequence of characters) that we need to press to "teleport" to that location.

#+begin_src elisp :tangle init.el
;; https://github.com/abo-abo/avy
(use-package avy
  :straight (avy :type git
                 :host github
                 :repo "abo-abo/avy")
  :bind (("C-:" . avy-goto-char)))
#+end_src

*** Rotate

Akin to rotating layouts in tmux, [[https://github.com/daichirata/emacs-rotate][emacs-rotate]] helps users rotate through layouts in Emacs. This can be handy when you quickly want to change a vertically tiles layout into a horizontally tiled layout.

#+begin_src elisp :tangle init.el
;; https://github.com/daichirata/emacs-rotate
(use-package rotate
  :straight (rotate :type git
                    :host github
                    :repo "daichirata/emacs-rotate"))
#+end_src

** Find File at Point (FFAP)

In order to provide point-specific behavior, we use the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/FFAP.html#index-ffap][FFAP]] package. As an example, the ~(find-file-at-point)~ command will provide custom behavior depending on the type of link it is called over.

#+begin_src elisp :tangle init.el
;; https://www.gnu.org/software/emacs/manual/html_node/emacs/FFAP.html#index-ffap
(ffap-bindings)
#+end_src

** Indentation

Turn of tab-indentation and opt for space-based indentation such that whitespace is a bit more controllable.

#+begin_src elisp :tangle init.el
;; https://www.gnu.org/software/emacs/manual/html_node/eintr/Indent-Tabs-Mode.html
(setq-default indent-tabs-mode nil)
#+end_src

#+begin_quote
⚠️ Not to append to ongoing flame wars: across different editors and viewers (pagers, terminals, etc) the use of spaces is a bit more predictable as a text alignment tool. 🤷🏿‍♂️
#+end_quote

** Scrolling

In order to [[https://www.emacswiki.org/emacs/SmoothScrolling][facilitate smoother scrolling]] than the default i.e.: "when scrolling out of view, scroll such that point is in the middle of the buffer", we set =scroll-conservatively= to allow for more line-by-line scrolling.

#+begin_src elisp :tangle init.el
;; https://www.emacswiki.org/emacs/SmoothScrolling
(setq-default scroll-conservatively 100)
#+end_src

💡 If you want to center the cursor (or point in Emacs vernacular), the ~evil-scroll-line-to-center~ command bound to =z z= is your friend.

** TODO Undo

#+begin_src elisp :tangle init.el
;; https://github.com/emacsmirror/undo-fu
(use-package undo-fu
  :straight (undo-fu :type git
                     :host github
                     :repo "emacsmirror/undo-fu"))
#+end_src

** <<async>> Async

Emacs is single-threaded and this makes sense considering that many packages navigate the live buffers or affect change to these buffers. Just imagine the mess if these packages attempted to conduct these operations on Emacs buffers concurrently. 😧

[[https://github.com/jwiegley/emacs-async][Emacs async]] allows for some async code execution which can come in handy for logic that may otherwise have blocked the Emacs main thread for too long.

#+begin_src elisp :tangle init.el
;; https://github.com/jwiegley/emacs-async
(use-package async
  :straight (async :type git
                   :host github
                   :repo "jwiegley/emacs-async")
  :config
  (async-bytecomp-package-mode 1))
#+end_src

** PROTOTYPE iedit

The =evil-search-forward= (bound to =/=) which triggers =isearch-forward= under the hood allows for the temporary highlighting of entered patterns which can provide awareness of a patterns presence in a buffer but sometimes one just wants to highlight a symbol under point without having to type it in first.

#+begin_src elisp :tangle init.el
;; https://github.com/victorhge/iedit
(use-package iedit
  :straight (iedit :type git
                   :host github
                   :repo "victorhge/iedit"))
#+end_src

Enable the iedit-mode through the =C-;= binding to highlight symbol under point throughout the buffer.

** <<evil>> Evil

In order to save your hand some pain, it may be helpful to use vi-like bindings that keep your hands around the home row more often and minimizes the need for your hands to pull acrobatic maneuvers 🎪 that could incur some strain. I use the [[https://github.com/emacs-evil/evil][extensible vi layer, inconveniently or mischievously abbreviated to Evil]], to help me to vi-bindings while in Emacs.

#+begin_quote
I used Emacs extensively in college and developed a case of the /Emacs pinky/ at the time. That's about the time I switched back to vi/vim and around the end of 2021, I decided to give Emacs another try in combination with Evil-mode which provides me the best of both worlds. 🤯
#+end_quote

Consult the [[https://github.com/noctuid/evil-guide][guide]] for more information on evil. Note that the vi commands started with colon such a =:e=, =:s= and =:g= are mapped through evil-ex (see [[https://gist.github.com/agzam/acd3b5e311f8f7e87e21b550856f65e1][agzam's write up]] on these evil-ex commands for reference).

#+begin_src elisp :tangle init.el
;; https://github.com/emacs-evil/evil
;; https://github.com/noctuid/evil-guide
(use-package evil
  :straight (evil :type git
                  :host github
                  :repo "emacs-evil/evil")
  :after
  undo-fu
  :init
  ;; https://github.com/emacs-evil/evil-collection#installation
  ;; pre-set some evil vars prior to package load
  (setq evil-respect-visual-line-mode t)
  (setq evil-undo-system 'undo-fu)
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
  :config
  (evil-mode t)
  (evil-set-initial-state 'info-mode 'emacs)
  (evil-set-initial-state 'help-mode 'emacs)
  (evil-set-initial-state 'special-mode 'emacs))

;; https://github.com/emacs-evil/evil-collection
(use-package evil-collection
  :straight (evil-collection :type git
                             :host github
                             :repo "emacs-evil/evil-collection")
  :after evil
  :config
  (evil-collection-init)
  :delight
  (evil-collection-unimpaired-mode))
#+end_src

#+begin_center
🚨 *Remember the =C-z= binding to exit the 'emacs state and return to 'normal state.* You may accidentally change =evil-state= (evil states are the equivalent to modes in vim vernacular) to =emacs= which will leave you with really annoying results when attempting to quickly navigate/edit your buffers. I've been cursing often enough thinking that my config was broken 🤬 when I had just accidentally pressed =C-z= and ended up in Emacs state. 🤦🏿‍♂️
#+end_center

*** <<evil-vimish-fold>> Folding in a "vimish" fashion

The [[https://github.com/alexmurray/evil-vimish-fold][evil-vimish-fold]] package does exactly what the name implies and integrates evil and [[vimish-fold]] such that we can fold regions through the [[https://vim.fandom.com/wiki/Folding][vim-like bindings]] with classics such as =z f= to fold, =z o= to open and =z d= to delete.

#+begin_src elisp :tangle init.el
;; https://github.com/alexmurray/evil-vimish-fold
(use-package evil-vimish-fold
  :straight (evil-vimish-fold :type git
                              :host github
                              :repo "alexmurray/evil-vimish-fold")
  :diminish evil-vimish-fold-mode
  :after
  (:all vimish-fold)
  :hook ((prog-mode conf-mode text-mode) . evil-vimish-fold-mode))
#+end_src

** <<vimish-fold>> Folding with vimish-fold

The [[https://github.com/matsievskiysv/vimish-fold][vimish-fold]] package allows us to fold regions in buffers while persisting our folding preferences when we save files.

#+begin_src elisp :tangle init.el
;; https://github.com/matsievskiysv/vimish-fold
(use-package vimish-fold
  :straight (vimish-fold :type git
                         :host github
                         :repo "matsievskiysv/vimish-fold")
  :after evil)
#+end_src

** WIP Annotation

The [[https://github.com/bastibe/annotate.el][annotate.el]] package allows us to annotate code in different projects without affecting those project directories themselves. Think of it as your personal marker/highligher toolbox for source code.

#+begin_src elisp :tangle init.el
;; https://github.com/bastibe/annotate.el
(use-package annotate
  :straight (annotate :type git
                      :host github
                      :repo "bastibe/annotate.el")
  :custom
  (annotate-file-buffer-local nil "Use central annotations file"))
#+end_src

Use =C-c C-a= to *add annotations* and =C-c C-d= to *delete* annotations.

** Version Control

*** TODO Magit: Git Porcelain

#+begin_src elisp :tangle init.el
;; https://github.com/magit/magit.git
(use-package magit
  :straight (magit :type git
                   :host github
                   :repo "magit/magit"))
#+end_src

*** TODO Diff-hl: Diff highlighting in the left gutter of a buffer

#+begin_src elisp :tangle init.el
;; https://github.com/dgutov/diff-hl
(use-package diff-hl
  :straight (diff-hl :type git
                     :host github
                     :repo "dgutov/diff-hl")
  :hook (after-init . global-diff-hl-mode)
  :custom
  (diff-hl-margin-mode t "Use margin mode to clear up the fringe"))
#+end_src

** 📁 Navigation

*** TODO Deft

#+begin_src elisp :tangle init.el
;; https://github.com/jrblevin/deft
(use-package deft
  :straight (deft :type git
                  :host github
                  :repo "jrblevin/deft")
  :after org
  :bind
  ("C-c n d" . deft)
  :custom
  (deft-directory "~/org")
  (deft-extensions '("md" "org"))
  (deft-recursive t)
  (deft-strip-summary-regexp
   (concat "\\("
           "[\n\t]" ;; blank
           "\\|^#\\+[[:alpha:]_]+:.*$" ;; org-mode metadata
           "\\)"))
  (deft-use-filename-as-title t)
  (deft-use-filter-string-for-filename t))
#+end_src

** Completion

*** <<orderless>> Orderless

The [[https://github.com/oantolin/orderless][orderless]] package provides more generous completion resolution by permitting us to:
1. provide partial phrases e.g.: "o i d" to filter for "org-indent-drawer" and
2. enter these parts in any order (hence /orderless/) e.g.: "drawer org" to filter for "org-indent-drawer".

#+begin_src elisp :noweb strip-export :tangle init.el
(use-package orderless
  :straight (orderless :type git
                       :host github
                       :repo "oantolin/orderless")
  <<orderless-ivy>>
  :custom
  (completion-styles '(orderless)))
#+end_src

The following note should help us remember to uncomment the [[orderless-ivy][Ivy integration]] when we are using [[swiper][Swiper]].

#+begin_src elisp :noweb-ref orderless-ivy
;; NOTE: Load Orderless after Swiper when using the Ivy integration
#+end_src

**** COMMENT <<orderless-ivy>> Ivy integration

In case Ivy is being used for completion, we will want to configure orderless to load after Ivy.

#+begin_src elisp :noweb-ref orderless-ivy
:after
(:all swiper)
#+end_src

Furthermore, we want to configure the ivy regex builder to play ball with orderless.

#+begin_src elisp :noweb-ref orderless-ivy
:custom
(ivy-re-builders-alist '((t . orderless-ivy-re-builder)))
#+end_src

*** TODO Marginalia

[[https://github.com/minad/marginalia
][Marginalia]] annotates entries in a completion buffer with additional context.

#+begin_src elisp :tangle init.el
;; Enable richer annotations using the Marginalia package
(use-package marginalia
  :straight (marginalia :type git
                        :host github
                        :repo "minad/marginalia")
  ;; Either bind `marginalia-cycle` globally or only in the minibuffer
  :bind (("M-A" . marginalia-cycle)
         :map minibuffer-local-map
         ("M-A" . marginalia-cycle))

  ;; The :init configuration is always executed (Not lazy!)
  :init

  ;; Must be in the :init section of use-package such that the mode gets
  ;; enabled right away. Note that this forces loading the package.
  (marginalia-mode))
#+end_src

*** Consult

[[https://github.com/minad/consult][Consult]] allows quick-selection from a completion buffer and is compatible with completion systems based around the standard Emacs =completing-read= API.

#+begin_src elisp :noweb yes :tangle init.el
;; https://github.com/minad/consult
(use-package consult
  :straight (consult :type git
                     :host github
                     :repo "minad/consult")
  :bind
  (;; bindings from https://github.com/minad/consult#use-package-example
   <<consult-bindings>>
   )

  :config
  ;; Use `consult-completion-in-region' if Vertico is enabled.
  ;; Otherwise use the default `completion--in-region' function.
  (setq completion-in-region-function
        (lambda (&rest args)
          (apply (if vertico-mode
                     #'consult-completion-in-region
                   #'completion--in-region)
                 args))))
#+end_src

**** TODO Bindings

From the [[https://github.com/minad/consult#use-package-example][example configuration]].

#+begin_src elisp :noweb-ref consult-bindings
;; C-c bindings (mode-specific-map)
("C-c h" . consult-history)
("C-c m" . consult-mode-command)
("C-c k" . consult-kmacro)
#+end_src

#+begin_src elisp :noweb-ref consult-bindings
;; C-x bindings (ctl-x-map)
("C-x M-:" . consult-complex-command)     ; orig. repeat-complex-command
("C-x b"   . consult-buffer)              ; orig. switch-to-buffer
("C-x 4 b" . consult-buffer-other-window) ; orig. switch-to-buffer-other-window
("C-x 5 b" . consult-buffer-other-frame)  ; orig. switch-to-buffer-other-frame
("C-x r b" . consult-bookmark)            ; orig. bookmark-jump
("C-x p b" . consult-project-buffer)      ; orig. project-switch-to-buffer
#+end_src

#+begin_src elisp :noweb-ref consult-bindings
;; Custom M-# bindings for fast register access
("M-#"   . consult-register-load)
("M-'"   . consult-register-store)        ; orig. abbrev-prefix-mark (unrelated)
("C-M-#" . consult-register)
#+end_src

#+begin_src elisp :noweb-ref consult-bindings
;; Other custom bindings
("M-y"      . consult-yank-pop)           ; orig. yank-pop
("<help> a" . consult-apropos)            ; orig. apropos-command
#+end_src

#+begin_src elisp :noweb-ref consult-bindings
;; M-g bindings (goto-map)
("M-g e"   . consult-compile-error)
("M-g f"   . consult-flymake)             ; Alternative: consult-flycheck
("M-g g"   . consult-goto-line)           ; orig. goto-line
("M-g M-g" . consult-goto-line)           ; orig. goto-line
("M-g o"   . consult-outline)             ; Alternative: consult-org-heading
("M-g m"   . consult-mark)
("M-g k"   . consult-global-mark)
("M-g i"   . consult-imenu)
("M-g I"   . consult-imenu-multi)
#+end_src

#+begin_src elisp :noweb-ref consult-bindings
;; M-s bindings (search-map)
("M-s d" . consult-find)
("M-s D" . consult-locate)
("M-s g" . consult-grep)
("M-s G" . consult-git-grep)
("M-s r" . consult-ripgrep)
("M-s l" . consult-line)
("M-s L" . consult-line-multi)
("M-s m" . consult-multi-occur)
("M-s k" . consult-keep-lines)
("M-s u" . consult-focus-lines)
#+end_src

#+begin_src elisp :noweb-ref consult-bindings
;; Isearch integration
("M-s e" . consult-isearch-history)
:map isearch-mode-map
("M-e"   . consult-isearch-history)       ; orig. isearch-edit-string
("M-s e" . consult-isearch-history)       ; orig. isearch-edit-string
("M-s l" . consult-line)                  ; needed by consult-line to detect isearch
("M-s L" . consult-line-multi)            ; needed by consult-line to detect isearch
#+end_src

#+begin_src elisp :noweb-ref consult-bindings
;; Minibuffer history
:map minibuffer-local-map
("M-s" . consult-history)                 ; orig. next-matching-history-element
("M-r" . consult-history)                 ; orig. previous-matching-history-element
#+end_src

*** WIP <<vertico>> Vertico

The [[https://github.com/minad/vertico][vertico]] package provides a lighter completion solution when compared to Helm or Ivy.

#+begin_src elisp :tangle init.el
;; https://github.com/minad/vertico
(use-package vertico
  :straight (vertico :type git
                     :host github
                     :repo "minad/vertico")
  :init
  (vertico-mode)

  :config
  )

;; Persist history over Emacs restarts. Vertico sorts by history position.
(use-package savehist
  :straight (:type built-in)
  :init
  (savehist-mode))

;; A few more useful configurations...
(use-package emacs
  :straight (:type built-in)
  :init
  ;; Add prompt indicator to `completing-read-multiple'.
  ;; Alternatively try `consult-completing-read-multiple'.
  (defun crm-indicator (args)
    (cons (concat "[CRM] " (car args)) (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))

  ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
  ;; Vertico commands are hidden in normal buffers.
  (setq read-extended-command-predicate
        #'command-completion-default-include-p)

  ;; Enable recursive minibuffers
  (setq enable-recursive-minibuffers t)

  :hook (minibuffer-setup . cursor-intangible-mode))
#+end_src

💡 Remember that non-existing options can be entered using =M RET= instead of =RET= (which is convenient when trying to enter options in finders).

*** COMMENT <<swiper>> Ivy, Swiper and Counsel

The [[https://github.com/abo-abo/swiper][swiper]] package, or rather repository, contains three packages actually being:
- Ivy :: a completion mechanism
- Swiper :: Ivy-enhanced Isearch
- Counsel :: Ivy-enhanced versions of common Emacs commands
  - =counsel-list-processes= :: Ivy-enchanced =list-processes=
  - =counsel-switch-buffer= :: Ivy-enchanced =switch-to-buffer=

#+begin_src elisp :noweb yes :tangle init.el
;; https://github.com/abo-abo/swiper
(use-package swiper
  :straight (swiper :type git
                    :host github
                    :repo "abo-abo/swiper")
  :delight
  (counsel-mode)
  (ivy-mode)
  :config
  (straight-use-package 'counsel)
  <<ivy-config>>
  (setq ivy-use-virtual-buffers t
        enable-recursive-minibuffers t))
#+end_src

Read [[https://oremacs.com/2019/06/27/ivy-directory-improvements/][Ivy usability improvements when dealing with directories]] to get a sense of how the different completion bindings =C-m=, =C-j= and =C-M-j= may work. At the very least just remember that these are the options when you find yourself stuck in an Ivy completion prompt.

**** COMMENT Activate Ivy and Swiper upon load

#+begin_src elisp :noweb-ref ivy-config
;; activate ivy and counsel upon config
(ivy-mode +1)
(counsel-mode +1)
#+end_src

*** Which-key: Show key bindings next to command listing in pop-up

The [[https://github.com/justbur/emacs-which-key][which-key]] package annotes the command listing with the key bindings for the shown commands.

#+CAPTION: Screenshot of which-key diplaying some keybindings to commands listed in an expanded minibuffer in dark-mode
[[file:images/screenshot-which-key-dark.png]]

#+CAPTION: Screenshot of which-key diplaying keybindings to commands listed in an expanded minibuffer in light-mode
[[file:images/screenshot-which-key-light.png]]

#+begin_src elisp :tangle init.el
;; https://github.com/justbur/emacs-which-key
(use-package which-key
  :straight (which-key :type git
                       :host github
                       :repo "justbur/emacs-which-key")
  :delight
  :config
  (which-key-mode))
#+end_src

*** COMMENT Company: Completion framework with pluggable back-ends

The [[https://company-mode.github.io/][company]] completion framework allows for the use of backends such as [[https://github.com/tigersoldier/company-lsp][company-lsp]] (for LSP integration), BBRB, clang, Ispell, Etags, and Gtags. Completions are triggered through the ~(completion-at-point)~ function while the listing is presented in a pop-up or menu near the pointer itself.

#+begin_src elisp :tangle init.el
;; https://company-mode.github.io/
(use-package company
  :straight (company :type git
                     :host github
                     :repo "company-mode/company-mode")
  :config
  (define-key company-mode-map (kbd "TAB") #'company-indent-or-complete-common)
  :hook (after-init . global-company-mode))
#+end_src

In case you are using company, the [[http://company-mode.github.io/manual/Getting-Started.html#Usage-Basics][Usage Basics]] page will provide a good walkthrough of the bindings, notable options being:
- =C-n= and =C-p= to navigate up and down the completions listing

** <<mail>> 📧 Mail

For mail, there are a couple of options within Emacs. First one needs to understand that there are message user agents (MUAs) which are the tool for composing messages, there are some options for these:

- *message-user-agent*, typically the default
- *sendmail-user-agent*
- *mh-e-user-agent*
- *gnus-user-agent*
- *mu4e-user-agent*, in case you're using mu4e

*** <<mu4e>> Mu4e

[[https://www.djcbsoftware.nl/code/mu/mu4e.html][Mu4e]] is Maildir-friendly mail client that uses mu as a backend.

#+begin_src elisp :noweb yes :tangle init.el
;; https://www.djcbsoftware.nl/code/mu/mu4e.html
(use-package mu4e
  :straight (:type built-in)
  :demand t
  :bind (("C-c M 4" . mu4e))
  :hook (
         <<mu4e-hooks>>)
  :config
  <<mu4e-config>>)
#+end_src

For convenience, remember to prefix the update command by entering it as =C-u u= in a *mu4e-main* buffer or by entering =C-u C-c C-u= from the *mu4e-headers* buffer such that the update commands *run in the background*.

**** Config

#+begin_src elisp :noweb-ref mu4e-config
(setq mail-user-agent 'mu4e-user-agent
      mu4e-compose-format-flowed t
      mu4e-contexts `( ,(make-mu4e-context
                         :name "Sample"
                         :enter-func (lambda () (mu4e-message "Into SAMPLE mu4e context"))
                         :leave-func (lambda () (mu4e-message "Out of SAMPLE mu4e context"))
                         :vars '(( user-mail-address . "foo@example.com"))))
      mu4e-context-policy 'always-ask
      mu4e-index-update-in-background t
      mu4e-view-show-addresses t)
#+end_src

***** Indexing

#+begin_src elisp :noweb-ref mu4e-config
;; https://www.djcbsoftware.nl/code/mu/mu4e/Retrieval-and-indexing.html#Speeding-up-indexing
(setq mu4e-index-cleanup t        ; do a full cleanup check
      mu4e-index-lazy-check nil)  ; consider up-to-date dirs
#+end_src

***** Updating

#+begin_src elisp :noweb-ref mu4e-config
;; https://www.djcbsoftware.nl/code/mu/mu4e/Retrieval-and-indexing.html#Example-setup
(setq mu4e-get-mail-command "offlineimap"   ; or fetchmail, or ...
      mu4e-update-interval 300)             ; update every 5 minutes
#+end_src

***** Attach files to mail through Dired

As outlined in the [[https://www.djcbsoftware.nl/code/mu/mu4e/Attaching-files-with-dired.html][mu4e appendix]], we enable the =dired-mode-hook= (see [[https://www.djcbsoftware.nl/code/mu/mu4e/Dired.html][Dired]]) that enables us to use =C-c RET C-a= to attach files to new or existing mu4e emails.

#+begin_src elisp :noweb-ref mu4e-hooks
;; https://www.djcbsoftware.nl/code/mu/mu4e/Dired.html
(dired-mode . turn-on-gnus-dired-mode)
#+end_src

Require =gnus-dired=:

#+begin_src elisp :noweb-ref mu4e-config
;; https://www.djcbsoftware.nl/code/mu/mu4e/Attaching-files-with-dired.html
(require 'gnus-dired)
#+end_src

The original =gnus-dired='s =gnus-dired-mail-buffers= returns
1. all message buffers in case =gnus-dired-mail-mode= is either =message-user-agent= or =gnus-user-agent= (unlikely to be the case for me since I'm using mu4e or notmuch) or
2. a filtered list of buffers that have =mail-mode= as their major mode.

We override it to return a list of buffers that derive =message-mode=.

#+begin_src elisp :noweb-ref mu4e-config
;; make the `gnus-dired-mail-buffers' function also work on
;; message-mode derived modes, such as mu4e-compose-mode
(defun gnus-dired-mail-buffers ()
  "Return a list of active message buffers."
  (let (buffers)
    (save-current-buffer
      (dolist (buffer (buffer-list t))
        (set-buffer buffer)
        (when (and (derived-mode-p 'message-mode)
                   (null message-sent-message-via))
          (push (buffer-name buffer) buffers))))
    (nreverse buffers)))
#+end_src

We set our preferred mail composition package:

#+begin_src elisp :noweb-ref mu4e-config
(setq gnus-dired-mail-mode 'mu4e-user-agent)
#+end_src

**** Figure out indexing shortcut

#+begin_src elisp
(mu4e-context-switch nil nil)
(mu4e-update-index)
(mu4e-update-mail-and-index 'background)
#+end_src

#+RESULTS:

*** PROTOTYPE <<notmuch>> Notmuch
:LOGBOOK:
- State "PROTOTYPE"  from "TODO"       [2022-06-23 Thu 21:51] \\
  with linking in place the setup is more or less prototype-worthy
:END:

- Leo Gaskin's [[https://github.com/leotaku/literate-emacs/blob/master/init.org#notmuch][notmuch config]]
- Mu4e, Gnus and Notmuch comparison thread on [[https://www.reddit.com/r/emacs/comments/ebite6/mu4e_vs_gnus_vs_notmuch_for_emacs_email/][reddit]]
- Jethro Kuan's (author of Org-roam) [[https://github.com/jethrokuan/.emacs.d/blob/master/init.el][notmuch config]]

#+begin_src elisp :tangle init.el
;; https://git.notmuchmail.org/git/notmuch
(use-package notmuch
  :straight (:type built-in)
  :if (executable-find "notmuch")
  :commands (notmuch
             notmuch-tree
             notmuch-search
             notmuch-hello)
  :bind (("C-c M n" . notmuch)
         :map notmuch-search-mode-map
         ("SPC" . vidbina/notmuch-toggle-inbox))
  :init
  (evil-collection-notmuch-setup)
  :hook (notmuch-hello-mode . (lambda () (display-line-numbers-mode 0)))
  :custom
  (mail-envelope-from 'header)
  (mail-specify-envelope-from t)
  (message-kill-buffer-on-exit t)
  (message-send-mail-function 'message-send-mail-with-sendmail)
  (message-sendmail-envelope-from 'header)
  (message-sendmail-f-is-evil nil)
  (message-signature #'my/mail-sig)
  (notmuch-always-prompt-for-sender t)
  (notmuch-archive-tags '("-inbox" "-unread"))
  (notmuch-crypto-process-mime t)
  (notmuch-hello-sections '(notmuch-hello-insert-saved-searches))
  (notmuch-labeler-hide-known-labels t)
  (notmuch-message-headers '("Subject" "To" "Cc" "Bcc"))
  (notmuch-search-oldest-first nil)
  (sendmail-program (executable-find "msmtp"))
  :config
  (notmuch-address-harvest)
  (require 'ol-notmuch))
  #+end_src

Notmuch has the following modes:
- *hello* which presents the starting page
- *search* which presents search results to a query
- *tree* which presents a thread and the message hierarchy
- *show* which presents the email

For insight into the evil bindings for notmuch, go have a look at the definition of ~evil-collection-notmuch-setup~ but for convenience, here are some bindings that you will likely rely on quite a bit:
- =cc= or =C= to compose mail with ~notmuch-mua-new-mail~ (like mu4e)
- =cR= reply
- =cf= forward
- === flag
- =+= add tag
- =-= remove tag
- =*= tag all
- =s= search
  - stash search in *search mode*
  - show stash in *show mode*
- =q= bury of kill buffer
- =g?= help or version information at notmuch-hello view
- =p= ~notmuch-show-save-attachments~ (like mu4e)
- =gd= goto address at point

**** WIP Face for "deleted" tag

We can customize the face messages that we want to mark as deleted. The relevant section of my custom.el section at [2022-06-30 Thu 13:52] is displayed below for convenience:

#+begin_src elisp
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(default ((t (:inherit nil :height 203))))
 '(notmuch-tag-deleted ((t (:foreground "#a60000" :inverse-video t :strike-through "#a60000")))))
#+end_src

The =notmuch-tag-deleted= bit is customization of interest and it should be managed through the customization facility in Emacs

** TODO 🕳️ Terminals and Shells 🐚

*** COMMENT vterm

#+begin_src elisp :tangle init.el
(use-package vterm
  :straight (:type built-in))
#+end_src

*** COMMENT multi-vterm

#+begin_src elisp :tangle init.el
(use-package multi-vterm
  :straight (multi-vterm :type git
                         :host github
                         :repo "suonlight/multi-vterm")
  :config
  ;;(add-hook 'vterm-mode-hook
  ;;          (lambda ()
  ;;            (setq-local evil-insert-state-cursor 'box)
  ;;            (evil-insert-state)))
  (define-key vterm-mode-map [return]                      #'vterm-send-return)

  (setq vterm-keymap-exceptions nil)
  (evil-define-key 'insert vterm-mode-map (kbd "C-e")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-f")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-a")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-v")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-b")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-w")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-u")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-d")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-n")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-m")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-p")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-j")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-k")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-r")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-t")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-g")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-c")      #'vterm--self-insert)
  (evil-define-key 'insert vterm-mode-map (kbd "C-SPC")    #'vterm--self-insert)
  (evil-define-key 'normal vterm-mode-map (kbd "C-d")      #'vterm--self-insert)
  (evil-define-key 'normal vterm-mode-map (kbd ",c")       #'multi-vterm)
  (evil-define-key 'normal vterm-mode-map (kbd ",n")       #'multi-vterm-next)
  (evil-define-key 'normal vterm-mode-map (kbd ",p")       #'multi-vterm-prev)
  (evil-define-key 'normal vterm-mode-map (kbd "i")        #'evil-insert-resume)
  (evil-define-key 'normal vterm-mode-map (kbd "o")        #'evil-insert-resume)
  (evil-define-key 'normal vterm-mode-map (kbd "<return>") #'evil-insert-resume))
#+end_src

** 📕 PDF

*** TODO PDF-Tools

#+begin_src elisp :tangle init.el
(use-package pdf-tools
  :straight (:type built-in)
  :config
  (require 'pdf-occur)
  (pdf-tools-install nil t nil nil)
  (setq-default pdf-view-display-size 'fit-width))
#+end_src

** 📑 Project Management

In order to manage projects more conveniently, one can opt for a variety of project management packages. In this section we configure and explain some of the options that I've relied on over time.

*** project.el

First and foremost, project.el (bundled with Emacs) provides some facilities to switch between projects, explore project trees and execute commands (among other features). The project.el bindings are mapped to =C-x p=.

The following links provide some context that can be helpful in helping inform your decision to learn project.el or projectile (or its derivatives):
- [[https://www.reddit.com/r/emacs/comments/nf2k5y/how_does_projectile_compare_to_the_builtin/][How does projectile compare to the built-in project.el? (reddit)]]
- [[https://www.manueluberti.eu/emacs/2020/09/18/project/][It’s never too late (Manuel Uberti)]]

*** Projectile

[[https://github.com/bbatsov/projectile/][Projectile]] simplifies working by projects by providing some bindings that infer their behavior from a project-type. This means that we can remember single bindings expore our project trees as well as triggering [[https://docs.projectile.mx/projectile/projects.html#configure-a-projects-lifecycle-commands][project lifecycle commands]] such as configure, compile and run test, and use these generalizations across projects -- allowing ourselves to forget some project-specific details. 😌

#+begin_src elisp :tangle init.el
;; https://github.com/bbatsov/projectile/
(use-package projectile
  :straight (projectile :type git
                        :host github
                        :repo "bbatsov/projectile")
  :custom
  (projectile-mode-line-prefix "🗄️")
  :hook (after-init . projectile-mode)
  :bind (:map projectile-mode-map
              ("C-x p" . projectile-command-map)))
#+end_src

We configure Projectile by
1. most generally, [[https://docs.projectile.mx/projectile/projects.html#adding-custom-project-types][defining new project types]] or
2. more specifically, populating the .dir-locals.el file with our needed [[https://docs.projectile.mx/projectile/configuration.html][Projectile configuration]] or [[https://docs.projectile.mx/projectile/projects.html#storing-project-settings][project settings]].

We use =C-x p= as the binding prefix projectile deciding to overide the project.el bindings 🙊:
- =C-x p P= to trigger a test command using ~(projectile-test-project ARG)~
- =C-x p L= to trigger a test command using ~(projectile-install-project ARG)~
- =C-x p != to run a one-off shell command using ~(projectile-run-shell-command-in-root)~
- =C-x p x s= run a shell ~(projectile-run-shell)~ (will jump to already running shell unless prefixed)

**** Defining Projectile lifecycle commands dir-locals.el

Look at =projectile-cache-current-file= on tips to implementing file-specific Projectile commands.

The following snippet is a rough example of a Projectile lifecycle command that performs an operation on the currently open file.

#+begin_src elisp
((nil . ((projectile-project-test-cmd . (lambda ()
                                          (shell-command (format "exercism submit %S" (file-truename (buffer-file-name))))
                                          (message "Ran test"))))))
#+end_src

For some reason, changing the .dir-locals.el file requires a reset of the corresponding map which, in the case above, happens to be the =projectile-test-cmd-map=. This hashmap can be reset by navigating to the source where is is defined and reevaluating the defining sexpr.

*** COMMENT <<perspective>> Perspective

The [[https://github.com/nex3/perspective-el][Perspective]] package provides some conveniences to manage different workspaces. I use perspectives to keep buffers and layouts isolated between different contexts e.g.: sometimes projects, sometimes features, sometimes tasks (e.g.: wedding planning notes and emails, 1-on-1 work-related notes and details, notes and buffers on a particular research topic, etc.).

#+begin_src elisp :tangle init.el
;; https://github.com/nex3/perspective-el
(use-package perspective
  :straight (perspective :type git
                         :host github
                         :repo "nex3/perspective-el")
  :bind (("C-x C-b" . persp-ivy-switch-buffer)
         ("C-x k" . persp-kill-buffer*))
  :config
  (message "Configuring ‘perspective’")
  <<perspective-config>>
  :init
  (setq persp-state-default-file "~/.emacs.d/perspective"
        persp-modestring-short t))
#+end_src

*** persp-mode

Unlike Perspective, [[https://github.com/Bad-ptr/persp-mode.el][persp-mode]] allows us to manage /perspectives/ across frames (i.e.: different desktop windows for Emacs). In my usage of Emacs, this was becoming more of a requirement since I often end up opening Emacs frames where I want the convenience of selecting either of the /perspectives/ that have been curated before. The [[https://github.com/nex3/perspective-el#similar-packages][Perspective documentation]] provides a helpful writeup of the alternative solutions available for perspective-management in Emacs which includes persp-mode.

#+begin_src elisp :noweb yes :tangle init.el
;; https://github.com/Bad-ptr/persp-mode.el
(use-package persp-mode
  :straight (persp-mode :type git
                        :host github
                        :repo "Bad-ptr/persp-mode.el")
  :diminish persp-mode
  :config
  (persp-mode t)
  :custom
  <<persp-mode-custom>>)
#+end_src

The use of persp-mode should not be too challenging since it is forked from the trusted and familiar Perspective.

Here are some of the relevant bindings to remember, provided that =persp-keymap-prefix= is set to the default =C-c p=:
- =C-c p s= *switch* to perspective (existing or new)
- =C-c p S= *switch* to perspective in a window
- =C-c p n= *next* perspective
- =C-c p p= *previous* perspective
- =C-c p r= *rename* perspective
- =C-c p w= *write* perspectives to file
- =C-c p l= *load* perspectives from file
- =C-c p o= turn *off* perspective mode
- =C-c p k= kill buffer from perspective
- =C-c p K= *kill* buffer

Killing a buffer through =C-x k= will only kill the buffer if it is only member of the current perspective i.e.: a buffer that is a member of multiple perspectives will only be removed from the current perspective when the ~kill-buffer~ command is invoked.

**** Customizations

Autoloading of perspectives is sometimes quite disruptive, since the binding is as far away as =C-c p l=, we will opt for manually triggering recovery of perspectives from an autosave file.

#+begin_src elisp :noweb-ref persp-mode-custom
(persp-auto-resume-time 0 "Avoid autoloading perspective")
#+end_src

For the sake of clarity, a goofy name is selected for the nil perspective to make sure that it is abundantly clear that we find ourselves in an empty perspective and that we haven't silently ended up in a weird case of nilness.

#+begin_src elisp :noweb-ref persp-mode-custom
(persp-nil-name "unpersp-ed" "Just to be clearer")
#+end_src

#+begin_center
This is mostly BS because "none" is clearly not nil-like but I'm just trynna keep things fun.
#+end_center

***** WIP Expand persp-auto-save filters to filter out magit buffers

Note that variable =persp-save-buffer-functions= (see [[file:straight/repos/persp-mode.el/persp-mode.el::(defcustom persp-save-buffer-functions][source]]) lists some functions that are used as filters to determine which buffers are persisted to the [[file:persp-confs/persp-auto-save][persp-auto-save]] files.

#+begin_src elisp
(list #'(lambda (b)
          (when (persp-buffer-filtered-out-p
                 b persp-filter-save-buffers-functions)
            'skip))
      #'persp-tramp-save-buffer
      #'(lambda (b)
          (when (eq 'dired-mode (buffer-local-value 'major-mode b))
            `(def-buffer ,(buffer-name b)
                         ,(buffer-local-value 'default-directory b)
                         ,(buffer-local-value 'major-mode b))))
      #'(lambda (b)
          `(def-buffer ,(buffer-name b)
                       ,(buffer-file-name b)
                       ,(buffer-local-value 'major-mode b))))
#+end_src

During recovery of perspectives, magit buffers typically show up empty. I should be figuring out how to produce magit buffers in the correct locations but since the usability case for respawning magit views is negligibly small, we will just drop magit buffers from the recovery strategy.

#+begin_src elisp :noweb-ref persp-mode-custom
(persp-filter-save-buffers-functions
 (list #'(lambda (b) (string-prefix-p "*" (buffer-name b)))
       #'(lambda (b) (not (null (string-match-p (rx (seq word-boundary "magit"
                                                         (zero-or-more (seq "-" (one-or-more any))) ":")) (buffer-name b))))))
 "Filter out special and magit buffers from saving")
#+end_src

Eventually we should look at [[https://github.com/Bad-ptr/persp-mode.el#custom-saveload-buffer-function-example][Custom save/load buffer function example]] to define persp save/load handlers for magit.

****** Yak Shaving

The [[file:straight/repos/persp-mode.el/persp-mode.el::(defcustom persp-filter-save-buffers-functions][persp-filter-save-buffers-functions]] by default only covers special buffers, being those that start with a =*=.

The following call effectively returns the first filter from the list of filter functions that matches against a buffer and =nil= when nothing matches. We demonstrate it against the buffer named =*scratch*=:

#+begin_src elisp :results verbatim
(persp-buffer-filtered-out-p "*scratch*" persp-filter-save-buffers-functions)
#+end_src

#+RESULTS:
: (#[257 "\300\301\302!\"\207" [string-prefix-p "*" buffer-name] 5 "
: 
: (fn B)"])

The output above looks a bit warbled up because the original value was compiled but after setting is anew, the lambdas are more clearly distinguishable.

**** Integrate with zoom-window

The [[zoom-window][zoom-window]] package can be configured to work with persp-mode

#+begin_src elisp :noweb-ref zoom-window-init
(with-eval-after-load 'persp-mode
  (message "Configuring ‘zoom-window’ to work with ‘persp-mode’")
  (setq zoom-window-use-persp t))
#+end_src

***** TODO Determine if =:defer= can be used to avoid having to define an =eval-after-load= form

I’m not sure if we can define our =eval-after-load= forms through =:defer= in [[file:straight/repos/use-package/use-package-core.el::`((eval-after-load ',name ',(macroexp-progn body)))))))][use-package-core.el]]) and I don’t have time to think about it at the moment.

**** Integrate with Perspective

The [[perspective][Perspective]] package can be configured to work with persp-mode by loading it within Perspective's config block.

#+begin_src elisp :noweb-ref perspective-config
(persp-mode t)
#+end_src

**** TODO Fix perspective switching bug

Ocassionally, I end up in a situation where my perspectives are all wonky and perspective switching breaks.

The problematic call is the following:

#+begin_src elisp
(persp-frame-switch)
#+end_src

#+begin_quote
Debugger entered--Lisp error: (wrong-number-of-arguments #<subr persp-activate> 2)
persp-activate(#s(perspective :name "conf" :buffers (#<buffer x.nix<dotfiles>> #<buffer x.nix<nixos-configuration>> #<buffer home-linux.nix> #<buffer utils.nix> #<buffer TAGS> #<buffer README.org<emacs>> #<buffer org.el.gz>) :killed (((min-height . 4) (min-width . 20) (min-height-ignore . 3) (min-width-ignore . 6) (min-height-safe . 1) (min-width-safe . 4) (min-pixel-height . 152) (min-pixel-width . 380) (min-pixel-height-ignore . 114) (min-pixel-width-ignore . 114) (min-pixel-height-safe . 38) (min-pixel-width-safe . 76)) hc (pixel-width . 3192) (pixel-height . 1718) (total-width . 168) (total-height . 45) (normal-height . 1.0) (normal-width . 1.0) (combination-limit) (leaf (pixel-width . 1592) (pixel-height . 1718) (total-width . 84) (total-height . 45) (normal-height . 1.0) (normal-width . 0.4987468671679198) (buffer "README.org<emacs>" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 98310) (start . 96955)) (prev-buffers ("x.nix<dotfiles>" 1 205) ("README.org<emacs>" 13189 13895) ("README.org<product>" 1 68) ("README.org<concept-clj-react>" 1 1) ("20210719134552-elisp.org" 42736 44426) ("home-linux.nix" 1 99) ("x.nix<nixos-configuration>" 1 101) ("utils.nix" 1488 2099) ("keyformat.txt" 1 1) ("nix-develop" 1 92) ("magit-diff: dotfiles" 1 1) ("README.backup.md" 1 1) ("20211215130037-typescript.org" 854 1110) ("dotfiles" 1 188) ("20210607090600-gpg.org" 764 1805) ("references.bib" 2079 3109) ("20210319152815-org_mode.org" 1243 1879) ("gnupg-backup" 1 608) ("README.md" 1 1) ("*scratch*" 1 140))) (leaf (last . t) (pixel-width . 1600) (pixel-height . 1718) (total-width . 84) (total-height . 45) (normal-height . 1.0) (normal-width . 0.5012531328320802) (buffer "org.el.gz" (selected) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 197764) (start . 196780)) (prev-buffers ("20210421011345-philipps_byrne_gmbh.org" 183939 220125) ("org.el.gz" 196780 197828) ("magit: dotfiles" 1 1) ("README.org<emacs>" 99856 115471)))) :local-variables nil :last-switch-time nil :created-time nil :window-configuration nil :point-marker 
persp-frame-switch(nil)
funcall-interactively(persp-frame-switch nil)
command-execute(persp-frame-switch)
#+end_quote

The =persp-frame-switch= function should never be called without valid arguments.

The invalid call also happens when calling the ~persp-frame-switch~ interactive command and selecting an option from the completion list that is no longer in memory as evident from the following trace:

#+begin_quote
Debugger entered--Lisp error: (wrong-number-of-arguments #<subr persp-activate> 2)
persp-activate(#s(perspective :name "conf" :buffers (#<buffer x.nix<dotfiles>> #<buffer x.nix<nixos-configuration>> #<buffer home-linux.nix> #<buffer utils.nix> #<buffer TAGS> #<buffer README.org<emacs>> #<buffer org.el.gz>) :killed (((min-height . 4) (min-width . 20) (min-height-ignore . 3) (min-width-ignore . 6) (min-height-safe . 1) (min-width-safe . 4) (min-pixel-height . 152) (min-pixel-width . 380) (min-pixel-height-ignore . 114) (min-pixel-width-ignore . 114) (min-pixel-height-safe . 38) (min-pixel-width-safe . 76)) hc (pixel-width . 3192) (pixel-height . 1718) (total-width . 168) (total-height . 45) (normal-height . 1.0) (normal-width . 1.0) (combination-limit) (leaf (pixel-width . 1592) (pixel-height . 1718) (total-width . 84) (total-height . 45) (normal-height . 1.0) (normal-width . 0.4987468671679198) (buffer "README.org<emacs>" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 98310) (start . 96955)) (prev-buffers ("x.nix<dotfiles>" 1 205) ("README.org<emacs>" 13189 13895) ("README.org<product>" 1 68) ("README.org<concept-clj-react>" 1 1) ("20210719134552-elisp.org" 42736 44426) ("home-linux.nix" 1 99) ("x.nix<nixos-configuration>" 1 101) ("utils.nix" 1488 2099) ("keyformat.txt" 1 1) ("nix-develop" 1 92) ("magit-diff: dotfiles" 1 1) ("README.backup.md" 1 1) ("20211215130037-typescript.org" 854 1110) ("dotfiles" 1 188) ("20210607090600-gpg.org" 764 1805) ("references.bib" 2079 3109) ("20210319152815-org_mode.org" 1243 1879) ("gnupg-backup" 1 608) ("README.md" 1 1) ("*scratch*" 1 140))) (leaf (last . t) (pixel-width . 1600) (pixel-height . 1718) (total-width . 84) (total-height . 45) (normal-height . 1.0) (normal-width . 0.5012531328320802) (buffer "org.el.gz" (selected) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 197764) (start . 196780)) (prev-buffers ("20210421011345-philipps_byrne_gmbh.org" 183939 220125) ("org.el.gz" 196780 197828) ("magit: dotfiles" 1 1) ("README.org<emacs>" 99856 115471)))) :local-variables nil :last-switch-time nil :created-time nil :window-configuration nil :point-marker 
persp-frame-switch(nil)
funcall-interactively(persp-frame-switch nil)
command-execute(persp-frame-switch record)
execute-extended-command(nil "persp-frame-switch" "pers")
funcall-interactively(execute-extended-command nil "persp-frame-switch" "pers")
command-execute(execute-extended-command)
#+end_quote

To debug

- current perspective is
  #+begin_src elisp
(persp-curr)
  #+end_src
  - which seems to now associate all buffers to the "main" perspective 💥
- all names
  #+begin_src elisp
(persp-all-names)
  #+end_src
  - which only shows "main"
  - somehow the completion list presents remembered perspectives 🤷🏿‍♂️
- reload
  #+begin_src elisp
(persp-load-state-from-file)
  #+end_src
  - empty call ~(persp-load-state-from-file)~ fails
    #+begin_quote
    Debugger entered--Lisp error: (wrong-number-of-arguments #<subr persp-add-buffer> 4)
    persp-add-buffer(#<buffer magit: dotfiles> nil nil nil)
    #f(compiled-function (b) #<bytecode -0x142e8783c2428156>)(#<buffer magit: dotfiles>)
    mapc(#f(compiled-function (b) #<bytecode -0x142e8783c2428156>) (#<buffer magit: dotfiles> #<buffer dotfiles> #<buffer gnupg-backup> #<buffer magit-process: gnupg-backup> #<buffer magit-diff: gnupg-backup> #<buffer magit: gnupg-backup> #<buffer magit-process: dotfiles> #<buffer magit-diff: dotfiles>))
    #f(compiled-function (name dbufs dwc &optional dparams weak auto hidden) #<bytecode 0x6af63e4156f816a>)(nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (((min-height . 4) (min-width . 10) (min-height-ignore . 3) (min-width-ignore . 3) (min-height-safe . 1) (min-width-safe . 2) (min-pixel-height . 164) (min-pixel-width . 200) (min-pixel-height-ignore . 123) (min-pixel-width-ignore . 60) (min-pixel-height-safe . 41) (min-pixel-width-safe . 40)) leaf (pixel-width . 3192) (pixel-height . 1715) (total-width . 160) (total-height . 42) (normal-height . 1.0) (normal-width . 1.0) (buffer "*scratch*" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 141) (start . 1)))) (def-params nil) t nil nil)
    apply(#f(compiled-function (name dbufs dwc &optional dparams weak auto hidden) #<bytecode 0x6af63e4156f816a>) (nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (((min-height . 4) (min-width . 10) (min-height-ignore . 3) (min-width-ignore . 3) (min-height-safe . 1) (min-width-safe . 2) (min-pixel-height . 164) (min-pixel-width . 200) (min-pixel-height-ignore . 123) (min-pixel-width-ignore . 60) (min-pixel-height-safe . 41) (min-pixel-width-safe . 40)) leaf (pixel-width . 3192) (pixel-height . 1715) (total-width . 160) (total-height . 42) (normal-height . 1.0) (normal-width . 1.0) (buffer "*scratch*" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 141) (start . 1)))) (def-params nil) t nil nil))
    persp-from-savelist-0((def-persp nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (((min-height . 4) (min-width . 10) (min-height-ignore . 3) (min-width-ignore . 3) (min-height-safe . 1) (min-width-safe . 2) (min-pixel-height . 164) (min-pixel-width . 200) (min-pixel-height-ignore . 123) (min-pixel-width-ignore . 60) (min-pixel-height-safe . 41) (min-pixel-width-safe . 40)) leaf (pixel-width . 3192) (pixel-height . 1715) (total-width . 160) (total-height . 42) (normal-height . 1.0) (normal-width . 1.0) (buffer "*scratch*" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 141) (start . 1)))) (def-params nil) t nil nil) #<hash-table equal 8/10 0x134d42d> nil)
    #f(compiled-function (pd) #<bytecode 0x16dab201fd7eeb63>)((def-persp nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (((min-height . 4) (min-width . 10) (min-height-ignore . 3) (min-width-ignore . 3) (min-height-safe . 1) (min-width-safe . 2) (min-pixel-height . 164) (min-pixel-width . 200) (min-pixel-height-ignore . 123) (min-pixel-width-ignore . 60) (min-pixel-height-safe . 41) (min-pixel-width-safe . 40)) leaf (pixel-width . 3192) (pixel-height . 1715) (total-width . 160) (total-height . 42) (normal-height . 1.0) (normal-width . 1.0) (buffer "*scratch*" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 141) (start . 1)))) (def-params nil) t nil nil))
    persps-from-savelist-0(((def-persp nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (... leaf ... ... ... ... ... ... ...)) (def-params nil) t nil nil) (def-persp "notes" ((def-buffer "20210519191436-management.org" "/home/vidbina/org/roam/business/..." org-mode) (def-buffer "20210719134552-elisp.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "20210319000406-emacs.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "20210607090600-gpg.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "Makefile" "/home/vidbina/src/vidbina/gnupg-..." makefile-gmake-mode) (def-buffer "README.md" nil markdown-mode) (def-buffer "20210319152815-org_mode.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "README.org<gnupg-backup>" "/home/vidbina/src/vidbina/gnupg-..." org-mode) (def-buffer "README.backup.md" "/home/vidbina/src/vidbina/gnupg-..." markdown-mode) (def-buffer "references.bib" "/home/vidbina/org/roam/software/..." bibtex-mode) (def-buffer "keyformat.txt" "/home/vidbina/src/gpg/gnupg/agen..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "conf" ((def-buffer "org.el.gz" "/nix/store/9b2cr2b5ldkclxkiascbs..." emacs-lisp-mode) (def-buffer "README.org<emacs>" "/home/vidbina/src/vidbina/dotfil..." org-mode) (def-buffer "TAGS" "/nix/store/9b2cr2b5ldkclxkiascbs..." tags-table-mode) (def-buffer "utils.nix" "/home/vidbina/src/vidbina/nixos-..." nix-mode) (def-buffer "home-linux.nix" "/home/vidbina/src/vidbina/dotfil..." nix-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "product" ((def-buffer "README.org<product>" "/home/vidbina/src/formation.tool..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "clj-react" ((def-buffer "README.org<concept-clj-react>" "/home/vidbina/src/formation.tool..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "pb" ((def-buffer "20210421011345-philipps_byrne_gm..." "/home/vidbina/org/roam/philipps-..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "js" ((def-buffer "20211215130037-typescript.org" "/home/vidbina/org/roam/software/..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "personal" ((def-buffer "personal.org" "/home/vidbina/org/personal.org" org-mode) (def-buffer "20210918225737-hamburg.org" "/home/vidbina/org/roam/asabina/p..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil)) #<hash-table equal 8/10 0x134d42d> "/home/vidbina/.emacs.d/persp-con..." nil nil)
    persps-from-savelist(((def-persp nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (... leaf ... ... ... ... ... ... ...)) (def-params nil) t nil nil) (def-persp "notes" ((def-buffer "20210519191436-management.org" "/home/vidbina/org/roam/business/..." org-mode) (def-buffer "20210719134552-elisp.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "20210319000406-emacs.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "20210607090600-gpg.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "Makefile" "/home/vidbina/src/vidbina/gnupg-..." makefile-gmake-mode) (def-buffer "README.md" nil markdown-mode) (def-buffer "20210319152815-org_mode.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "README.org<gnupg-backup>" "/home/vidbina/src/vidbina/gnupg-..." org-mode) (def-buffer "README.backup.md" "/home/vidbina/src/vidbina/gnupg-..." markdown-mode) (def-buffer "references.bib" "/home/vidbina/org/roam/software/..." bibtex-mode) (def-buffer "keyformat.txt" "/home/vidbina/src/gpg/gnupg/agen..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "conf" ((def-buffer "org.el.gz" "/nix/store/9b2cr2b5ldkclxkiascbs..." emacs-lisp-mode) (def-buffer "README.org<emacs>" "/home/vidbina/src/vidbina/dotfil..." org-mode) (def-buffer "TAGS" "/nix/store/9b2cr2b5ldkclxkiascbs..." tags-table-mode) (def-buffer "utils.nix" "/home/vidbina/src/vidbina/nixos-..." nix-mode) (def-buffer "home-linux.nix" "/home/vidbina/src/vidbina/dotfil..." nix-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "product" ((def-buffer "README.org<product>" "/home/vidbina/src/formation.tool..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "clj-react" ((def-buffer "README.org<concept-clj-react>" "/home/vidbina/src/formation.tool..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "pb" ((def-buffer "20210421011345-philipps_byrne_gm..." "/home/vidbina/org/roam/philipps-..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "js" ((def-buffer "20211215130037-typescript.org" "/home/vidbina/org/roam/software/..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "personal" ((def-buffer "personal.org" "/home/vidbina/org/personal.org" org-mode) (def-buffer "20210918225737-hamburg.org" "/home/vidbina/org/roam/asabina/p..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil)) #<hash-table equal 8/10 0x134d42d> "/home/vidbina/.emacs.d/persp-con..." nil nil)
    persp-load-state-from-file()
    elisp--eval-last-sexp(nil)
    eval-last-sexp(nil)
    funcall-interactively(eval-last-sexp nil)
    command-execute(eval-last-sexp)
    #+end_quote
  - call with existing file ~(persp-load-state-from-file EXISTING_FILE_PATH)~ also fails
    #+begin_quote
    Debugger entered--Lisp error: (wrong-number-of-arguments #<subr persp-add-buffer> 4)
    persp-add-buffer(#<buffer magit: dotfiles> nil nil nil)
    #f(compiled-function (b) #<bytecode -0x142e8783c2428156>)(#<buffer magit: dotfiles>)
    mapc(#f(compiled-function (b) #<bytecode -0x142e8783c2428156>) (#<buffer magit: dotfiles> #<buffer dotfiles> #<buffer gnupg-backup> #<buffer magit-process: gnupg-backup> #<buffer magit-diff: gnupg-backup> #<buffer magit: gnupg-backup> #<buffer magit-process: dotfiles> #<buffer magit-diff: dotfiles>))
    #f(compiled-function (name dbufs dwc &optional dparams weak auto hidden) #<bytecode 0x6af63e4156f816a>)(nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (((min-height . 4) (min-width . 10) (min-height-ignore . 3) (min-width-ignore . 3) (min-height-safe . 1) (min-width-safe . 2) (min-pixel-height . 164) (min-pixel-width . 200) (min-pixel-height-ignore . 123) (min-pixel-width-ignore . 60) (min-pixel-height-safe . 41) (min-pixel-width-safe . 40)) leaf (pixel-width . 3192) (pixel-height . 1715) (total-width . 160) (total-height . 42) (normal-height . 1.0) (normal-width . 1.0) (buffer "*scratch*" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 141) (start . 1)))) (def-params nil) t nil nil)
    apply(#f(compiled-function (name dbufs dwc &optional dparams weak auto hidden) #<bytecode 0x6af63e4156f816a>) (nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (((min-height . 4) (min-width . 10) (min-height-ignore . 3) (min-width-ignore . 3) (min-height-safe . 1) (min-width-safe . 2) (min-pixel-height . 164) (min-pixel-width . 200) (min-pixel-height-ignore . 123) (min-pixel-width-ignore . 60) (min-pixel-height-safe . 41) (min-pixel-width-safe . 40)) leaf (pixel-width . 3192) (pixel-height . 1715) (total-width . 160) (total-height . 42) (normal-height . 1.0) (normal-width . 1.0) (buffer "*scratch*" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 141) (start . 1)))) (def-params nil) t nil nil))
    persp-from-savelist-0((def-persp nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (((min-height . 4) (min-width . 10) (min-height-ignore . 3) (min-width-ignore . 3) (min-height-safe . 1) (min-width-safe . 2) (min-pixel-height . 164) (min-pixel-width . 200) (min-pixel-height-ignore . 123) (min-pixel-width-ignore . 60) (min-pixel-height-safe . 41) (min-pixel-width-safe . 40)) leaf (pixel-width . 3192) (pixel-height . 1715) (total-width . 160) (total-height . 42) (normal-height . 1.0) (normal-width . 1.0) (buffer "*scratch*" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 141) (start . 1)))) (def-params nil) t nil nil) #<hash-table equal 8/10 0x134d42d> nil)
    #f(compiled-function (pd) #<bytecode 0x49d2498a9f3c07>)((def-persp nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (((min-height . 4) (min-width . 10) (min-height-ignore . 3) (min-width-ignore . 3) (min-height-safe . 1) (min-width-safe . 2) (min-pixel-height . 164) (min-pixel-width . 200) (min-pixel-height-ignore . 123) (min-pixel-width-ignore . 60) (min-pixel-height-safe . 41) (min-pixel-width-safe . 40)) leaf (pixel-width . 3192) (pixel-height . 1715) (total-width . 160) (total-height . 42) (normal-height . 1.0) (normal-width . 1.0) (buffer "*scratch*" (selected . t) (hscroll . 0) (fringes 8 8 nil nil) (margins nil) (scroll-bars nil 0 t nil 0 t nil) (vscroll . 0) (dedicated) (point . 141) (start . 1)))) (def-params nil) t nil nil))
    persps-from-savelist-0(((def-persp nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (... leaf ... ... ... ... ... ... ...)) (def-params nil) t nil nil) (def-persp "notes" ((def-buffer "20210519191436-management.org" "/home/vidbina/org/roam/business/..." org-mode) (def-buffer "20210719134552-elisp.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "20210319000406-emacs.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "20210607090600-gpg.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "Makefile" "/home/vidbina/src/vidbina/gnupg-..." makefile-gmake-mode) (def-buffer "README.md" nil markdown-mode) (def-buffer "20210319152815-org_mode.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "README.org<gnupg-backup>" "/home/vidbina/src/vidbina/gnupg-..." org-mode) (def-buffer "README.backup.md" "/home/vidbina/src/vidbina/gnupg-..." markdown-mode) (def-buffer "references.bib" "/home/vidbina/org/roam/software/..." bibtex-mode) (def-buffer "keyformat.txt" "/home/vidbina/src/gpg/gnupg/agen..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "conf" ((def-buffer "org.el.gz" "/nix/store/9b2cr2b5ldkclxkiascbs..." emacs-lisp-mode) (def-buffer "README.org<emacs>" "/home/vidbina/src/vidbina/dotfil..." org-mode) (def-buffer "TAGS" "/nix/store/9b2cr2b5ldkclxkiascbs..." tags-table-mode) (def-buffer "utils.nix" "/home/vidbina/src/vidbina/nixos-..." nix-mode) (def-buffer "home-linux.nix" "/home/vidbina/src/vidbina/dotfil..." nix-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "product" ((def-buffer "README.org<product>" "/home/vidbina/src/formation.tool..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "clj-react" ((def-buffer "README.org<concept-clj-react>" "/home/vidbina/src/formation.tool..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "pb" ((def-buffer "20210421011345-philipps_byrne_gm..." "/home/vidbina/org/roam/philipps-..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "js" ((def-buffer "20211215130037-typescript.org" "/home/vidbina/org/roam/software/..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "personal" ((def-buffer "personal.org" "/home/vidbina/org/personal.org" org-mode) (def-buffer "20210918225737-hamburg.org" "/home/vidbina/org/roam/asabina/p..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil)) #<hash-table equal 8/10 0x134d42d> "~/.emacs.d/persp-confs/2022.06.0..." nil nil)
    persps-from-savelist(((def-persp nil ((def-buffer "magit: dotfiles" nil magit-status-mode) (def-buffer "dotfiles" "~/src/vidbina/dotfiles/" dired-mode) (def-buffer "gnupg-backup" "~/src/vidbina/gnupg-backup/" dired-mode) (def-buffer "magit-process: gnupg-backup" nil magit-process-mode) (def-buffer "magit-diff: gnupg-backup" nil magit-diff-mode) (def-buffer "magit: gnupg-backup" nil magit-status-mode) (def-buffer "magit-process: dotfiles" nil magit-process-mode) (def-buffer "magit-diff: dotfiles" nil magit-diff-mode)) (def-wconf (... leaf ... ... ... ... ... ... ...)) (def-params nil) t nil nil) (def-persp "notes" ((def-buffer "20210519191436-management.org" "/home/vidbina/org/roam/business/..." org-mode) (def-buffer "20210719134552-elisp.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "20210319000406-emacs.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "20210607090600-gpg.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "Makefile" "/home/vidbina/src/vidbina/gnupg-..." makefile-gmake-mode) (def-buffer "README.md" nil markdown-mode) (def-buffer "20210319152815-org_mode.org" "/home/vidbina/org/roam/software/..." org-mode) (def-buffer "README.org<gnupg-backup>" "/home/vidbina/src/vidbina/gnupg-..." org-mode) (def-buffer "README.backup.md" "/home/vidbina/src/vidbina/gnupg-..." markdown-mode) (def-buffer "references.bib" "/home/vidbina/org/roam/software/..." bibtex-mode) (def-buffer "keyformat.txt" "/home/vidbina/src/gpg/gnupg/agen..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "conf" ((def-buffer "org.el.gz" "/nix/store/9b2cr2b5ldkclxkiascbs..." emacs-lisp-mode) (def-buffer "README.org<emacs>" "/home/vidbina/src/vidbina/dotfil..." org-mode) (def-buffer "TAGS" "/nix/store/9b2cr2b5ldkclxkiascbs..." tags-table-mode) (def-buffer "utils.nix" "/home/vidbina/src/vidbina/nixos-..." nix-mode) (def-buffer "home-linux.nix" "/home/vidbina/src/vidbina/dotfil..." nix-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "product" ((def-buffer "README.org<product>" "/home/vidbina/src/formation.tool..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "clj-react" ((def-buffer "README.org<concept-clj-react>" "/home/vidbina/src/formation.tool..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "pb" ((def-buffer "20210421011345-philipps_byrne_gm..." "/home/vidbina/org/roam/philipps-..." org-mode)) (def-wconf (... hc ... ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "js" ((def-buffer "20211215130037-typescript.org" "/home/vidbina/org/roam/software/..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil) (def-persp "personal" ((def-buffer "personal.org" "/home/vidbina/org/personal.org" org-mode) (def-buffer "20210918225737-hamburg.org" "/home/vidbina/org/roam/asabina/p..." org-mode)) (def-wconf (... leaf ... ... ... ... ... ... ... ...)) (def-params nil) nil nil nil)) #<hash-table equal 8/10 0x134d42d> "~/.emacs.d/persp-confs/2022.06.0..." nil nil)
    persp-load-state-from-file("~/.emacs.d/persp-confs/2022.06.05")
    funcall-interactively(persp-load-state-from-file "~/.emacs.d/persp-confs/2022.06.05")
    command-execute(persp-load-state-from-file)
    #+end_quote
    - new call with valid file as input fails the same way like an empty call
      #+begin_src elisp
(f-file-p "~/.emacs.d/persp-confs/2022.06.05")
(persp-load-state-from-file "~/.emacs.d/persp-confs/2022.06.05")
      #+end_src

* 🏁 Finale

To keep our init as general as possible we store private information and language configurations in separate files since these are inherently personal concerns. This configuration will try to load [[file:lang.el]] and [[file:personal.el]] if these exist.

#+begin_src elisp :tangle init.el
(message "💥 Debug on error is %s" debug-on-error)

(load "~/.emacs.d/lang.el")
(load "~/.emacs.d/personal.el")
#+end_src

** Customizations

Furthermore we load customization since some configurations and changes to our Emacs setup will be persisted through the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Customizations.html][customization system]].

#+begin_src elisp :tangle init.el
;; https://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Customizations.html
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+end_src

* 📛 Personal Details

#+begin_quote
💡 You can copy the content in this section to your own personal.org file in this directory and configure all the =:tangle= arguments to output to =personal.el= to cook up your own personal part of your configuration through literal programming. Remember that you can tangle an Org-file into the resulting code with the ~(org-babel-tangle)~ command (mapped to =C-c C-v t= by default).
#+end_quote

Populate a =personal.el= file which defines your name, your e-mail details and some other /very personal/ configuration bits such as theme customizations or personalized keybindings. Use the following snippet as an example of a configuration that may work.

#+begin_src elisp :tangle personal-example.el
(setq user-full-name "David Asabina"
      inhibit-startup-screen t
      smtpmail-debug-info t
      message-send-mail-function 'message-send-mail-with-sendmail
      frame-title-format '(multiple-frames "%b" ("" "Emacs :: %b")))
#+end_src

** COMMENT Reenable some disabled commands

In order to meet new Emacs users half-way in terms of UX, some features/commands have been [[https://www.emacswiki.org/emacs/DisabledCommands][disabled by default]]. The [[https://www.emacswiki.org/emacs/BasicNarrowing][narrowing]] functionality allows one to narrow a buffer to a subset of it's original content. In Org-mode I often narrow to a chapter (subtree in an Org document) in order to reduce my context a bit (reduce the noise and enhance my focus). So, let's reenable some of the disabled commands needed for narrowing.

#+begin_src elisp :tangle personal-example.el
(put 'narrow-to-region 'disabled nil)
(put 'narrow-to-page 'disabled nil)
#+end_src

** Org-capture Templates

#+begin_src elisp :noweb yes :tangle personal-example.el
(setq org-capture-templates
      (list
       <<my-org-capture-templates>>
       nil))
#+end_src

Because templates expressed as string literals are difficult to read, debug and edit, we opt for a form that more closely represents the visual form that our templates will take on (i.e.: show real whitespacing for structure). The snippets in this section are tangled into real Org files which are referred to when setting =org-capture-template=.

⚠️ Please keep in mind that this section tangles into the absolute the relative path =templates/= which can wreak havoc on your setup if you already have files in that directory that you will need.

#+begin_src org :tangle templates/default.org
,* %^{Title}

Source: %u, %c

%i
#+end_src

Which can be configured using the following template entry:

#+begin_src elisp :noweb-ref my-org-capture-templates
(list "w" "Default Template" 'entry
      '(file+headline "~/org/protocol/capture.org" "Notes")
      `(file ,(expand-file-name "templates/default.org"))
      :empty-lines 1)
#+end_src

**** TODOs

#+begin_src org :tangle templates/todo.org
,* TODO %?

%i

%a
#+end_src

#+begin_src elisp :noweb-ref my-org-capture-templates
(list "t" "Todo" 'entry
      '(file+headline "~/org/todo.org" "Tasks")
      `(file ,(expand-file-name "templates/todo.org")))
#+end_src

**** Links

***** Capture template for a basic Link

For links we define the basic template:

#+begin_src org :tangle templates/link.org
,* TODO Read _%:description_

Source: %:annotation%?
#+end_src

Which we map to =L=:

#+begin_src elisp :noweb-ref my-org-capture-templates
(list "L" "Link Only" 'entry
      '(file+headline "~/org/protocol/capture.org" "Links")
      `(file ,(expand-file-name "templates/link.org"))
      :empty-lines 2)
#+end_src

***** Capture template for Link with Text

For links with additional text we define the template:

#+begin_src org :tangle templates/link-with-text.org
,* TODO Read %^{title}

Source: %:annotation

,#+begin_quote
%i
,#+end_quote%?
#+end_src

which we map to =p=:

#+begin_src elisp :noweb-ref my-org-capture-templates
(list "p" "Link with Selected Text" 'entry
      '(file+headline "~/org/protocol/capture.org" "Links")
      `(file ,(expand-file-name "templates/link-with-text.org"))
      :empty-lines 2)
#+end_src

** Email

*** Citation line

In order to keep things lean, I've defined my own citation line that easy enough to parse as opposed to the default line.

#+begin_src elisp :tangle personal-example.el
(setq message-citation-line-format "On %d.%m.%Y, %f wrote:\n"
      message-citation-line-function #'message-insert-formatted-citation-line)
#+end_src

*** 📧 Mu4e

**** TODO Contexts

In order to get mail to work for multiple mailboxes you will need to configure [[https://www.djcbsoftware.nl/code/mu/mu4e/Contexts.html][mu4e contexts]]. Refer to the [[https://www.djcbsoftware.nl/code/mu/mu4e/Contexts-example.html][examples]] in the documentation for some guidance on how to define contexts.

#+begin_src elisp :tangle personal-example.el
;; TODO fill in the blanks for mu4e-contexts
(setq mu4e-contexts `())
#+end_src

**** COMMENT Signing

#+begin_src elisp :tangle personal-example.el
(add-hook 'mu4e-compose-mode-hook 'mml-secure-sign-pgpmime)
#+end_src

**** COMMENT HTML Mail Escape-hatch

In order to conveniently view HTML mail which may not always be presented in a pleasantly readable manner inside of E-macs, you may appreciate using the escape hatch and viewing such pages in a proper browser. The view-actions menu can be pulled up by executing ~(mu4e-view-action)~ or pressing =A= while in the mu4e mail view.

#+begin_src elisp :tangle personal-example.el
;; https://www.djcbsoftware.nl/code/mu/mu4e/Reading-messages.html
(add-to-list 'mu4e-view-actions
             '("ViewInBrowser" . mu4e-action-view-in-browser) t)
#+end_src

#+begin_quote
💡 Since there is so much trash hidden in HTML mails (e.g.: pixels), I tend to paste (and follow) these links in private, incognito or profile-isolated browser tabs instead. Perhaps something you can consider if you you're not in the mood to be too generous (or nonchalant) with your data.
#+end_quote

*** Notmuch

https://notmuchmail.org/emacstips/

#+begin_src elisp :tangle personal-example.el
(setq notmuch-saved-searches
      '((:name "inbox" :query "tag:inbox" :key "i")
        (:name "unread" :query "tag:unread" :key "u")
        (:name "flagged" :query "tag:flagged" :key "f")
        (:name "sent" :query "tag:sent" :key "t")
        (:name "drafts" :query "tag:draft" :key "d")
        (:name "all mail" :query "*" :key "a")))
#+end_src

#+begin_src elisp
(defun my/mail-sig ()
  "Returns signature based on From field"
  (let ((from-field (message-field-value "From")))
    (message "Trying out signature for %S" from-field)
    (pcase (or from-field "")
      ((pred (vidbina/mail-sig-match "@example.com"))
       (vidbina/mail-sig-file "/home/example/my-example.sig"))
      (_ (format "\n\n-- \nBe kind! 🤗")))))
#+end_src

** 🥳 Personal Helpers

Here be dragons! 🐉 This is my personal collection of helpers that I use for little things like switching themes, managing wrapping inside of buffers, managing opening of URL's and more junk. I will not explain these as these are simple enough and I'm not expecting me needing to explain this to myself or others (you likely will want to write your own).

*** Themes

#+begin_src elisp :tangle personal-example.el
(defcustom vidbina/theme-should-be-dark nil
  "Non-nil means that the theme should be dark"
  :type 'boolean
  :group 'display)

(defun vidbina/theme-switch-to-choice ()
  "Switch to the theme of choice"
  (message "🦋 Switching to vidbina's theme")
  (if vidbina/theme-should-be-dark
      (vidbina/theme-switch-to-dark)
    (vidbina/theme-switch-to-light)))

(defun vidbina/theme-switch-to-dark ()
  "Switch to the dark theme"
  (interactive)
  (modus-themes-load-vivendi)
  (setq org-format-latex-options
        '(:scale 2 :foreground "White" :background "Transparent")
        zoom-window-mode-line-color "DodgerBlue4")
  (message "🌑 Theme is dark")
  (customize-save-variable 'vidbina/theme-should-be-dark t))

(defun vidbina/theme-switch-to-light ()
  "Switch to the light theme"
  (interactive)
  (modus-themes-load-operandi)
  (setq org-format-latex-options
        '(:scale 2 :foreground "Black" :background "Transparent")
        zoom-window-mode-line-color "Gold")
  (message "🌕 Theme is light")
  (customize-save-variable 'vidbina/theme-should-be-dark nil))

(defun vidbina/theme-toggle ()
  "Toggle theme"
  (interactive)
  (if vidbina/theme-should-be-dark
      (vidbina/theme-switch-to-light)
    (vidbina/theme-switch-to-dark)))

(add-hook 'after-init-hook 'vidbina/theme-switch-to-choice)
#+end_src

*** Org-Export

#+begin_src elisp :tangle personal-example.el
(defun vidbina/toggle-local-org-export-use-babel ()
  "Toggle buffer-local org-export-use-babel"
  (interactive)
  (if org-export-use-babel
      (setq-local org-export-use-babel nil)
    (setq-local org-export-use-babel t))
  (message (format "❓ org-export confirm = %s" org-export-use-babel)))

(defun vidbina/toggle-local-org-confirm-babel-evaluate ()
  "Toggle buffer-local org-confirm-babel-evaluate"
  (interactive)
  (if org-confirm-babel-evaluate
      (setq-local org-confirm-babel-evaluate nil)
    (setq-local org-confirm-babel-evaluate t))
  (message (format "☑️ Org Babel confirmation is %s" org-confirm-babel-evaluate)))
#+end_src

*** Wrapping

#+begin_src elisp :tangle personal-example.el
(defun vidbina/wrap ()
  "Toggle wrapping using adaptive-wrap-prefix-mode and visual-line-mode"
  (interactive)
  (let ((vidbina/wrap-set
         (lambda (state)
           (progn
             (if state
                 (progn
                   (visual-line-mode +1)
                   (adaptive-wrap-prefix-mode +1))
               (visual-line-mode -1)
               (adaptive-wrap-prefix-mode -1))
             (setq-local vidbina/wrap--state state)
             (message (format "🎁 state=%s wrap -> %s and line -> %s" state adaptive-wrap-prefix-mode visual-line-mode))))))
    (unless (boundp 'vidbina/wrap--state)
      (setq-local vidbina/wrap--state nil))
    (funcall vidbina/wrap-set (not vidbina/wrap--state))))
#+end_src

#+begin_src elisp :tangle personal-example.el

;; https://stackoverflow.com/questions/12663061/emacs-auto-scrolling-log-buffer
(defun vidbina/tail-buffer ()
  (setq-local window-point-insertion-type t))
#+end_src

*** Web-Browsing

#+begin_src elisp :tangle personal-example.el
(defun vidbina/browse-url-xsel (url &optional ignored)
  (shell-command (format "echo \"%s\" | xsel -ib" url)))

(setq browse-url-browser-function 'vidbina/browse-url-xsel)

(defun vidbina/browse-to-current-file ()
  "Open saved HTML file with default browser"
  (progn
    (when (derived-mode-p 'html-mode)
      (progn
        (message (concat "Browse " buffer-file-name))
        (browse-url (file-truename buffer-file-name))))))

(add-hook 'after-save-hook 'vidbina/browse-to-current-file)
#+end_src

*** Notmuch Inbox Toggler

#+begin_src elisp :tangle personal-example.el
(defun vidbina/notmuch-toggle-inbox ()
  "toggle inbox tag of message"
  (interactive)
  (if (member "inbox" (notmuch-search-get-tags))
      (notmuch-search-tag (list "-inbox"))
    (notmuch-search-tag (list "+inbox"))))

(evil-collection-define-key 'normal 'notmuch-search-mode-map
  "i" 'vidbina/notmuch-toggle-inbox)
#+end_src

*** Mail Signature Helpers

#+begin_src elisp :tangle personal-example.el
(defun vidbina/mail-sig-match (pattern from)
  "Matches From field to a regex"
  (string-match-p pattern from))

(defun vidbina/mail-sig-file (path)
  "Retrieves a signature text by path"
  (format "\n\n-- \n%s" (with-temp-buffer
                          (insert-file-contents path)
                          (buffer-string))))
#+end_src

*** Org-roam UI Navigation

#+begin_src elisp :tangle personal-example.el
(defcustom vidbina/orui-node-zoom-padding 10
  "Padding to pass to org-roam-ui when navigating with vidbia-org-roam-ui-node-zoom"
  :type 'number
  :group 'display)

(defun vidbina/orui-node-zoom-padding-set ()
  "Set the padding for org-roam-ui-node-zoom"
  (interactive)
  (let ((padding (read-number "🔍:" vidbina/orui-node-zoom-padding)))
    (customize-save-variable 'vidbina/orui-node-zoom-padding padding)))

(defun vidbina/orui-node-zoom ()
  "Zoom to org-roam-ui node with custom padding"
  (interactive)
  (let ((id (org-roam-id-at-point))
        (padding vidbina/orui-node-zoom-padding))
    (org-roam-ui-node-zoom id nil padding)
    (message "🕸️ ORUI zoom 🔍 %s to %s" id padding)))
#+end_src

*** Helper for Desktop Entries to handle different MIME types

We can configure [[https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html][desktop entries (freedesktop.org)]] that open URI's in a new frame using the =--create-frame= (shorthand =-c=) argument while also setting the xproperties through =--frame-parameters= (shorthand =-F=) that may aid a window manager in positioning the windows correctly. I learned about defining frame parameters first through a [[https://stackoverflow.com/questions/16012024/using-emacsclient-instead-of-emacs-translating-arguments][StackOverflow thread]] thread. The following snippet provides a demonstration on how to open a frame through the aforementioned parameters:

#+begin_src bash :async
emacsclient -F '((name . "Dired"))' --create-frame -a emacs --eval "(let ((path \"/tmp\")) (delete-other-windows-internal) (message (concat \"Dired will open: \" path)) (dired path) path)"
#+end_src

#+RESULTS:
: /tmp

Note that eval has to be a single expression. In the following example we wrap multiple sexps in a =progn= form to qualify as a single expression:

#+begin_src bash :async
emacsclient -F '((name . "experiment"))' --create-frame -a emacs --eval "(progn (message \"hi there\") (message \"bye\"))"
#+end_src

Considering how verbose the eval value is and how error prone modifying this may be, we define a helper function for simplicity.

When create-frame is set, we create a new frame with =make-frame-command= and then clear that frame from any other windows through the =delete-other-windows-internal= command. This is useful because the creation of a new frame doesn't always yield a "clean frame" and could therefore be rather noisy (as it may display the multiple windows that were in the previously active frame).

#+begin_src elisp :tangle personal-example.el
(defun vidbina-mime-handle--open (window-name func target &optional create-frame)
  "Spawn a new frame with the proper qualities"
  ;;(if create-frame (select-frame (make-frame `((name . ,window-name)))))
  (message (concat "MIME handler opening " target))
  (if create-frame (progn
                     (select-frame (make-frame-command))
                     (delete-other-windows-internal)))
  (funcall func target)
  (message "MIME handler opened: \"%s\" in \"%s\"" target window-name))
#+end_src

The helper can be tested through the snippet below and should be less disruptive when the =create-frame= argument is set since:
1. it opens up a new frame (leaving existing frames as-is)
2. reduces the new frame to a single window where only the opened location is presented (for focus)

#+begin_src elisp
(vidbina-mime-handle--open "Dired" #'dired "/tmp" 'create-frame)
#+end_src

#+begin_quote
⚠️ The setting of the create-frame argument may only be necessary when you are not using the =--create-frame= CLI argument when invoking the =emacsclient= command.
#+end_quote

The defined function can be used inside of a =Exec= key of a [[https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-0.9.5.html
][Desktop entry]] i.e.: a .desktop file.

#+begin_src sh :async :results none
emacsclient -a emacs -F "((name . \"emacs-dired\"))" --eval "(vidbina-mime-handle--open \"Dired\" #'dired \"/tmp\" 'create-frame)"
#+end_src

**** Specialized User-friendly Helpers

Invoking =vidbina-mime-handle--open= through an =Exec= key in a desktop entry gets messy because we're entering a sexp that references function symbols. Just keeping everything escaped correctly is already a non-trivial problem (for me). It gets even worse when trying to formulate such command invocations inside of a declarative Nix-based configuration where we introduce another level of "escaping" special characters. 😭

At some point it becomes too Inception-esque to reasonably assume that future me will be able to use it with relative ease. Specialized helpers are therefore formulated to greatly reduce the complexity of the information to be entered into a /Desktop Entry/'s =Exec= key.

#+begin_src elisp :tangle personal-example.el
(defun vidbina-mime-handle-open-directory (window-name target &optional create-frame)
  "Open a directory in a new frame"
  (vidbina-mime-handle--open window-name #'dired target create-frame))
#+end_src

#+begin_src elisp :tangle personal-example.el
(defun vidbina-mime-handle-open-message-in-mu4e (window-name target &optional create-frame)
  "Open a message in a new frame"
  (vidbina-mime-handle--open window-name #'mu4e target create-frame))
#+end_src

*** Conveniences

**** WIP Store input to kill-ring

Writing to the kill ring is done on a buffer-basis. Sometimes one just want to yank (in vim-lingo) or kill (in Emacs-lingo) a value to the kill-ring for later reference.

#+begin_src elisp :tangle personal-example.el
(defun vidbina/kill (object)
  "Yank object"
  (with-temp-buffer
    (insert object)
    (kill-region (point-min) (point-max))))
#+end_src

**** WIP Open process buffer below active buffer

#+begin_src elisp :tangle personal-example.el
(defun vidbina/open-proc-below (proc)
  "Open proc buffer below the current buffer"
  (save-excursion
    (split-window-below)
    (evil-window-down 1)
    (switch-to-buffer (process-buffer proc))
    (evil-window-up 1)))
#+end_src

**** WIP Remove text properties

#+begin_src elisp :tangle personal-example.el
(defun vidbina/unpropertize (string)
  "Remove the text properties from a string"
  (let* ((s string)
         (start 0)
         (end (length string)))
    (set-text-properties start end nil s)
    s))

(defalias 'vidbina/depropertize 'vidbina/unpropertize)
;; https://nullprogram.com/blog/2019/12/10/
(put 'vidbina/depropertize 'byte-optimizer 'byte-compile-inline-expand)
#+end_src

** TODO Misc

*** Global Keybindings

#+begin_src elisp :tangle personal-example.el
(global-set-key (kbd "C-c v l") 'vidbina/theme-switch-to-light)
(global-set-key (kbd "C-c v d") 'vidbina/theme-switch-to-dark)
(global-set-key (kbd "C-c v TAB") 'vidbina/wrap)
(global-set-key (kbd "C-c v \\") 'visual-fill-column-mode)
(global-set-key (kbd "C-c v SPC") 'global-whitespace-mode)
(global-set-key (kbd "C-c v c") 'completion-at-point)
(global-set-key (kbd "C-c v O") 'vidbina/orui-node-zoom-padding-set)
(global-set-key (kbd "C-c v _") 'vidbina/tail-buffer)
(global-set-key (kbd "C-c v .") 'vidbina/orui-node-zoom)

(global-set-key (kbd "C-c v z") 'zoom-window-zoom)

(global-set-key (kbd "C-c l") 'org-store-link)
(global-set-key (kbd "C-c a") 'org-agenda)
#+end_src

*** Visual Aids

#+begin_src elisp :tangle personal-example.el
(setq fill-column 1)

(setq whitespace-style '(trailing tabs newline tab-mark newline-mark))
#+end_src

*** Org Conveniences

#+begin_src elisp :tangle personal-example.el
;; https://orgmode.org/manual/Handling-Links.html
(setq org-return-follows-link t)

(setq org-log-into-drawer "LOGBOOK")

;; Allow for resizing of images
(setq org-image-actual-width nil)

(setq org-html-head-extra
      "<link rel=\"alternate stylesheet\" type=\"text/css\" href=\"~/org/style.css\" />")
;; https://www.gnu.org/software/emacs/manual/html_node/emacs/Position-Info.html
#+end_src

*** Reload inline images after Org export

#+begin_src elisp :tangle personal-example.el
;; https://joy.pm/post/2017-09-17-a_graphviz_primer/
(defun my/fix-inline-images ()
  (when org-inline-image-overlays
    (org-redisplay-inline-images)))

(add-hook 'org-babel-after-execute-hook 'my/fix-inline-images)
#+end_src

*** <<mode-line>> Customize Mode-line

For additional context, one can display /mode line/ or /header line/ elements along the bottom and top of a window respectively.

#+begin_src elisp :tangle personal-example.el
;; https://www.gnu.org/software/emacs/manual/html_node/elisp/Mode-Line-Variables.html
;; http://emacs-fu.blogspot.com/2011/08/customizing-mode-line.html
(setq-default mode-line-format
              (list "%e"
                    ;; ** when modified
                    ;; -- if not modified
                    ;; %% when read-only
                    ;; %+ read-only but modified
                    mode-line-modified

                    persp-lighter

                    mode-line-frame-identification
                    mode-line-buffer-identification

                    ;; https://evil.readthedocs.io/en/latest/overview.html?highlight=mode-line#modes-and-states
                    ;; <N> normal state
                    ;; <I> insert state
                    ;; <V> visual state
                    ;; <R> replace state
                    ;; <O> operator-pending state
                    ;; <M> motion state
                    ;; <E> emacs state
                    evil-mode-line-tag

                    mode-line-modes
                    (propertize "(%c,%l)%p ")
                    "∎"))
(message "🕹️ Mode-line set")
#+end_src

You can force update the mode line in the =setq= doesn't quite get the job done:

#+begin_src elisp :results none
(force-mode-line-update)
#+end_src

** Security

*** Org-crypt

In order to [[https://orgmode.org/worg/org-tutorials/encrypting-files.html][encrypt entries of Org files]], the package org-crypt needs to be configured.

#+begin_src elisp :tangle personal-example.el
(require 'org-crypt)
(org-crypt-use-before-save-magic)
#+end_src

**** Usage

Usage of org-crypt is as simple as tagging the heading of a section to be encrypted with =:crypt:=. With the =org-crypt-key= variable set to =nil=, symmetric encryption is used. By setting this variable to a string, or by setting the =CRYPTKEY= property as demonstrated below, we can encrypt against a GPG public key of choice.

#+begin_example org
,* For all eyes

This is nothing special

,* For my eyes only :crypt:
:PROPERTIES:
:CRYPTKEY: 0xffffffffffffffffffffffffffffffffffffffff
:END:

This would be encrypted upon safe 😉

,* Local File Variables

Disable auto-save since I'm using crypt in this file.

# Local Variables:
# auto-save-default: nil
# End:
#+end_example

****** TODO Verify if =epa-file-encrypt-to= works as expected

An alternate approach would be to append the =epa-file-encrypt-to= variable to the local variables list. The benefit of this is that one can encrypt a file for multiple recipients. I haven't tested this yet. 🤔

* 💬 Languages

Populate a =lang.el= file which defines all of the major-modes and language-related tooling that are relevant to you. In my case I have simply defined a symlink from [[file:lang.example.el][lang.example.el]] to lang.el. The literal configuration in this section defines my own languages setup. YMMV! 🤷🏿‍♂️

** Natural Language

*** Spell Checking

#+begin_src elisp :tangle lang.example.el
;; https://200ok.ch/posts/2020-08-22_setting_up_spell_checking_with_multiple_dictionaries.html
(with-eval-after-load "ispell"
  (setq ispell-program-name "hunspell")
  ;; Configure German, Swiss German, and two variants of English.
  (setq ispell-dictionary "en_US,de_DE,nl")
  ;; ispell-set-spellchecker-params has to be called
  ;; before ispell-hunspell-add-multi-dic will work
  (ispell-set-spellchecker-params)
  (ispell-hunspell-add-multi-dic ispell-dictionary)
  ;; For saving words to the personal dictionary, don't infer it from
  ;; the locale, otherwise it would save to ~/.hunspell_de_DE.
  (setq ispell-personal-dictionary "~/.hunspell_personal")

  ;; The personal dictionary file has to exist, otherwise hunspell will
  ;; silently not use it.
  (unless (file-exists-p ispell-personal-dictionary)
    (write-region "" nil ispell-personal-dictionary nil 0)))
#+end_src

** Markup Languages

*** COMMENT Org

#+begin_src elisp :tangle lang.example.el
;; https://www.gnu.org/software/emacs/manual/html_node/elisp/Hooks-for-Loading.html
;; https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-gnuplot.html#sec-4
(with-eval-after-load 'org
  (message "Loading org-babel-language mappings")
  (org-babel-do-load-languages 'org-babel-load-languages
                               '((shell . t)
                                 (clojure .  t)
                                 (gnuplot . t)
                                 (haskell . t)
                                 (makefile . t)
                                 ;; (nix . t) ;; TODO: Figure out why broken
                                 (python . t))))
#+end_src

*** Markdown

#+begin_src elisp :tangle lang.example.el
;; https://jblevins.org/projects/markdown-mode/
(use-package markdown-mode
  :straight (markdown-mode :type git
                           :host github
                           :repo "jrblevin/markdown-mode")
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init
  (setq markdown-command "multimarkdown"))
#+end_src

** Serialization Languages/Formats

*** JSON

[[https://github.com/joshwnj/json-mode][JSON-mode]] provides a major-mode and some keybindings to simplify working with JSON.

#+begin_src elisp :tangle lang.example.el
;; https://github.com/joshwnj/json-mode
(use-package json-mode
  :straight (json-mode :type git
                       :host github
                       :repo "joshwnj/json-mode"))
#+end_src

Some of the relevant keybindings are:
- =C-c C-f= format region or buffer with =json-reformat=
- =c-c P= copy path to object at point to the kill ring

**** JSON Reformat

[[https://github.com/gongo/json-reformat][JSON Reformat]] provides convenience helpers to reformat JSON in string or region.

#+begin_src elisp :tangle lang.example.el
;; https://github.com/gongo/json-reformat
(use-package json-reformat
  :straight (json-reformat :type git
                           :host github
                           :repo "gongo/json-reformat")
  :custom
  (json-reformat:indent-width 2 "Keep a short indentation span to simplify reading of deep structures"))
#+end_src

**** JSON Snatcher: Extract Element Paths within a JSON Structure

[[https://github.com/Sterlingg/json-snatcher][JSON Snatcher]] allows extraction of "addresses" or "paths" to an item within a JSON structure i.e.: /snatching/.

#+begin_src elisp :tangle lang.example.el
;; https://github.com/Sterlingg/json-snatcher
(use-package json-snatcher
  :straight (json-snatcher :type git
                           :host github
                           :repo "Sterlingg/json-snatcher"))
#+end_src

*** YAML

#+begin_src elisp :tangle lang.example.el
;; https://github.com/yoshiki/yaml-mode
(use-package yaml-mode
  :straight (yaml-mode :type git
                       :host github
                       :repo "yoshiki/yaml-mode"))
#+end_src

** Viz Languages for graphing, plotting and more

*** PlantUML

#+begin_src elisp :tangle lang.example.el
;; https://github.com/skuro/plantuml-mode
(use-package plantuml-mode
  :straight (plantuml-mode :type git
                           :host github
                           :repo "skuro/plantuml-mode")
  :after org
  :config
  ;; https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-dot.html
  (setq org-plantuml-exec-mode 'plantuml)

  (setq plantuml-default-exec-mode 'executable)
  (org-babel-do-load-languages 'org-babel-load-languages
                               (append org-babel-load-languages
                                       '((plantuml . t)))))
#+end_src

*** Graphviz

#+begin_src elisp :tangle lang.example.el
;; https://github.com/ppareit/graphviz-dot-mode
(use-package graphviz-dot-mode
  :straight (graphviz-dot-mode :type git
                               :host github
                               :repo "ppareit/graphviz-dot-mode")
  :after org
  :config
  (setq graphviz-dot-indent-width 2)
  (org-babel-do-load-languages 'org-babel-load-languages
                               (append org-babel-load-languages
                                       '((dot . t)))))
#+end_src

*** Gnuplot

#+begin_src elisp :tangle lang.example.el
;; https://github.com/emacsorphanage/gnuplot
;; also https://github.com/bruceravel/gnuplot-mode
;; also https://github.com/rudi/gnuplot-el
(use-package gnuplot
  :straight (gnuplot :type git
                     :host github
                     :repo "emacsorphanage/gnuplot")
  :after org
  :config
  (org-babel-do-load-languages 'org-babel-load-languages
                               (append org-babel-load-languages
                                       '((gnuplot . t)))))
#+end_src

** DSL

The selected nomer is a poor choice if you think about it. 🤔 Plotting languages are arguably domain-specific, markup languages are arguably domain specific -- naming is hard. 🤷🏿‍♂️

*** Shell

#+begin_src elisp :tangle lang.example.el
(with-eval-after-load 'org
  (message "Load Shell into Org Babel")
  (org-babel-do-load-languages 'org-babel-load-languages
                               (append org-babel-load-languages
                                       '((shell . t)))))
#+end_src

*** Dockerfile

#+begin_src elisp :tangle lang.example.el
;; https://github.com/spotify/dockerfile-mode
(use-package dockerfile-mode
  :straight (dockerfile-mode :type git
                             :host github
                             :repo "spotify/dockerfile-mode"))
#+end_src

*** Octave

[[https://www.gnu.org/software/emacs/manual/html_mono/octave-mode.html][Octave]] mode provides support for the [[https://www.gnu.org/software/octave/][Octave scientific programming language]] which is a popular FLOSS alternative to Matlab. From a glance at the [[https://github.com/emacs-mirror/emacs/commit/be64c05d81d6191397fa96e050b8b3ad8134b62b][Emacs git history]] it seems that this feature has been bundled in emacs for a while now, so we will simply assume it's here and add the language to the =org-babel-load-languages= list to enable Org Babel exports.

#+begin_src elisp :tangle lang.example.el
(with-eval-after-load 'org
  (message "Load Octave into Org Babel")
  (org-babel-do-load-languages 'org-babel-load-languages
                               (append org-babel-load-languages
                                       '((octave . t)))))
#+end_src

*** Nix

#+begin_src elisp :tangle lang.example.el
;; https://github.com/NixOS/nix-mode
(use-package nix-mode
  :straight (nix-mode :type git
                      :host github
                      :repo "NixOS/nix-mode")
  :init
  (setq nix-nixfmt-bin "nixpkgs-fmt"))
#+end_src

**** WIP Org-babel support for nix shells

It is possible to define shell source blocks that can be evaluated through ob-shell but these environments don't quite seem to be Nix aware. I've explored using the [[envrc][envrc]] package but these only seem to configure a) local buffers exec paths and environment variables and b) command invocations through =shell-command-to-string= neither of which cover configuration of ob-shell invocations.

***** Generate shebang lines for nix shells

In order to use nix shells in literate programs, we need an ability to eval shell code blocks in a Nix-aware manner. The standard shell executor, copies the contents of a code block into the tmp directory and executes it there. Since nix-shells are location dependent (because the shell.nix or any other .nix file in the source directory may be required to adequately run them), we provide a means to define a shebang line for nix-shell runs.

****** PROTOTYPE nix-shell ob-shell shebang generator

Let's define a function to allow us to dynamically generate a valid shebang for shell blocks that will spawn a nix-shell to run the code in.

#+begin_src elisp :tangle personal-example.el :results none
(defun vidbina/ob-shell-nix-shebang (&optional shell-file)
  "Shebang line for a nix-shell environment based on the buffer directory"
  (unless (stringp shell-file) (error "shell-file must be a string"))
  (let ((shell-file (or shell-file "shell.nix"))
        (nix-file (expand-file-name shell-file
                                    (file-name-directory (buffer-file-name)))))
    (format "#!/usr/bin/env nix-shell\n#!nix-shell -i bash %s" nix-file)))
#+end_src

Testing against [[file:../shell.nix]] which should roughly contain a superset of:

#+begin_src nix
# save this as shell.nix
{ pkgs ? import <nixpkgs> {}}:

pkgs.mkShell {
  nativeBuildInputs = [ pkgs.hello ];
}
#+end_src

we can define a shell block with the shebang helper in the following manner to run the code inside of a nix-shell:

#+begin_src org
,#+begin_src bash :shebang (vidbina/ob-shell-nix-shebang) :results verbatim
hello
,#+end_src
#+end_src

which can be executed as follows with the result listed thereafter:

#+begin_src bash :shebang (vidbina/ob-shell-nix-shebang "../shell.nix") :results verbatim
hello
#+end_src

#+RESULTS:
: Hello, world!

The following example should fail because the shebang helper checks that the supplied argument is a valid string that can be expanded into a path:

#+begin_src bash :shebang (vidbina/ob-shell-nix-shebang (list "a")) :results verbatim
hello
#+end_src

****** CANCELED COMMENT nix-develop ob-shell shebang generator
:LOGBOOK:
- State "CANCELED"   from "TODO"       [2022-06-01 Wed 22:54] \\
  Between =nix-shell= and =nix develop=, only =nix-shell= allows usage as a shell interpreter which is why a shebang interpreter line only works for =nix-shell=. Any attempt to achieve the same with =nix develop= is just going to fail, so I'm attempting a comint-based approach instead.
:END:

#+begin_src elisp :tangle personal-example.el :results none
(defun vidbina/ob-shell-nix-develop-shebang ()
  "Shebang line for a nix develop environment based on the buffer directory"
  (let ((nix-directory (file-name-directory (buffer-file-name))))
    (format "#!/usr/bin/env -vS nix develop --inputs-from %s" nix-directory)))
#+end_src

****** References

- https://www.reddit.com/r/NixOS/comments/r15hx4/nix_shell_vs_nix_develop/
- https://blog.ysndr.de/posts/guides/2021-12-01-nix-shells/

***** Define org-babel-execute for nix-develop

****** Background

Refer to [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-shell.html#org9ad9ef2
][Shell Code Blocks in Babel]] for details on how Org-babel executes shell blocks.

:CODESTUDY:
The =org-babel-shell-initialize= function defines specialized ob-execute handlers for every one of the supported shells in =org-babel-shell-names= (of which bash, sh and zsh are members).

#+begin_src elisp :results none
(defun org-babel-shell-initialize ()
  "Define execution functions associated to shell names.
This function has to be called whenever `org-babel-shell-names'
is modified outside the Customize interface."
  (interactive)
  (dolist (name org-babel-shell-names)
    (eval `(defun ,(intern (concat "org-babel-execute:" name))
	       (body params)
	     ,(format "Execute a block of %s commands with Babel." name)
	     (let ((shell-file-name ,name))
	       (org-babel-execute:shell body params))))
    (eval `(defalias ',(intern (concat "org-babel-variable-assignments:" name))
	     'org-babel-variable-assignments:shell
	     ,(format "Return list of %s statements assigning to the block's \
variables."
		      name)))
    (eval `(defvar ,(intern (concat "org-babel-default-header-args:" name)) '()))))
#+end_src

The generalized ob-exec (short form for Org-babel execute 🤦🏿‍♂️) handler =org-babel-execute:shell= is the entrypoint for all shell execution tasks and is called by =org-babel-execute-src-block= which packages like [[ob-async]] retrofit (through the advice facility) to provide async execution capability.

#+begin_src elisp :results none
(defun org-babel-execute:shell (body params)
  "Execute a block of Shell commands with Babel.
This function is called by `org-babel-execute-src-block'."
  (let* ((session (org-babel-sh-initiate-session
		   (cdr (assq :session params))))
	 (stdin (let ((stdin (cdr (assq :stdin params))))
                  (when stdin (org-babel-sh-var-to-string
                               (org-babel-ref-resolve stdin)))))
	 (results-params (cdr (assq :result-params params)))
	 (value-is-exit-status
	  (or (and
	       (equal '("replace") results-params)
	       (not org-babel-shell-results-defaults-to-output))
	      (member "value" results-params)))
	 (cmdline (cdr (assq :cmdline params)))
         (full-body (concat
		     (org-babel-expand-body:generic
		      body params (org-babel-variable-assignments:shell params))
		     (when value-is-exit-status "\necho $?"))))
    (org-babel-reassemble-table
     (org-babel-sh-evaluate session full-body params stdin cmdline)
     (org-babel-pick-name
      (cdr (assq :colname-names params)) (cdr (assq :colnames params)))
     (org-babel-pick-name
      (cdr (assq :rowname-names params)) (cdr (assq :rownames params))))))
#+end_src

The results of the =org-babel-execute:shell= call is a table as indicated by the =org-babel-reassemble-table=.
:END:

Note that the =org-babel-sh-evaluate= function is the main worker we need to pay attention to. It roughly handles 4 cases:
1. when =stdin= or =cmdline= are defined \to external shell script w/ stdin
2. when =session= is defined \to session evaluation
3. if =shebang= is not empty, external shell script w/ or w/o shebang
4. otherwise, ~(org-babel-eval EXEC_FILE BODY)~

#+begin_src elisp :results verbatim
(let ((session-name "*dummy-session*")
      (body "echo hi")
      (params '())
      (stdin nil)
      (cmdline nil))
  (org-babel-sh-initiate-session session-name)
  (org-babel-sh-evaluate session-name body params stdin cmdline))
#+end_src

:CODESTUDY:
:END:

#+begin_src elisp :results output
(org-babel-eval "xargs echo" "hi")
#+end_src

#+RESULTS:

It takes a session that is initiated with "none" by default resulting to:

#+begin_src elisp :results verbatim
(org-babel-sh-initiate-session)
#+end_src

#+RESULTS:
: nil

Initiating a session with a name yields a namesake buffer:

#+begin_src elisp :results verbatim
(org-babel-sh-initiate-session "my-temporary-session")
#+end_src

#+RESULTS:
: #<buffer my-temporary-session>

Note that =params= can be set through code-block headers

#+begin_src bash :session "*my-bash-session*" :results output :output verbatim
echo "hi"
echo "other"
#+end_src

#+RESULTS:
: hi
: other

****** TODO Define nix-develop ob-execute handler

The nix-develop prompt will either default to "> " or the value of the =nixConfig.bash-prompt= attribute.

:BACKGROUND:
The =nixConfig.bash-prompt{,-{prefix,suffix}}= can be defined to specify the =PS1= variable within the /nix develop shell/ and is defined in the [[https://github.com/NixOS/nix/blob/bf89cd95a4af35ab15f7fad3186c8f6190f87c84/src/nix/develop.cc
][nix/src/nix/develop.cc]].
:END:

******* Prompt

We describe our prompt matcher through the following regexp:

#+begin_src elisp :noweb-ref nix-develop-prompt-regexp :results none
"^>\s+"
#+end_src

We verify the previously defined regexp by calling the =re-search-forward=

#+begin_src elisp :noweb yes :results none
(re-search-forward <<nix-develop-prompt-regexp>> nil t)
#+end_src

Execution of the previously listed =re-search-forward= call should move the cursor to the ">   here" line in the following block:

#+begin_quote
>no
...
$ not a valid prompt
>   here
> here too
#+end_quote

Define the previously defined regexp as the default nix-develop prompt:

#+begin_src elisp :noweb yes :noweb-ref nix-develop-mode :results none
(defcustom nix-develop-default-prompt-regexp <<nix-develop-prompt-regexp>>
  "Custom prompt for nix-develop"
  :type 'string
  :group 'nix-develop)

#+end_src

******* Execute Handler

In order to process code blocks through Org-Babel execute, we define a =org-babel-execute= handler.

#+begin_src elisp :noweb-ref nix-develop-ob-execute :results none
(defun org-babel-execute:nix-develop (body params)
  "Execute a block of nix develop commands with Babel."
  (save-window-excursion
    (let* ((shell-buffer (org-babel-sh-initiate-session "*nix-develop*"))
           (prompt-regexp nix-develop-default-prompt-regexp))
      (org-babel-comint-with-output
          (shell-buffer org-babel-sh-eoe-output t body)
        (dolist (line (append (list "nix develop")
                              (split-string (org-trim body) "\n")
                              (list org-babel-sh-eoe-indicator)))
          (insert line)
          (comint-send-input nil t)
          (while (save-excursion
                   (goto-char comint-last-input-end)
                   (not (re-search-forward
                         prompt-regexp nil t)))
            (accept-process-output
             (get-buffer-process (current-buffer)))))))))
#+end_src

****** TODO Define syntax major mode for highlighting

We define sparse keymap:

#+begin_src elisp :noweb-ref nix-develop-mode :results none
(defvar nix-develop-mode-map
  (let ((map (make-sparse-keymap)))
    map))

#+end_src

Define a syntax table that is inherits from =shell-mode= since we're expecting code blocks to only contain shell-like syntax:

#+begin_src elisp :noweb-ref nix-develop-mode :results none
(defvar nix-develop-mode-syntax-table
  (make-syntax-table shell-mode-syntax-table))

#+end_src

Derive a major mode from comint-mode because we want to do the interactive thing:

#+begin_src elisp :noweb-ref nix-develop-mode :results none
(define-derived-mode nix-develop-mode comint-mode "Nix Develop"
  "Major mode for `nix-develop'"
  (setq comint-prompt-regexp nix-develop-default-prompt-regexp))

#+end_src

******* Example: Code blocks of different major-modes

#+begin_src shell :results verbatim
echo "hi"
for i in a b; do testing; done
#+end_src

#+begin_src sh :results verbatim
echo "hi"
for i in a b; do testing; done
#+end_src

#+begin_src nix-develop :results verbatim
echo "hi"
for i in a b; do testing; done
#+end_src

****** Compose nix-develop-mode and ob-execute handler

#+begin_src elisp :noweb yes :tangle lang.example.el :results none
<<nix-develop-mode>>
<<nix-develop-ob-execute>>

(provide 'nix-develop-mode)
#+end_src

***** TODO Prep Reddit question

#+begin_src markdown
I've noticed that calling `define-derived-mode` multiple times and then refreshing syntax highlighing on a code block (by reentering the syntax descriptor) to another buffer to test that mode in a code block doesn't seem to reflect the changes made in the `define-derived-mode` call.

As an example let's define a dummy mode blah and use it in a code block as follows:

```
,#+begin_src blah :results verbatim
echo "hi"
,#+end_src
```

A. Deriving a mode from shell-mode

```
(define-derived-mode blah-mode
  sh-mode "Nix Develop"
  "Major mode for `nix-develop`")
```

B. Deriving a mode from sh-mode

```
(define-derived-mode blah-mode
  emacs-lisp-mode "Nix Develop"
  "Major mode for `nix-develop`")
```

Running A and then opening/reloading the buffer (through `revert-buffer-quick`) and then running B and reloading the buffer again doesn't seem to render different results in the buffer.

When we reload Emacs and run B, the rendering in the source block seems quite different.

```
,#+begin_src blah :results verbatim
echo "hi"
,#+end_src
```
#+end_src

#+begin_src markdown
I am aware that I can define a nix-shell shebang as follows

```shell
#!/usr/bin/env nix-shell
#!nix-shell -i bash /PATH/TO/shell.nix
```

but I am trying to figure out how to spawn a nix shell interpreter in a Flake-based configuration where I may have to use nix-develop
#+end_src

*** Web

#+begin_src elisp :tangle lang.example.el
;; https://github.com/fxbois/web-mode
(use-package web-mode
  :straight (web-mode :type git
                      :host github
                      :repo "fxbois/web-mode"))
#+end_src

**** Vue

#+begin_src elisp :tangle lang.example.el
;; https://github.com/fxbois/web-mode
(use-package web-mode
  :straight (web-mode :type git
                      :host github
                      :repo "fxbois/web-mode"))
#+end_src

** General Purpose Programming Languages

*** Go (Golang)

#+begin_src elisp :tangle lang.example.el
;; https://github.com/dominikh/go-mode.el
(use-package go-mode
  :straight (go-mode :type git
                     :host github
                     :repo "dominikh/go-mode.el"))
#+end_src

*** JavaScript (ECMAScript or ES)

Since JavaScript is everywhere, let's make sure we can at least read it with ease.

#+begin_src elisp :tangle lang.example.el
;; https://github.com/redguardtoo/js-comint
(use-package js-comint
  :straight (js-comint :type git
                       :host github
                       :repo "redguardtoo/js-comint")
  :hook (inferior-js-mode . (lambda ()
                              (add-hook 'comint-output-filter-functions 'js-comint-process-output)))
  :config
  (define-key js-mode-map [remap eval-last-sexp] #'js-comint-send-last-sexp)
  (define-key js-mode-map (kbd "C-c b") 'js-send-buffer))
#+end_src

**** TypeScript

Superset of JavaScript that folks really should be using instead of just vanilla JS but we're not here to judge. 🤷🏿‍♂️

#+begin_src elisp :tangle lang.example.el
;; https://github.com/emacs-typescript/typescript.el
(use-package typescript-mode
  :straight
  (typescript-mode :type git
                   :host github
                   :repo "emacs-typescript/typescript.el"))
#+end_src

*** Java

#+begin_src elisp :tangle lang.example.el
;; https://emacs-lsp.github.io/lsp-java/
(use-package lsp-java
  :straight (lsp-java :type git
                      :host github
                      :repo "emacs-lsp/lsp-java"))
#+end_src

*** Clojure

#+begin_src elisp :noweb yes :tangle lang.example.el
;; https://github.com/clojure-emacs/clojure-mode
(use-package clojure-mode
  :straight (clojure-mode :type git
                          :host github
                          :repo "clojure-emacs/clojure-mode")
  :config
  <<clojure-config>>)
#+end_src

The =ob-clojure= package provides Org-Babel support for Clojure code blocks.

#+begin_src elisp :noweb-ref clojure-config
(require 'ob-clojure)
#+end_src

Refer to the [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-clojure.html][Org-babel-clojure documentation]] for instructions on how to install your environment to use Clojure with Emacs.

**** CIDER

#+begin_src elisp :tangle lang.example.el
;; https://github.com/clojure-emacs/cider
(use-package cider
  :straight (cider :type git
                   :host github
                   :repo "clojure-emacs/cider")
  :config
  (setq org-babel-clojure-backend 'cider
        cider-lein-parameters "with-profile -user repl :headless :host localhost"))
#+end_src

*** Kotlin

#+begin_src elisp :tangle lang.example.el
;; https://github.com/Emacs-Kotlin-Mode-Maintainers/kotlin-mode
(use-package kotlin-mode
  :straight (kotlin-mode :type git
                         :host github
                         :repo "Emacs-Kotlin-Mode-Maintainers/kotlin-mode"))
#+end_src

*** Swift

#+begin_src elisp :tangle lang.example.el
;; https://github.com/swift-emacs/swift-mode
(use-package swift-mode
  :straight (swift-mode :type git
                        :host github
                        :repo "swift-emacs/swift-mode"))
#+end_src

*** Haskell

In order to conveniently read and write Haskell, I rely on [[https://github.com/haskell/haskell-mode][haskell-mode]]. Note that [[https://gitlab.com/tseenshe/haskell-tng.el][haskell-tng]] is a fork from haskell-mode that may be worth looking into in your case. read the [[http://haskell.github.io/haskell-mode/manual/latest/][manual]] for more information.

In order to configure interactive mode, we follow the [[https://haskell.github.io/haskell-mode/manual/latest/Interactive-Haskell.html#Customizations][setup instructions from the manual]].

#+begin_src elisp :tangle lang.example.el
;; https://github.com/haskell/haskell-mode
(use-package haskell-mode
  :straight (haskell-mode :type git
                          :host github
                          :repo "haskell/haskell-mode")
  :config
  (require 'haskell-interactive-mode)
  (require 'haskell-process)
  :hook ((haskell-mode . haskell-unicode-input-method-enable)
         (haskell-mode . interactive-haskell-mode))
  :custom
  (haskell-process-suggest-remove-import-lines t)
  (haskell-process-auto-import-loaded-modules t)
  (haskell-process-log t)
  (haskell-stylish-on-save t))
#+end_src

Please note that [[https://wiki.haskell.org/GHC/GHCi][GHCi]], [[https://github.com/ndmitchell/hlint][HLint]] and [[https://github.com/haskell/stylish-haskell][stylish-haskell]] are needed for this configuration to work.

**** Haskell Environment Configuration in Nix

For convenience, I use direnv to manage my environments. Considering that I am a Nix user and the configuration described above needs GHCi, Hlint and stylish-haskell installed, I just have to see to it that a project directory tree contains an .envrc file that contains the =use nix= string to relegate env configuration to the nix configuration and then populate default.nix to contain description of the needed environment.

So, =.envrc= should contain the following:

#+begin_src conf
use nix
#+end_src

and my =default.nix= file will contain something to the tune of the snippet below.

#+begin_src nix
{ sources ? import ./nix/sources.nix }:

let
  nixpkgs = import sources.nixpkgs {};
in
nixpkgs.mkShell {
  buildInputs = with nixpkgs.haskellPackages; [
    ghci
    hlint
    stylish-haskell
  ];
}
#+end_src

To add another layer of convenience or complexity, depending on how you want to look at it 🤷🏿‍♂️, I manage my nix packages with [[https://github.com/nmattia/niv][niv]] in order to decouple the project packages from my system configuration (i.e.: every project installs packages in reference to a pinned package repository that remains the same even if the system repository changes over time which improves reproducability). This is where the =./nix/sources.nix= bit comes into the picture -- that's a niv thing. In order to populate the =nix/sources.nix= and =nix/sources.json= files that nix needs, I have to run =niv init= inside of the directory where the default.nix resides. After all of this is done, we have to allow direnv to evaluate the files within the directory to autoload our environment. I sometimes do this within emacs with ~(envrc-allow)~ but you can also do this from a terminal with the command =direnv allow=.

*** Elm

#+begin_src elisp :tangle lang.example.el
;; https://github.com/jcollard/elm-mode
(use-package elm-mode
  :straight (elm-mode :type git
                      :host github
                      :repo "jcollard/elm-mode"))
#+end_src

** Misc

*** 🌈 Rainbow Delimiters

#+begin_src elisp :tangle lang.example.el
;; https://github.com/Fanael/rainbow-delimiters
(use-package rainbow-delimiters
  :straight (rainbow-delimiters :type git
                                :host github
                                :repo "Fanael/rainbow-delimiters")
  :hook ((emacs-lisp-mode . rainbow-delimiters-mode)
         (prog-mode . rainbow-delimiters-mode))

  ;; ;; https://github.com/patrickt/emacs
  ;; ((prog-mode) . rainbow-delimiters-mode)
  )
#+end_src

*** <<paredit>> Paredit

In order to simplify editing LISPs, [[https://github.com/emacsmirror/paredit][paredit]] can be used to assist in keeping forms balanced (i.e.: ensuring that a form always has as many opening as closing parenthesis).

#+begin_src elisp :noweb yes :tangle lang.example.el
;; https://github.com/emacsmirror/paredit
(use-package paredit
  :straight (paredit :type git
                     :host github
                     :repo "emacsmirror/paredit")
  <<paredit-config>>)
#+end_src

**** Set lighter

#+begin_src elisp :noweb-ref paredit-config
:delight
(paredit-mode "🛝")
#+end_src

**** Set global binding

Enable paredit mode using the =C-c v (= binding.

#+begin_src elisp :noweb-ref paredit-config
:bind (("C-c v (" . paredit-mode))
#+end_src

**** Usage

Once paredit mode is enabled, we can do the following:
- =C-right= slurp
  - src_elisp[:exports code]{(a (here) b)} \to  src_elisp[:exports code]{(a (here b))}
- =C-left= barf
  - src_elisp[:exports code]{(a (here b))} \to  src_elisp[:exports code]{(a (here) b)}
- =M-S= split sexp
  - with point before =b=, src_elisp[:exports code]{(a b)} \to  src_elisp[:exports code]{(a) (b)}
- =C-M-b= / =C-M-f= move backward/forward
- =C-M-u= / =C-M-n= move backward/forward out of enclosing list

You can enter a special edit mode by placing point on the codeblock below and entering =C-c '=.

#+begin_src elisp
'(a (here) b)

(progn
  (message "hi")
  (+ 40 2) :42)

(progn
  (let ((a 4))
    '(a (b c) d)
    (+ (* 12 3)
       (1+ 12))))


(+ 1 (* 2 3) 4)
#+end_src

*** <<inheritenv>> inheritenv

The [[https://github.com/purcell/inheritenv][inheritenv]] package configures background processes to adopt the =process environment= and =exec-path= of the calling Emacs buffer. This package is used by [[envrc][envrc]] which means that we don't really have to do anything if we configure the envrc to run the show for us.

#+begin_src elisp :tangle lang.example.el
;; https://github.com/purcell/inheritenv
(use-package inheritenv
  :straight (inheritenv :type git
                        :host github
                        :repo "purcell/inheritenv"))
#+end_src

*** <<envrc>> envrc

By using the [[https://github.com/purcell/envrc][envrc]] package, buffer-local variables can be managed through the configuration of the [[https://direnv.net/][direnv]] .envrc file.

#+begin_src elisp :tangle lang.example.el
;; https://github.com/purcell/envrc
(use-package envrc
  :straight (envrc :type git
                   :host github
                   :repo "purcell/envrc")
  :after inheritenv
  :hook (after-init . envrc-global-mode)
  :bind-keymap ("C-c e" . envrc-command-map))
#+end_src

We bind =C-c e= to envrc to simplify access to mode toggles and reloading facilities.

The use of this package, will arm =shell-command-to-string= to call [[inheritenv][inheritenv]] through the =envrc-propagate-environment= call.

**** TODO Configure exec path

When using changes to the path may go unnoticed to Emacs which results to shell blocks in Org files not having the proper path configurations and therefore not being able to find the right executables.

#+begin_src elisp :tangle lang.example.el
;; https://github.com/purcell/exec-path-from-shell
(use-package exec-path-from-shell
  :straight (exec-path-from-shell :type git
                                  :host github
                                  :repo "purcell/exec-path-from-shell")
  :config (when (daemonp)
            (exec-path-from-shell-initialize)))
#+end_src

https://emacs.stackexchange.com/questions/53773/best-way-to-make-org-babel-blocks-aware-of-my-path-and-other-environment-variab

**** Example Usage

As a Nix ❄️ user, there are a few [[https://github.com/direnv/direnv/wiki/Nix][options]] available for managing direnv environments of which [[https://github.com/nix-community/nix-direnv][nix-direnv]] happened to be an easier and faster option. As an example, observe the following shell.nix:

#+begin_src nix :tangle playground/nix-direnv/shell.nix
# save this as shell.nix
{ pkgs ? import <nixpkgs> {}}:

pkgs.mkShell {
  nativeBuildInputs = [ pkgs.hello ];
}
#+end_src

along with the following *.envrc*

#+begin_src bash :tangle playground/nix-direnv/.envrc
use nix
#+end_src

which defines an environment that is configured upon directory entry.

Dropping into an appropriate shell through Projectile shell ~(projectile-run-shell)~ (or similar) commands should result to a pre-configured environment.

#+begin_center
Update the following snippet by tangling it and trying out the code blocks by opening the resulting buffer [[file:playground/nix-direnv/README.org]] and then copying the results back into the Org block. A bit tedious, but the safer way to test this since =org-edit-special= buffers are not file buffers and thus any ~(buffer-file-name)~ calls will come up empty.
#+end_center

#+begin_src org :tangle playground/nix-direnv/README.org
,#+title: Experimenting with envrc binary access

Just trying to get a handle of what we can reach from Emacs Org-Babel when utilizing envrc to manage environments.

,* Calling envrc binaries through =shell-command-to-string=

[[https://github.com/purcell/inheritenv#make-emacs-temp-buffers-inherit-buffer-local-environment-variables][Thanks to inheritenv]], the =shell-command-to-string= function can be used to run commands within the envrc environment.

,** With envrc-global-mode disabled

Without envrc enabled, the hello binary is not accessible.

,#+begin_src elisp
(envrc-mode -1)
(shell-command-to-string "hello")
,#+end_src

,#+RESULTS:
: zsh:1: command not found: hello

,** With envrc-global-mode enabled

With envrc enabled, the hello binary is found and successfully executed.

,#+begin_src elisp
(envrc-mode 1)
(shell-command-to-string "hello")
,#+end_src

,#+RESULTS:
: Hello, world!

,* Calling envrc binaries through a shell block

Regardless of the envrc enabled state, calling of envrc managed binaries seems to be a problem directly from bash blocks. The following block will therefore error out with a "bash: line 1: hello: command not found".

,#+begin_src org
,,#+begin_src bash :results none
hello
,,#+end_src
,#+end_src

,#+begin_src bash :results none
hello
,#+end_src

,#+begin_center
⚠️ Surely I must have overlooked the idiomatic way to configure Emacs to run ob-shell inside of nix shells so please shoot me a note if you know what I'm missing here. 🤷🏿‍♂️
,#+end_center

By defining a shebang header argument, we can inform Emacs how to run the code in a shell block but a simple shebang may not suffice as is evident by the "error: getting status of '/tmp/babel-K6A1O8/shell.nix': No such file or directory" error that is being throw when I run the following:

,#+begin_src org
,,#+begin_src bash :shebang "#!/usr/bin/env nix-shell" :results none
hello
,,#+end_src
,#+end_src

,#+begin_src bash :shebang "#!/usr/bin/env nix-shell" :results none
hello
,#+end_src

The ob-shell implementation copies the contents of a code block into a temporary directory, which breaks a nix-shell setup since the copy operation does not copy along the .nix files. I considered, figuring out how to copy shell.nix over and then realized that shell.nix may import other files which opens a can of worms of which context to copy over to guarantee that the setup will work reliably. The safer way to go is to create a dynamic shebang that refers back to a shell.nix in the source directory and not the temporary directory.

,#+begin_src elisp
(defun vidbina/ob-shell-nix-shebang ()
  "Shebang line for a nix-shell environment based on the buffer directory"
  (let ((nix-directory (expand-file-name "shell.nix" (file-name-directory (buffer-file-name)))))
    (format "#!/usr/bin/env nix-shell\n#!nix-shell -i bash %s" nix-directory)))
,#+end_src

Note that we assume that there is a shell.nix in the buffer directory. This will break if we define our shell under a different filename but I felt that assuming that a shell.nix existed was safer bet than assuming that I would know how many nix files (in whichever directory structure) to copy over to a temporary directory. 🤷🏿‍♂️

,#+begin_src org
,,#+begin_src bash :shebang (vidbina/ob-shell-nix-shebang) :results verbatim
hello
,,#+end_src
,#+end_src

,#+begin_src bash :shebang (vidbina/ob-shell-nix-shebang) :results verbatim
hello
,#+end_src

,#+RESULTS:
: Hello, world!
#+end_src

** LSP

*** TODO Eglot

#+begin_src elisp :tangle lang.example.el
;; https://github.com/joaotavora/eglot
(use-package eglot
  :straight (eglot :type git
                   :host github
                   :repo "joaotavora/eglot"))
#+end_src

*** COMMENT Emacs LSP

**** LSP-mode

#+begin_src elisp :tangle lang.example.el
;; https://emacs-lsp.github.io/lsp-mode/page/installation/#vanilla-emacs
(use-package lsp-mode
  :straight (lsp-mode :type git
                      :host github
                      :repo "emacs-lsp/lsp-mode")
  :bind (:map lsp-mode-map ("TAB" . completion-at-point))
  :init
  (setq-default read-process-output-max (* 1024 1024))
  (setq  gc-cons-threshold (* 100 1024 1024))
  ;;(setq lsp-keymap-prefix "C-c C-M-l")
  ;;(setq lsp-log-io t) ;; ⚠️ turn off for performance
  :hook ((java-mode . lsp)
         (go-mode . lsp))
  :commands
  (lsp lsp-deferred)
  ;;:config
  ;;(define-key lsp-mode-map (kbd "C-c C-M-l") lsp-command-map)
  ;;(lsp-enable-which-key-integration t)
  )
#+end_src

**** LSP-ui

#+begin_src elisp :tangle lang.example.el
;; https://emacs-lsp.github.io/lsp-mode/page/installation/#use-package
;; https://config.daviwil.com/emacs
;; https://github.com/emacs-lsp/lsp-ui
(use-package lsp-ui
  :straight t
  :hook (lsp-mode . lsp-ui-mode)
  :config
  (setq lsp-ui-sideline-enable t
        lsp-ui-sideline-show-hover nil
        lsp-ui-doc-position 'bottom)
  (lsp-ui-doc-show))
#+end_src

**** Ivy Integration

The Ivy completion framework can be used in combination with Emacs LSP through the native [[https://github.com/emacs-lsp/lsp-ivy][lsp-ivy integration]].

#+begin_src elisp :tangle lang.example.el
;; https://github.com/emacs-lsp/lsp-ivy
(use-package lsp-ivy
  :straight t
  :hook (lsp-mode . lsp-ivy-mode))
#+end_src

**** Treemacs Integration

The Treemacs tree layout explorer can be used in combination with Emacs LSP through the [[https://github.com/emacs-lsp/lsp-treemacs][lsp-treemacs integration]].

#+begin_src elisp :tangle lang.example.el
;; https://github.com/emacs-lsp/lsp-treemacs
(use-package lsp-treemacs
  :straight t
  :commands lsp-treemacs-errors-list
  :after lsp-mode)
#+end_src

**** Docker Integration

In order to use LSP with projects where the language servers runs inside Docker containers, one can use the [[https://github.com/emacs-lsp/lsp-docker][lsp-docker integration]].

#+begin_src elisp :tangle lang.example.el
;; https://github.com/emacs-lsp/lsp-docker
(setq lsp-docker-client-configs
      '((:server-id bash-ls :docker-server-id bashls-docker :server-command "bash-language-server start")
        (:server-id clangd :docker-server-id clangd-docker :server-command "clangd")
        (:server-id css-ls :docker-server-id cssls-docker :server-command "css-languageserver --stdio")
        (:server-id dockerfile-ls :docker-server-id dockerfilels-docker :server-command "docker-langserver --stdio")
        (:server-id gopls :docker-server-id gopls-docker :server-command "gopls")
        (:server-id html-ls :docker-server-id htmls-docker :server-command "html-languageserver --stdio")
        (:server-id pyls :docker-server-id pyls-docker :server-command "pyls")
        (:server-id ts-ls :docker-server-id tsls-docker :server-command "typescript-language-server --stdio")))
#+end_src

#+begin_src elisp :tangle lang.example.el
;; https://github.com/emacs-lsp/lsp-docker
(use-package lsp-docker
  :straight (lsp-docker :type git
                        :host github
                        :repo "emacs-lsp/lsp-docker")
  :after lsp-mode
  ;;:init
  ;;(setq lsp-docker-client-packages '()
  ;;      lsp-docker-client-configs '())
  :config
  (lsp-docker-init-clients :path-mappings '(("/home/vidbina/src" . "/projects"))
                           ;;:docker-image-id "vidbina/lsp-docker-langservers:latest"
                           :client-packages lsp-docker-default-client-packages
                           :client-configs lsp-docker-default-client-configs
                           ;;:client-configs '((:server-id 'clangd
                           ;;                              :docker-server-id 'examplels-docker
                           ;;                              :docker-image-id "vidbina/lsp-docker-langservers:latest"
                           ;;                              :docker-container-name "vidbina-lsp-clangd"
                           ;;                              :server-command "ccls"
                           ))
#+end_src

***** TODO Language-specific configuration

Refactor the =lsp-docker-client-configs= such that the LSP config for every language is defined within the language's chapter within this config.

* Developer Notes

** Tangle Helper

The =my-dotfiles-tangle-wrapper= helper allows us to spawn an Emacs session with our freshly tangled configuration in order to spot early errors.

#+CAPTION: Screenshot of the a blank Emacs session automatically started by the tangle helper.
[[file:images/screenshot-tangle-helper-full.png]]

#+begin_src elisp :results none
(defun my-dotfiles-tangle-wrapper (orig-fun &rest args)
  (message "Wrapping %S with %S" orig-fun args)
  (let ((res (apply orig-fun args))
        (command "emacs")
        (args (list "-q"
                    "--load=init.el"
                    "--debug-init"
                    "--name=Emacs Test"
                    (format "--file=%s" buffer-file-name))))
    (apply #'start-process `("emacs-for-org-cite-export" nil ,command ,@args))
    (message "Done and got %S" res)
    res))
#+end_src

*** Enable

Enable the tangle helper by running the following snippet with ~(org-ctrl-c-ctrl-c)~ mapped by default to =C-c C-c=.

#+begin_src elisp :results none
(advice-add 'org-babel-tangle :around #'my-dotfiles-tangle-wrapper)
#+end_src

*** Disable

Disable the tangle helper by running the following snippet with ~(org-ctrl-c-ctrl-c)~ mapped by default to =C-c C-c=.

#+begin_src elisp :results none
(advice-remove 'org-babel-tangle #'my-dotfiles-tangle-wrapper)
#+end_src

* <<nix-config>> Nix ❄️ Home-manager Configuration

[[https://github.com/nix-community/home-manager][Home-manager]] allows management of a user environment through Nix -- the package-manager and language.

** General

We use Nix (the language) to define our Emacs builds for GNU/Linux and Darwin (macOS) systems. For both systems, we need to specify the inputs (sources), setup the emacs configuration directory and build and install Emacs.

*** Nix Sources

The Nix configuration will be importing the sources managed through [[https://github.com/nmattia/niv][niv]] and captured in the [[file:../nix/sources.nix]] file.

#+begin_src nix :noweb-ref nix-let-bindings
sources = import ../nix/sources.nix;
#+end_src

#+begin_center
💡 I don't manage my home-configuration through [[https://nix-community.github.io/home-manager/index.html#ch-nix-flakes][Nix Flakes]] because parts of my home-manager  configuration depends on files that I can't track in Git for privacy reasons. Nix Flakes doesn't play ball well when files are in play that aren't tracked, so I opted out of Flake-based usage and opted for managing versions with niv.
#+end_center

*** Setup Emacs configuration directory

We instruct home-manager to symlink the current directory into the [[file:~/.emacs.d]] destination.

#+begin_src nix :noweb-ref nix-home-emacsdir-source
home.file.".emacs.d".source = config.lib.file.mkOutOfStoreSymlink ./.;
#+end_src

*** Install Emacs

Home-manager enables the installation of Emacs through the =programs= facility. For the different systems that we use, we will define custom packages through [[nix-overlays-source][overlays]].

#+begin_src nix :noweb-ref nix-home-programs
programs.emacs = {
  enable = true;
  package = pkgs.my-emacs;
};
#+end_src

*** <<nix-overlays-source>> Overlays

The [[https://github.com/nix-community/emacs-overlay][emacs-overlay]] project is used to build the bundles of Emacs that we want on our systems.

#+begin_src nix :noweb-ref nix-let-bindings
emacs-overlay-src = sources."emacs-overlay";
#+end_src

Refer to the definitions for the [[nix-overlays-linux][Linux]] and [[nix-overlays-darwin][Darwin (macOS)]] overlays to understand what we're bundling into our Emacs builds.

** <<nix-config-linux>> 🐧 GNU/Linux

On GNU/Linux, home-manager allows for the installation of the Linux packages, configuration of systemd services, configuration of overlays and registration of XDG mimeApps entries in order to produce a "working environment". The complete GNU/Linux configuration looks as follows but is explained in the following subsections:

#+begin_src nix :noweb yes :tangle default.nix
{ config, pkgs, lib, options, ... }:

let
  <<nix-let-bindings>>
in
{
  <<nix-home-emacsdir-source>>

  <<nix-linux-packages>>

  <<nix-home-programs>>

  <<nix-linux-services>>

  <<nix-linux-overlays>>

  <<nix-linux-mime>>
}
#+end_src

*** <<nix-overlays-linux>> Overlays

Using [[https://github.com/nix-community/emacs-overlay][emacs-overlay]], we define an Emacs build that bundles packages that are difficult to install just with straight on account of non-elisp dependencies such as system dependencies that may require special privileges of a specialized build process.

#+begin_src nix :noweb-ref nix-linux-overlays
nixpkgs.overlays = [
  (import emacs-overlay-src)

  (self: super: {
    my-emacs =
      let
        emacs = (pkgs.emacsGit.override {
          nativeComp = true;
          withSQLite3 = true;
          withGTK2 = false;
          withGTK3 = false;
        });
        emacsWithPackages = (pkgs.emacsPackagesNgGen emacs).emacsWithPackages;
        bundled-emacs = emacsWithPackages (epkgs: (
          with epkgs; [
            notmuch
            vterm
            pdf-tools
          ]
        ) ++ (
          with epkgs.melpaStablePackages; [
          ]
        ) ++ (
          with epkgs.melpaPackages; [
          ]
        ));
        ripgrep-for-doom-emacs = (pkgs.ripgrep.override {
          withPCRE2 = true;
        });
        jupyter-for-emacs = (pkgs.python38.withPackages (ps: with ps; [
          jupyter
        ]));
      in
      (pkgs.buildEnv {
        name = "my-emacs";
        paths = [
          bundled-emacs
          pkgs.clang
          pkgs.cmake
          pkgs.coreutils
          pkgs.fd
          pkgs.multimarkdown
          jupyter-for-emacs
          ripgrep-for-doom-emacs
        ];
      });
  })
];
#+end_src

*** Packages

#+begin_src nix :noweb yes :noweb-ref nix-linux-packages
home.packages = with pkgs; let
  <<nix-linux-packages-let-bindings>>
in
[
  cask

  <<nix-linux-packages-e>>

  <<nix-linux-packages-emacs-org-protocol>>

  <<nix-linux-packages-emacs-mu4e>>

  <<nix-linux-packages-emacs-dired>>
];
#+end_src

**** Helpers

#+begin_src nix :noweb-ref nix-linux-packages-let-bindings
baseCommand = windowName:
  builtins.concatStringsSep " " [
    "emacsclient -a emacs"
    ''-F "((name . \\\"${windowName}\\\"))"''
    "-c"
  ];
#+end_src

**** Shorthand to emacsclient

#+begin_src nix :noweb-ref nix-linux-packages-e
(writeScriptBin "e" ''
  exec emacsclient -a emacs -c "$@"
'')
#+end_src

**** Emacs Org-Protocol

#+begin_src nix :noweb-ref nix-linux-packages-emacs-org-protocol
(makeDesktopItem {
  name = "emacs-org-protocol";
  exec = "${(baseCommand "emacs-org-protocol")} %u";
  comment = "Org Protocol";
  desktopName = "org-protocol";
  categories = builtins.concatStringsSep ";" [
    "Utility"
    "Database"
    "TextTools"
    "TextEditor"
    "Office"
  ] + ";";
  mimeType = builtins.concatStringsSep ";" [
    "x-scheme-handler/org-protocol"
  ] + ";";
  terminal = false;
})
#+end_src

**** Emacs mu4e

#+begin_src nix :noweb yes :noweb-ref nix-linux-packages-emacs-mu4e
<<nix-linux-packages-desktop-emacs-mu4e>>

<<nix-linux-packages-wrapper-emacs-mu4e>>
#+end_src

#+begin_src nix :noweb-ref nix-linux-packages-desktop-emacs-mu4e
# https://www.emacswiki.org/emacs/MailtoHandler
# https://dev.spacekookie.de/kookie/nomicon/commit/9e5896496cfd5da5754018887f7ad3b256b3ad80.diff
(makeDesktopItem {
  name = "emacs-mu4e";
  exec = "emacs-mu4e %u";
  comment = "Emacs mu4e";
  desktopName = "emacs-mu4e";
  type = "Application";
  categories = builtins.concatStringsSep ";" [
    "Network"
    "Email"
  ] + ";";
  mimeType = builtins.concatStringsSep ";" [
    # Email
    "x-scheme-handler/mailto"
    "message/rfc822"
  ] + ";";
  terminal = false;
})
#+end_src

#+begin_src nix :noweb-ref nix-linux-packages-wrapper-emacs-mu4e
(writeScriptBin "emacs-mu4e" ''
  set -e
  target_path=$@
  echo "Target: $target_path"

  exec emacsclient -a emacs -c -F "((name . \"emacs-dired\"))" -e "(vidbina-mime-handle-open-message-in-mu4e \"emacs-dired\" \"$target_path\")"
'')
#+end_src

**** Dired

#+begin_src nix :noweb yes :noweb-ref nix-linux-packages-emacs-dired
<<nix-linux-packages-desktop-emacs-dired>>

<<nix-linux-packages-wrapper-emacs-dired>>
#+end_src

#+begin_src nix :noweb-ref nix-linux-packages-desktop-emacs-dired
# https://emacs.stackexchange.com/questions/13927/how-to-set-emacs-as-the-default-file-manager
(makeDesktopItem {
  name = "emacs-dired";
  exec = "emacs-dired %f";
  comment = "Emacs Dired";
  desktopName = "emacs-dired";
  categories = builtins.concatStringsSep ";" [
    "Utility"
    "FileManager"
    "FileTools"
  ] + ";";
  mimeType = builtins.concatStringsSep ";" [
    "inode/directory"
    "inode/symlink"
  ] + ";";
  terminal = false;
})
#+end_src

#+begin_src nix :noweb-ref nix-linux-packages-wrapper-emacs-dired
(writeScriptBin "emacs-dired" ''
  set -e
  target_path=$(printf '%q\n' "$@" | xargs realpath -e)
  echo "Sanitized target to: $target_path"

  exec emacsclient -a emacs -c -F "((name . \"emacs-dired\"))" -e "(vidbina-mime-handle-open-directory \"emacs-dired\" \"$target_path\")"
'')
#+end_src

*** Service

#+begin_src nix :noweb-ref nix-linux-services
services.emacs = {
  # Restart using `systemctl --user restart emacs`
  enable = true;
  package = pkgs.my-emacs;

  client.enable = true;
};
#+end_src

*** XDG mimeApps

#+begin_src nix :noweb-ref nix-linux-mime
xdg.mimeApps.defaultApplications = {
  "inode/directory" = [ "emacs-dired.desktop" ];
  "inode/symlink" = [ "emacs-dired.desktop" ];

  "message/rfc822" = [ "emacs-mu4e.desktop" ];
  "x-scheme-handler/mailto" = [ "emacs-mu4e.desktop" ];

  "x-scheme-handler/org-protocol" = [ "emacs-org-protocol.desktop" ];
};
#+end_src

** PROTOTYPE <<nix-config-darwin>> 🍏 Darwin

On Darwin, the home-manager configuration is simpler (and more restricted) than the GNU/Linux configuration. For starters, we don't have the ability to configure services (since Darwin doesn't support systemd).

#+begin_src nix :noweb yes :tangle default-darwin.nix
{ config, pkgs, lib, options, ... }:

let
  <<nix-let-bindings>>
in
{
  <<nix-home-emacsdir-source>>

  <<nix-home-programs>>

  <<nix-darwin-overlays>>
}
#+end_src

*** <<nix-overlays-darwin>> Overlays

#+begin_center
🐉 This has not been sufficiently tested so use with caution. I'm using NixOS mainly, so anything Darwin-related has probably been run once on a MacBook that I haven't touched for a good 4 months at the time of writing (being [2022-06-30 Thu 18:31]).
#+end_center

Using [[https://github.com/nix-community/emacs-overlay][emacs-overlay]], we compose a custom Emacs build that looks quite similar to the GNU/Linux configuration sans the graphical facilities and native compilation capabilities. Furthermore, the Darwin configuration has some =makeDesktopItem= packages bundled within it.

#+begin_center
🤔 Looking at the [[https://nixos.wiki/wiki/Emacs][NixOS Emacs wiki entry]], it may be worthwhile to revaluate what the difference between =emacsGit=, used in my GNU/Linux config, and =emacsPgtkGcc= (now known as =emacsPgtkNativeComp=) really is.
#+end_center

#+begin_src nix :noweb-ref nix-darwin-overlays
nixpkgs.overlays = [
  (import emacs-overlay-src)

  (self: super: {
    my-emacs =
      let
        emacs = pkgs.emacsPgtkGcc;
        emacsWithPackages = (pkgs.emacsPackagesNgGen emacs).emacsWithPackages;
        bundled-emacs = emacsWithPackages (epkgs: (
          with epkgs; [
            notmuch
            vterm
            pdf-tools
          ]
        ) ++ (
          with epkgs.melpaStablePackages; [
          ]
        ) ++ (
          with epkgs.melpaPackages; [
          ]
        ));
        ripgrep-for-doom-emacs = (pkgs.ripgrep.override {
          withPCRE2 = true;
        });
        jupyter-for-emacs = (pkgs.python38.withPackages (ps: with ps; [
          jupyter
        ]));
      in
      (pkgs.buildEnv {
        name = "my-emacs";
        paths = [
          bundled-emacs
          pkgs.clang
          pkgs.cmake
          pkgs.coreutils
          pkgs.fd
          pkgs.multimarkdown
          jupyter-for-emacs
          ripgrep-for-doom-emacs

          # for Emacs
          (pkgs.makeDesktopItem {
            name = "org-protocol";
            exec = "${bundled-emacs}/bin/emacsclient --create-frame %u";
            comment = "Org Protocol";
            desktopName = "org-protocol";
            type = "Application";
            mimeType = "x-scheme-handler/org-protocol";
          })

          # for Emacs
          # https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-0.9.5.html
          # https://www.emacswiki.org/emacs/MailtoHandler
          # https://dev.spacekookie.de/kookie/nomicon/commit/9e5896496cfd5da5754018887f7ad3b256b3ad80.diff
          (pkgs.makeDesktopItem {
            name = "emacs-mu4e";
            exec = ''
              ${bundled-emacs}/bin/emacsclient --create-frame --eval "(browse-url-mail \"%u\")"
            '';
            comment = "Emacs mu4e";
            desktopName = "emacs-mu4e";
            type = "Application";
            mimeType = builtins.concatStringsSep ";" [
              # Email
              "x-scheme-handler/mailto"
              "message/rfc822"
            ];
          })
        ];
      });
  })
];
#+end_src

**** emacsPgtkNativeComp vs emacsGit

Looking at [[https://github.com/nix-community/emacs-overlay/blob/master/default.nix][emacs-overlay default.nix]], the diff between =emacsGit= and =emacsPgtkNativeComp= is basically that the latter extends the former with native compilation. 🤷🏿‍♂️

Perhaps we use differing builds because of issues like [[https://github.com/nix-community/emacs-overlay/issues/187][emacs-overlay issue 187]] but I simply can't recall how I settled on the current design.

***** Expansion

For reference's sake, observe how the definition of =emacsGit= wraps =mkGitEmacs=:

#+begin_src nix
emacsGit = mkGitEmacs "emacs-git" ./repos/emacs/emacs-master.json { withSQLite3 = true; };
#+end_src

****** TL;DR

The =emacsPgtkNativeComp= definition calls =mkPkgEmacs= and is listed below:

#+begin_src nix
emacsPgtkNativeComp = mkPgtkEmacs "emacs-pgtk-native-comp" ./repos/emacs/emacs-master.json { nativeComp = true; withSQLite3 = true; };
#+end_src

The =mkPgtkEmacs= definition just provides a wrapper around =mkGitEmacs=, removes the =--with-xft= configuration flag and adds the =--with-pgtk= flag.

#+begin_src nix
mkPgtkEmacs = namePrefix: jsonFile: { ... }@args: (mkGitEmacs namePrefix jsonFile args).overrideAttrs (
  old: {
    configureFlags = (super.lib.remove "--with-xft" old.configureFlags)
      ++ super.lib.singleton "--with-pgtk";
  }
);
#+end_src

****** Conclusion

It is fair to assume that =emacsPgtkNativeComp= expands to the following:

#+begin_src nix
(mkGitEmacs "emacs-pgtk-native-comp" ./repos/emacs/emacs-master.json {
  nativeComp = true;
  withSQLite3 = true;
}).overrideAttrs (old: {
  configureFlags = (super.lib.remove "--with-xft" old.configureFlags)
                   ++ super.lib.singleton "--with-pgtk";
});
#+end_src

The only diff being the change of name of the package, the attribute set (which now sets =nativeComp= to true) and the =configureFlags= override. Perhaps it is time to use =emacsPgtkNativeComp= for all builds after all. 🤷🏿‍♂️

* Footnotes

[fn:6] Different variants of Markdown may have slightly differing and sometimes conflicting notation for some simple formatting markers such as the ones needed to underline, boldface or italicize text.

[fn:4] By allowing the Emacs package system to load packages prior to engaging our selected package manager, it becomes harder to establish where package-related state gets introduced. By choosing to manage all packages declaratively (through code) through a single package manager, one creates a situation that is easier to debug (single actor to observe) and reproduce (by reevaluating the configuration) while being a tad more deterministic (reduced ability of imperatively grown global state to break the configuration).

[fn:3] Remember that we're just using =~/.emacs.d= to simplify the text, but if you use another /[[emacsconfdir][emacs configuration directory]]/ you'll need to substitute every occurence of that path accordingly)

[fn:2] I am the /perpetual beginner/ 🌱 so I'm mostly writing this for my future self. 😅

[fn:1] Literal in the "Literal Programming" way as coined by Donald Knuth. There are a bunch of interesting bytes on the topic at [[http://literateprogramming.com/][literateprogramming.com]] and numerous other resources that can be link-followed when starting from one of the more recent related HN threads as per [2022-06-30 Thu] to the article [[https://news.ycombinator.com/item?id=31301777#31302835][Donald Knuth was framed (2020)]].

[fn:5] Keywords can be recognized by the =:= (colon character) prefix.

* Local Variables

For convenience, we call =delete-trailing-whitespace= as outlined in an [[https://www.mail-archive.com/emacs-orgmode@gnu.org/msg112517.html][emacs-orgmode mailing thread]] to automatically clean up trailing whitespaces that may be artifact from tangling noweb refs that
1. contain line-breaks and are being indented or
2. have no noweb-ref writes

;;; Local Variables:
;;; eval: (add-hook 'org-babel-post-tangle-hook #'delete-trailing-whitespace)
;;; eval: (add-hook 'org-babel-post-tangle-hook #'save-buffer :append)
;;; End:
